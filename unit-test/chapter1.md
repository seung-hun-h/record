# 1. 단위 테스트의 목표
- 단위 테스트에 시간을 투자할 때는 항상 최대한 이득을 얻도록 노력해야 한다
- 테스트에 드는 노력을 최대한 줄이고 그에 따르는 이득을 최대화 해야 한다

## 1.1 단위 테스트 현황
- 단위 테스트를 작성해야 하는 것은 이제 기본이다
- 문제는 '좋은 단위 테스트를 작성하는 것은 어떤 의미인가?' 다
- 좋은 테스트와 좋지 않은 테스트의 차이는 취향이나 개인적인 선호도의 문제가 아니라 현재 작업 중인 중대한 프로젝트의 성패를 가르는 문제이다

## 1.2 단위 테스트의 목표
- 단위 테스트를 통해 더 나은 설계를 할 수도 있지만 이는 부수적인 효과이다
  - 낮은 결합도를 보여도 프로젝트는 대참사가 될 수도 있다
- 단위 테스트의 목표는 **소프트웨어 프로젝트의 지속가능한 성장을 가능하게 하는 것**이다
- 프로젝트가 진행하면서 개발 속도가 빠르게 감소하는 현상을 소프트웨어 엔트로프라고도 한다
- 코드 베이스에서 무언가를 수정할 때마다 엔트로피는 증가한다
  - 변경이 일어날 떄마다 무질서도는 증가하고, 안정성이 떨어져 코드 베이스를 신뢰할 수 없게 된다
- 단위 테스트는 **안정망** 역할을 하며, **회귀에 대한 보험**을 제공한다
  - 새로운 요구 사항에 맞게 리팩토링한 후에도 기존의 기능이 잘 작동하는지 확인하는데 도움이 된다

### 1.2.1 좋은 테스트와 좋지 않은 테스트를 가르는 요인
- 좋은 테스트는 소프트웨어 품질에 매우 많은 기여를 한다
- 나쁜 테스트는 프로젝트가 침체 단계에 접어드는 시간이 더 걸릴 수는 있지만 어쩄든 피할 수 없게 한다
- 단순히 테스트를 많이 작성하는 것이 좋은 것은 아니다. 테스트의 가치와 유지 비용을 모두 고려 해야 한다
  - 기반 코드를 리팩터링할 때 테스트도 리팩터링 해라
  - 각 코드 변경 시 테스트를 실행하라
  - 테스트가 잘못된 경고를 발생시킬 경우 처리하라
  - 기반 코드가 어떻게 동작하는지 이해하려고 할 때는 테스트를 읽는 데 시간을 투자하라
- 프로젝트의 성장을 위해서는 고품질 테스트에 집중 해야 한다

## 1.3 테스트 스위트 품질 측정을 위한 커버리지 지표
- 테스트 커버리지 지표는 괜찮은 부정 지표이지만, 좋지 않은 긍정 지표이다
- 코드 커버리지가 너무 적을 때는 테스트가 충분치 않다는 긍정 지표이다
- 하지만 코드 커버리지가 높다고 해서 모두 좋은 테스트틑 아니다

### 1.3.1 코드 커버리지 지표에 대한 이해
- 코드 커버리지 == 테스트 커버리지
- 코드 커버리지 = 실행 코드 라인 수 / 전체 라인 수

```java
public static boolean isLong(String input) {
    if (input.length() > 5) {
        return true; // 코드 커버리지 포함 안됨
    }
    return false;
}

public void test() {
    boolean result = isLong("abc");
    Assertions.assertThat(result).isFalse();
}
```
- 코드 커버리지는 4/5 = 80%
  - `return true`는 실행되지 않기 떄문이다
- 코드를 아래처럼 바꾸면 코드 커버리지는 100%가 된다


```java
public static boolean isLong(String input) {
    return input.length() > 5;
}
```
- 코드 커버리지는 장난치기 쉽다
- 코드를 작게하면 커버리지가 증가한다
- 코드를 더 작게 해도 테스트 스위트의 가치나 기반 코드베이스의 유지 보수성이 변경되지 않는다

### 1.3.2 분기 커버리지 지표에 대한 이해
- 분기 커버리지는 if 나 switch 와 같은 제어 구문에 중점을 둔다
- 분기 커버리지는 코드 커버리지의 단점을 극복할 수 있다
- 분기 커버리지 = 통과 분기 / 전체 분기 수

```java
public static boolean isLong(String input) {
    return input.length() > 5;
}

public void test() {
    boolean result = isLong("abc");
    Assertions.assertThat(result).isFalse();
}
```
- 위 코드의 분기 커버리지는 50%이다
- 분기 커버리지는 해당 분기를 구현하는데 얼마나 많은 코드가 필요한지 고려하지 않는다. 단지 분기의 개수만 다룬다

### 1.3.3 커버리지 지표에 대한 문제점
- 테스트 스위트의 품질을 결정하는데 커버리지 지표를 완전히 의존할 수 없다
  - 테스트 대상 시스템의 모든 가능한 결과를 검증한다고 보증할 수 없다
  - 외부 라이브러리의 코드 경로를 고려할 수 있는 커버리지 지표는 없다
- 어떤 메서드가 내부 속성에 새로운 값을 쓰고, 다른 값을 반환하면 이를 검증할 수 있는 방법은 없다
- 검증이 없는 테스트는 항상 통과한다
- 외부 라이브러리를 사용하는 경우 해당 코드 경로를 고려할 수 없다

### 1.3.4 특정 커버리지 숫자를 목표로 하기
- 커버리지 지표를 보는 가장 좋은 방법은 지표 그 자체로 보는 것이며 목표로 여겨서는 안된다
- 커버리지 숫자를 강요하면 개발자들은 테스트 대상에 신경 쓰지 못하고 결국 적절한 단위 테스트는 더욱 달성하기 어려워진다
- 시스템의 핵심 부분은 커버리지를 높게 두는 것이 좋다. 하지만 이 높은 수준을 요구 사항으로 삼는 것은 좋지 않다. 그 차이는 미미하지만 매우 중요하다
- 커버리지 지표는 좋은 부정 지표지만, 나쁜 긍정 지표이다
  - 커버리지 숫자가 낮으면 문제 징후라고 볼 수 있지만, 높다고 좋은 것은 아니다

## 1.4 무엇이 성공적인 테스트 스위트를 만드는가?
- 믿을만 한 방법은 스위트 내 각 테스트를 하나씩 따로 평가하는 것뿐이다
- 테스트 스위트가 얼마나 좋은지 자동으로 확인할 수 없다. 개인에게 맡겨야 한다
- 성공적인 테스트 스위트는 다음과 같은 특성을 가지고 있다
  - 개발 주기에 통합돼 있다
  - 코드베이스에서 가장 중요한 부분만을 대상으로 한다
  - 최소한의 유지비로 최대의 가치를 끌어낸다

### 1.4.1 개발 주기에 통합돼 있음
- 모든 테스트는 개발 주기에 통합돼야 한다
- 이상적으로는 코드가 변경될 때마다 아무리 작은 것이라도 실행해야 한다

### 1.4.2 코드베이스에서 가장 중요한 부분만을 대상으로 함
- 코드베이스의 모든 부분에 똑같이 주목할 필요는 없다
- 테스트가 주는 가치는 테스트 구조 뿐만이 아니라 검증하는 코드에도 있다
- 시스템의 가장 중요한 부분에 단위 테스트 노력을 기울이고, 다른 부분은 간략하게 또는 간점적으로 검증하는 것이 좋다
- 비즈니스 로직 테스트가 시간 투자 대비 최고의 수익을 낼 수 있다
- 일반적으로는 도메인 모델에 관심을 더 많이 갖는 것이 옳다
  - 다른 부분(인프라 코드, DB, 서드 파티 시스템, 모든 것을 하나로 묶는 코드)도 단위 테스트를 철저히 해야 하는 경우도 있다
- 도메인 모델을 코드베이스 중 중요하지 않은 부분과 분리해야 한다.

### 1.4.3 최소 유지비로 최대 가치를 끌어냄
- 단위 테스트에서 가장 어려운 부분이 최소 유지비로 최대 가치를 달성하는 것이다
- 가치가 유지비를 상회하는 테스트만 스위트에 유지하는 것이 중요하다
  - 이러한 속성을 두 가지로 나눌 수 있다
    - 가치 있는 테스트 식별하기
    - 가치 있는 테스트 작성하기
  - 가치가 높은 테스트를 식별하기 위해서는 기준틀이 필요하다
  - 가치 있는 테스트를 작성하려면 코드 설계 기술을 알아야 한다
  - 단위 테스트와 기반 코드는 서로 얽혀 있으므로 코드베이스에 노력을 많이 기울이지 않으면 가치 있는 테스트를 만들 수 없다