# 2. 단위 테스트란 무엇인가
- 테스트에 접근하는 두 가지 견해는 '고전파'와 '런던파'이다

---

## 2.1 단위 테스트의 정의
- 단위 테스트의 주요 세 가지 속성
  1. 작은 코드 조각 단위로 검증한다
  2. 빠르게 수행한다
  3. 격리된 방식으로 처리하는 자동화된 테스트다
- 1, 2 번째 속성에는 이견이 거의 없다
- 3 번째 속성의 격리가 무엇인지에 대한 의견 차이로 고전파와 런던파로 나뉜다

### 2.1.1 격리 문제에 대한 런던파의 접근
- 런던파에서는 테스트 대상 시스템을 협력자에게서 격리한다
  - 하나의 클래스가 다른 하나의 클래스 혹은 여러 클래스를 의존하면 모든 의존성을 테스트 대역(test double)으로 대체한다
  - 외부 영향과 분리해서 테스트 대상 클래스에만 집중할 수 있다
- 런던파 접근의 장점
  - 테스트가 실패하면 어느 부분이 고장났는지 확실히 알 수 있다
  - 객체 그래프를 분할 할 수 있다
    - 복잡한 의존성을 대체하고, 의존성의 의존성을 다룰 필요가 없어 테스트 준비를 크게 줄일 수 있다
- 테스트 대역과 목은 다르다
  - 테스트 대역은 실행과 관련 없이 모든 종류의 가짜 의존성을 설명하는 포괄적인 용어이다
  - 목은 그러한 의존성의 하나일 뿐이다
- 고전파에서는 테스트 이후 상태를 검증하지만, 런던파는 상호작용을 검증한다

### 2.1.2 격리 문제에 대한 고전파의 접근
- 고전파 접근 방법에서는 코드를 반드시 격리할 필요는 없다. 대신 단위 테스트는 격리된 상태에서 실행되어야 한다
  - 단위 테스트의 실행 결과가 서로 영향을 받지 않는다
  - 각각의 테스트를 격리하는 것은 여러 클래스가 모두 메모리에 상주하고 공유 상태에 도달하지 않는 한, 여러 클래스를 한 번에 테스트 해도 괜찮다
- 테스트 대역을 사용할 수 있지만, 보통 테스트 간에 공유 상태를 일으키는 의존성에 대해서만 사용한다
  - 공유 의존성
    - 테스트 간에 공유되고 서로의결과에 영향을 미칠 수 있는 수단을 제공하는 의존성
    - 정적 가변 필드, 데이터베이스 등
  - 비공개 의존성
    - 공유되지 않는 의존성
  - 프로세스 외부 의존성
    - 애플리케이션 실행 프로세스 외부에서 실행되는 의존성
    - 아직 메모리에 없는 데이터에 대한 프록시
- 공유 의존성은 테스트 클래스가 아닌 단위 테스트 간에 공유한다
  - 싱글턴 의존성은 각 테스트에서 새 인스턴스를 만들 수 있다면 공유되지 않는다
  - 파일 시스템이나 데이터베이스는 새로 만들 수 없으므로 테스트간에 공유되거나 대체되어야 한다
- 공유 의존성을 대체하는 또 다른 이유는 테스트 실행 속도를 높이기 위함이다
  - 공유 의존성에 대한 호출은 비공개 의존성에 대한 호출보다 더 오래걸린다
  - 공유 의존성은 보통 실행 프로세스 외부에 있는 반면, 비공개 의존성은 그 범위를 벗어나지 않기 때문이다

---

## 2.2 단위 테스트의 런던파와 고전파
- 런던파와 고전파로 나뉜 원인은 격리 특성에 있다
  - 런던파는 테스트 대상 시스템에서 협력자를 격리하는 것으로 본다
  - 고전파는 단위 테스트끼리 격리하는 것으로 본다

||격리 주체|단위의 크기|테스트 대역 사용 대상|
|-|------|--------|---------------|
|런던파|단위|단일 클래스|불변 의존성 외 모든 의존성|
|고전파|단위 테스트|단일 또는 여러 클래스|공유 의존성|

### 2.2.1 고전파와 런던파가 의존성을 다루는 방법
**런던파**
- 불변 의존성 외 다른 모든 의존성은 대체한다
  - 불변 객체란 값이 절대 변하지 않는 객체를 말한다
  - 불변 객체는 값 객체(Value Object) 혹은 값이라고 한다
  - 불변 객체의 두 인스턴스가 물리적으로는 다르지만 논리적으로 같다면(같은 값을 가지고 있다면) 같은 객체라고 본다

**고전파**
- 공유 의존성만 대체한다

- 의존성 계층
  - 의존성은 공유되거나 비공개일 수 있다
  - 비공개 의존성은 변경 가능하거나 불변일 수 있다
  - 고전파에서는 공유 의존성을 대체한다.
  - 런던파에서는 공유 의존성과 변경가능한 비공개 의존성을 대체한다

- **모든 프로세스 외부 의존성이 공유 의존성의 범주에 있는 것은 아니다**
  - 공유 의존성의 거의 항상 프로세스 외부에 존재한다
  - 프로세스 외부에 존재하는 의존성이 항상 공유되는 것은 아니다
  - 데이터베이스는 공유 의존성이면서 프로세스 외부 의존성이다
  - 읽기 전용 API는 프로세스 외부 의존성이지만 공유 의존성은 아니다. 데이터를 변경할 수 없기 때문이다.
  - 프로세스 외부 의존성이 불변이라고 하더라도 테스트에 반드시 포함해야하는 것은 아니다. 느리다면 대체하고 빠르고 안정적이면 포함한다

---

## 2.3 고전파와 런던파의 비교
### 2.3.1 한 번에 한 클래스만 테스트하기
- 런던파는 입자성이 좋다. 테스트가 세밀해서 한 번에 한 클래스만 확인한다
- OOP 개발자들은 자연스럽게 클래스를 테스트에서 검증할 원자 단위로 취급하게 되지만, 오해의 소지가 있다
- 코드의 입자성을 목표로하는 것은 도움이 되지 않는다
- 테스트는 응집도가 높고 의미가 있어야 한다
  1. 강아지를 부르면 나에게 온다
  2. 강아지를 부르면 강아지는 먼저 왼쪽 앞다리와 뒷다리를 움직이고, 이어 오른쪽 앞다리와 뒷다리를 움직인 후 꼬리를 흔든다...
  - 실제 동작(개가 주인에게 오는 것) 대신 개별 클래스(다리, 머리, 꼬리)를 목표로 할 때 두번째와 같은 테스트가 생겨난다

### 2.3.2 상호 연결된 클래스의 큰 그래프를 단위 테스트하기
- 런던파는 상호 연결된 클래스의 그래프가 커져도 테스트하기 쉽다
- 하지만 이러한 추리과정은 잘못된 문제에 초점을 맞추고 있다
  - 상호 연결된 클래스의 크고 복잡한 그래프를 테스트할 방법을 찾는 대신, 먼저 이러한 클래스 그래프를 갖지 않는데 집중해야 한다
  - 클래스 그래프가 커진 것은 대개 설계의 잘못이다
- 목을 사용하는 것은 문제를 감추기만 할 뿐, 원인을 해결하지 못한다

### 2.3.3 버그 위치 정확히 찾아내기
- 런던파의 테스트는 시스템에 버그가 발생하면 SUT에 버그가 포함된 테스트만 실패한다
- 고전파의 테스트는 하나의 버그가 전체 시스템에 걸쳐 테스트를 야기하는 파급효과를 가진다
  - 문제의 원인을 파악하고 디버깅하기 어려워진다
- 고전파의 문제는 테스트를 정기적으로 실행하면 그리 큰 문제는 아니다
  - 테스트를 정기적으로 수행하면 마지막으로 한 수정이 무엇인지 알기 때문에 문제를 찾는 것은 그리 어렵지 않다
- 고전파의 테스트가 계단식으로 실패하는 것 그 자체가 의미있다
  - 방금 고장낸 그 코드가 전체 시스템에 영향을 미친다는 것을 알 수 있다

### 2.3.4 고전파와 런던파 사이의 다른 차이점
1. 테스트 주도 개발(Test-Driven Development)을 통한 시스템 설계 방식
2. 과도한 명세(Over-Specification) 문제

- 런던파의 단위 테스트는 하향식 TDD로 이루어진다
  - 전체 시스템에 대한 기대치를 설정하는 상위 레벨 테스트부터 시작한다
  - 목을 사용해 예상 결과를 달성하고자 시스템이 통신해야 하는 협력자를 지정한다
  - 그런 다음 모든 클래스를 구현할 때까지 클래스 그래프를 다져나간다
  - 목을 사용하여 실제 구현을 뒤로 미룬다

- 고전파의 단위 테스트는 상향식 TDD로 이루어진다
  - 도메인 모델을 시작으로 최종 사용자가 소프트웨어를 사용할 수 있을 때까지 계층을 그 위에 더 둔다

- 고전파와 런던파의 가장 중요한 차이점은 과도한 명세 문제, 즉 테스트가 SUT의 구현 세부 사항에 결합되는 것이다
  - 런던 스타일은 고전 스타일보다 테스트가 구현에 더 결합되는 편이다
  - 이로 인해 런던 스타일과 목을 전반저그올 아무데나 쓰는 것에 대해 주로 이의 제기가 된다

---

## 2.4 두 분파의 통합 테스트
- 단위 테스트는 다음과 같은 특징이 있는 자동화된 테스트다
    1. 작은 코드 조각을 검증
    2. 빠르게 수행
    3. 격리된 방식으로 수행
- 고전파 관점에서 다시 정의하면 단위 테스트는
    1. 단일 동작 단위를 검증하고
    2. 빠르게 수행하고
    3. 다른 테스트와 별도록 처리한다
- 통합 테스트는 이러한 기준 중 하나를 충족하지 않는 테스트이다
  - 공유 의존성(ex: 데이터베이스)에 접근하는 테스트는 다른 테스트와 분리해 실행할 수 없다
    - 한 테스트에서 데이터베이스의 상태를 변경하면 병렬로 실행되는 다른 테스트에 간섭한다
    - 이러한 간섭을 피하려면 추가적으로 조치해야 한다
  - 프로세스 외부 의존성에 접근하면 테스트가 느려진다
  - 둘 이상의 동작 단위를 검증할 떄는 통합 테스트다
    - 비슷한 단계를 따르지만 다른 동작 단위를 검증하는 느린 테스트 두 개를 하나의 테스트로 통합할 수도 있다
    - 다른 팀이 개발한 모듈이 둘 이상 있을 때 통합 테스트로 어떻게 작동하는 지 검증할 수 있다

### 2.4.1 통합 테스트의 일부인 엔드 투 엔드 테스트
- 통합 테스트는 공유 의존성, 프로세스 외부 의존성뿐 아니라 조직 내 다른 팀이 개발한 코드 등과 통합해 작동하는지 검증하는 테스트이다
- 엔드 투 엔드 테스트는 통합 테스트의 일부이지만, 일반적으로 엔드 투 엔트 테스트가 의존성을 더 많이 포함한다
- 일반적으로 통합 테스트는 프로세스 외부 의존성을 한 두개만 갖고 작동한다
- 엔드 투 엔드 테스트는 프로세스 외부 의존성을 전부 또는 대다수 갖고 작동한다
- 엔드 투 엔드 테스트는 모든 외부 애플리케이션을 포함해 시스템을 최종 사용자의 관점에서 검증하는 것을 의미한다
- 엔드 투 엔드 테스트는 유지 보수 측면에서 가장 비용이 많이 들기 때문에 모든 단위 테스트와 통합 테스트를 통과한 후 빌드 프로세스 후반에 실행하는 것이 좋다
- 엔드 투 엔드 테스트를 하더라도 여전히 테스트 대역을 사용할 필요가 있고, 통합 테스트와의 경계가 뚜렷하지 않