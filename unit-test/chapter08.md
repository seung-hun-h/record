# 8. 통합 테스트를 하는 이유
## 8.1 통합 테스트는 무엇인가?
### 8.1.1 통합 테스트의 역할
- 단위 테스트는 다음 세 가지 요구사항을 만족하는 테스트다
  - 단일 동작 단위를 검증하고
  - 빠르게 수행하고
  - 다른 테스트와 별도로 처리한다
- 세 가지 요구 사항 중 하나라도 충족하지 않으면 통합 테스트에 속한다
- 통합 테스트는 대부분의 시스템이 프로세스 외부 의존성과 통합해 어떻게 동작하는지를 검증한다
  - 컨트롤러 사분면에 속하는 코드를 테스트한다
  - 단위 테스트는 도메인 모델을 다루는 반면, 통합 테스트는 프로세스 외부 의존성과 도메인 모델을 연결하는 코드를 확인한다

### 8.1.2 다시 보는 테스트 피라미드
- 단위 테스트와 통합 테스트간 균형을 유지하는 것이 중요하다
- 통합 테스트는 유지비가 많이 든다
  - 프로세스 외부 의존성 운영이 필요함
  - 관련된 협력자가 많아서 테스트가 비대해짐
- 통합 테스트는 회귀 방지와 리팩터링 내성이 우수하다
  - 더 많은 코드를 거친다
  - 제품 코드와 결합도가 낮다
- 단위 테스트로 가능한 많은 비즈니스 시나리오의 예외 상황을 확인한다
- 통합 테스트는 주요 흐름과 단위 테스트가 다루지 못하는 기타 예외 상황을 다룬다
- 단위 테스트를 하면 유지비를 절감할 수 있고, 통합 테스트가 비즈니스 시나리오당 하나 또는 두 개 있으면 시스템 전체의 정확도를 보장할 수 있다
- 아주 간단한 애플리케이션의 경우 단위 테스트가 의미 없을 수 있다
- 통합 테스트는 단순한 애플리케이션에서 가치가 있다

### 8.1.3 통합 테스트와 빠른 실패
- 통합 테스트에서 프로세스 외부 의존성과의 상호 작용을 모두 확인하려면 가장 긴 주요 흐름을 선택하라
  - 모든 상호 작용을 거치는 흐름이 없으면, 외부 시스템과의 통신을 모두 확인하는데 필요한 만큼 통합 테스트를 추가로 작성하라

```c#
// User
public void ChangeEmail(string newEmail, Company company) {
    Precondition.Requires(CanchangeEmail() == null);
    //..
}


// UserController
public string ChangeEmail(int userId, string newEmail) {
    object[] userData = _database.GetUserById(userId);
    User user = UserFactory.Create(userData);

    string error = user.CanChangeEmail();
    if (error != null) {
        return error;
    }

    //...
}
```

- 컨트롤러가 먼저 `CanChangeEmail()`을 참조하지 않고, 이메일을 변경하려고 하면 애플리케이션이 충돌한다
  - 처음 실행으로 버그가 드러나므로 쉽게 알아차리고 고칠 수 있다
  - 데이터 손상으로 이어지지 않는다
- `User`에 사전 조건이 있는지를 테스트 해야 하며, 이는 단위 테스트면 충분하다
- 버그를 빨리 나타나게 하는 것을 파른 실패 원칙(Fast Fail Principle)이라고 한다
  - 예기치 않은 오류가 발생하자마자 현재 연산을 중단하는 것을 빠른 실패 원칙이라 한다

## 8.2 어떤 프로세스 외부 의존성을 직접 테스트해야 하는가?
- 통합 테스트는 시스템이 프로세스 외부 의존성과 어떻게 통합하는지를 검증한다
- 검증을 구현하는 방식은 두 가지가 존재한다
  - 실제 프로세스 외부 의존성을 사용한다
  - 해당 의존성을 목으로 대체한다

### 8.2.1 프로세스 외부 의존성의 두 가지 유형
- 프로세스 외부 의존성의 두 가지 유형
  - 관리 의존성
    - 애플리케이션을 통해서만 접근할 수 있는 프로세스 의부 의존성
    - 예를 들어 데이터베이스가 있다
  - 비관리 의존성
    - 해당 의존성과의 상호 작용을 외부에서 볼 수 있다
    - 예를 들어 SMTP 서버와 메시지 버스 등이 있다

- 관리 의존성은 실제 인스턴스를 사용하고, 비관리 의존성은 목으로 대체하라
- 비관리 의존성에 대한 통신 패턴을 유지해야 하는 것은 하위 호환성을 지켜야한다. 이러한 작업에는 목이 제격이다
- 관리 의존성과 통신하는 것은 애플리케이션 뿐이므로 하위 호환성을 지킬 필요가 없다. 중요한 것은 시스템의 최종 상태다.

### 8.2.2 관리 의존성이면서 비관리 의존성인 프로세스 외부 의존성 다루기
- 때로는 관리 의존성과 비관리 의존성 모두의 속성을 나타내는 프로세스 외부 의존성이 있다
  - 좋은 예로, 다른 애플리케이션에서 접근할 수 있는 데이터베이스가 있다
- 시스템 간의 통합을 구현하는 데 데이터베이스를 사용하면 시스템이 서로 결합되고 추가 개발을 복잡하게 만들기 때문에 좋지 않다
  - API나 메시지 버스를 사용하는 것이 더 낫다
- 이미 공유 데이터베이스가 있고 근래에 할 수 있는 것이 아무 것도 없으면 테이블을 비관리 의존성으로 취급하라
  - 테이블이 사실상 메시지 버스 역할을 하고, 각 행이 메시지 역할을 한다
  - 이러한 테이블을 이용한 통신 패턴이 바뀌지 않도록 하려면 목을 하용하라
  - 그리고 나머지 데이터베이스를 관리 의존성으로 처리하고 데이터 베이스의 최종 상태를 검증하라

### 8.2.3 통합 테스트에서 실제 데이터베이스를 사용할 수 없다면 어떻게 해야 할까?
- 데이터베이스를 그대로 테스트할 수 없으면 통합 테스트를 아예 작성하지 말고 도메인 모델의 단위 테스트에만 집중하라

## 8.3 통합 테스트: 예제
- 생략

## 8.4 의존성 추상화를 위한 인터페이스 사용
### 8.4.1 인터페이스와 느슨한 결합
- 많은 개발자가 데이터베이스나 메시지 버스와 같은 프로세스 외부 의존성을 위해 인터페이스를 도압한다
- 심지어 인터페이스에 구현이 단 하나만 존재하는 경우에도 그렇다
- 인터페이스를 사용하는 일반적이유는 다음과 같다
  - 프로세스 외부 의존성을 추상화해 느슨한 결합을 달성한다
  - 기존 코드를 변경하지 않고 새로운 기능을 추가해 OCP 원칙을 지킨다
- 하지만 단일 구현을 위한 인터페이스는 추상화가 아니며, 해당 인터페이스를 구현하는 구체 클래스보다 결합도가 낮지 않다
- 두 번째 이유는 더 기본적인 원칙인 YAGNI(You aren't gonna need it)를 위반하기 때문에 잘못된 생각이다
  - YAGNI는 현재 필요하지 않는 기능에 시간을 들이지 말라는 것이다

### 8.4.2 프로세스 외부 의존성에 인터페이스를 사용하는 이유는 무엇인가?
- 프로세스 외부 의존성에 인터페이스를 두는 이유는 목을 사용하기 위함이다
  - 인터페이스가 없으면 테스트 대역을 만들 수 없으므로 테스트 대상 시스템과 프로세스 외부 의존성 간의 상호 작용을 확인할 수 없다
- 의존성을 목으로 처리할 필요가 없는 한, 프로세스 외부 의존성에 대한 인터페이스를 두지 마라

### 8.4.3 프로세스 내부 의존성을 위한 인터페이스 사용
- 떄로는 프로세스 내부 의존성도 인터페이스 기반인 코드를 볼 수 있다
- 도메인 클래스에 대해 인터페이스를 도입하는 경우에도 목을 사용하기 위함이다(단일 구현인 경우)
- 하지만 프로세스 외부 의존성과 달리 도메인 클래스 간의 상호 작용을 확인해서는 안된다
  - 이는 깨지기 쉬운 테스트로 이어지고 리팩터링 내성이 떨어지게 된다

## 8.5 통합 테스트 모범 사례
- 통합 테스트를 최대한 활용하는 데 도움이 되는 몇 가지 지침이 존재한다
  - 도메인 모델 경계 명시하기
  - 애플리케이션 내 계층 줄이기
  - 순환 의존성 제거하기

### 8.5.1 도메인 모델 경계 명시하기
- 항상 도메인 모델을 코드베이스에서 명시적이고 잘 알려진 위치에 둬라
- 단위 테스트는 도메인 모델과 알고리즘을 대상으로하고, 통합 테스트는 컨트롤러를 대상으로 한다
- 도메인 클래스와 컨트롤러 사이의 명확한 경계로 단위 테스트와 통합 테스트의 차이점을 쉽게 구별할 수 있다

### 8.5.2 계층 수 줄이기
- 애플리케이션에 추상 계층이 너무 많으면 코드베이스를 탐색하기 어렵고 아주 간단한 연산이라 해도 숨은 로직을 이해하기가 너무 어려워진다
- 모든 기능이 각각의 계층으로 전개되면 모든 조각을 하나의 그림으로 만드는 데 상당한 노력이 필요하다
- 추상화가 지나치게 많으면 단위 테스트와 통합 테스트에도 도움이 되지 않는다
- 가능한 간접 계층을 적게 사용하라. 대부분의 백엔드 시스템에서는 도메인 모델, 애플리케이션 서비스 계층, 인프라 계층 이 세 가지만 잘 활용하면 된다

### 8.5.3 순환 의존성 제거하기
- 순환 의존성은 코드를 읽고 이해하려고 할 때 알아야할 것이 많아서 큰 부담이 된다
- 순환 의존성이 있으면 해결책을 찾기 위한 출발점이 명확하지 않기 때문이다
- 순환 의존성은 테스트를 방해한다

### 8.5.4 테스트에서 다중 실행 구절 사용
- 테스트에서 두 개 이상의 준비나 실행 또는 검증 구절을 두는 것은 고드 악취에 해당한다
- 테스트가 여러 동작 단위를 확인해서 테스트의 유지 보수성을 저해한다는 신호이다
- 각 실행을 고유의 테스트로 추출해 테스트를 나누는 것이 좋다
- 각 테스트가 단일 동작 단위에 초점을 맞추게 하면, 테스트를 더 쉽게 이해하고 필요할 때 수정할 수 있다
- 둘 이상의 실행 구절로 테스트를 작성하는 것이 타당한 이유를 생각해보면, 프로세스 외부 의존성을 관리하기 어려운 경우 뿐이다

## 8.6 로깅 기능을 테스트하는 방법
- 생략