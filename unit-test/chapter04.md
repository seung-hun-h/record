# 4. 좋은 단위 테스트의 4대 요소
- 좋은 단위 테스트 스위트의 특성
  - 개발 주기에 통합돼 있다. 실제로 사용하는 테스트에만 가치가 있다. 그렇지 않으면 작성해도 의미가 없다
  - 코드베이스의 가장 중요한 부분만을 대상으로 한다
  - 최소한의 유지비로 최대한의 가치를 끌어낸다
    - 가치 있는 테스트를 식별해야 한다
    - 가치 있는 테스트를 작성해야 한다

## 4.1 좋은 단위 테스트의 4대 요소 자세히 살펴보기
- 좋은 단위 테스트의 네 가지 특성
  - 회귀 방지
  - 리팩터링 내성
  - 빠른 피드백
  - 유지 보수성

### 4.1.1 첫 번째 요소: 회귀 방지
- 회귀란 소프트웨어 버그이다. 코드 베이스를 수정한 후 기능이 의도한 대로 동작하지 않는 경우를 말한다
- 코드 베이스가 커질 수록 잠재적인 버그에 더 많이 노출되므로, 회귀 방지는 중요하다
- 회귀 방지를 위한 중요한 3가지 사항
  - 테스트 중에 실행되는 코드의 양
    - 코드의 양이 많을 수록 회귀가 발생할 가능성이 높다
    - 예외를 발생시키지 않고 실행되는 것과 유효한 결과가 도출되었는지도 확인 해야 한다
  - 코드 복잡도
  - 코드의 도메인 유의성
- 개발자가 직접 작성하지 않는 코드인 라이브러리, 프레임 워크, 외부 시스템도 테스트 범주에 포함 시켜 의존성에 대해 검증해야 한다

### 4.1.2 두 번째 요소: 리팩터링 내성
- 리팩터링 내성은 테스트를 실패하지 않고 기본 애플리케이션 코드를 리팩터링할 수 있는 지에 대한 척도다
- 거짓 양성(False positive)는 실제로 기능은 의도한대로 동작하지만 테스트는 실패하는 상황을 의미한다
- 거짓 양성은 테스트가 제공하는 소프트웨어의 지속가능한 성장을 방해한다
  - 테스트가 타당한 이유 없이 실패하면 코드 문제에 대응하는 능력과 의지가 희석된다. 시간이 흐르면서 실패에 익숙해지고 신경쓰지 않게된다
  - 거짓 양성이 빈번하면 테스트 스위트에 대한 신뢰도가 떨어지며, 더 이상 믿을 만한 안전망으로 인식하지 않는다

### 4.1.3 무엇이 거짓 양성의 원인인가?
- 테스트에서 발생하는 거짓 양성의 수는 테스트 구성 방식과 직접적인 관련이 있다
- SUT의 세부적인 구현 사항와 테스트가 많이 결합할 수록 거짓 양성이 많이 발생한다
- 거짓 양성이 생길 가능성을 줄이는 방법은 구현 세부사항에서 테스트를 분리하는 것 뿐이다
  - 최종 사용자 관점에서 SUT를 검증한다
  - 최종 사용자에게 의미있는 결과만 확인한다
- 테스트를 구성하기 가장 좋은 방법은 문제 영역에 대해 이야기 하는 것이다

### 4.1.4 구현 세부 사항 대신 최종 결과를 목표로 하기
- 생략

## 4.2 첫 번째 특성과 두 번째 특성 간의 본질적인 관계
- 회귀 방지와 리팩터링 내성 사이에는 본질적인 관계가 존재한다
  - 둘 다 정반대의 관점에서도 테스트 스위트 정확도에 기여한다
  - 두 특성은 프로젝트 영향에 영향을 다르게 미치는 경향이 있다
    - 초기에는 회귀 방지를 갖추는 것이 중요, 리팩터링 내성은 덜 중요

### 4.2.1 테스트 정확도 극대화
|            |기능 작동|기능 고장|
|------------|-------|-------|
|**테스트 성공**|올바른 추론(참 음성)|2종 오류(거짓 음성)|
|**테스트 실패**|1종 오류(거짓 양성)|올바른 추론(참 양성)|

- 기능이 고장났는데 오류가 발생하지 않으면 문제가 된다(2종 오류). 이는 거짓 음성이다
  - 거짓 음성을 피하는데 좋은 테스트의 첫 번째 특성인 회귀 방지가 도움이 된다
  - 회귀 방지가 훌륭한 테스트는 2종 오류인 거짓 음성의 수를 최소화하는데 도움이 된다
- 기능은 올바르지만 테스트가 실패하는 상황도 있다(거짓 양성)
  - 이는 허위 경보다
  - 거짓 양성을 피하는데는 리팩터링 내성이 도움이된다

- 회귀 방지와 리팩터링 내성은 테스트 스위트의 정확도를 극대화하는 것을 목표로 한다
  - 테스트가 버그 있음을 얼마나 잘 나타내는가
  - 테스트가 버그 없음을 얼마나 잘 나타내는가
- 거짓 양성과 거짓 음성을 생각해보는 또 다른 관점으로는 소음 대비 신호 비율 측면에서 볼 수 있다
  - `테스트 정확도 = 신호(발견된 버그 수) / 소음(허위 경보 발생 수)`
  - 신호 수를 증가시킨다 -> 회귀를 더 잘 찾아내는 테스트로 개선한다(회귀 방지)
  - 소음을 줄인다 -> 허위 경보를 발생시키지 않는 테스트로 개선한다(리팩터링 내성)

### 4.2.2 거짓 양성과 거짓 음성의 중요성: 역학 관계
- 프로젝트 초기에는 거짓 음성이 중요하고 거짓 양성은 덜 중요햐다
- 개발자의 기억속에서 코드가 생생하기 때문에 쉽게 리팩터링할 수 있다
- 하지만 시간이 지날 수록 코드 베이스는 나빠져 리팩토링이 필요해진다
- 대부분의 프로젝트는 작고 프로젝트가 커지기 전에 개발이 끝난다
- 하지만 중대형 프로젝트에서 작업하면, 거짓 음성과 거짓 양성에 대해 똑같이 주의를 기울여야 한다

## 4.3 세 번째 요소와 네 번째 요소: 빠른 피드백과 유지 보수성
- 빠른 피드백은 테스트가 빠르게 실행되어야 한다는 의미이다
  - 테스트 속도가 빠를 수록 테스트 스위트에서 더 많은 테스트를 수행할 수 있고 더 자주 실행할 수 있다
- 유지 보수성은 테스트의 유지비를 평가한다
  - 테스트 코드의 품질은 제품 코드만큼 중요하다. 테스트는 이해하기 쉬울 수록 좋다
  - 테스트는 실행하기 쉬워야 한다. 테스트가 프로세스 외부 종속성으로 작동하면 의존성을 상시 운영하는데 시간을 들여야 한다

## 4.4 이상적인 테스트를 찾아서
- 테스트 코드를 포함한 모든 코드는 책임이다
- 최소한으로 필요한 가치로 임계치를 상당히 높게 설정하고 이 임계치를 충족하는 테스트만 테스트 스위트에 남겨라
- 소수의 매우 가치 있는 테스트는 평범한 테스트보다 프로젝트가 계속 성장하는 데 훨씬 더 효과적이다

### 4.4.1 이상적인 테스트를 만들 수 있는가?
- 회귀 방지, 리팩터링 내성, 빠른 피드백, 유지 보수성을 모두 최대 점수를 받는 이상적인 테스트는 존재하지 않는다
- 회귀 방지, 리팩터링 내성, 빠른 피드백은 상호 배타적이기 때문이다
- 따라서 특성 중 어느 것도 크게 줄지 않는 방식으로 최대한 크게 해야 한다

### 4.4.2 극단적인 사례1: 엔드 투 엔드 테스트
- 엔드 투 엔드 테스트는 최종 사용자의 관점에서 시스템을 살펴본다
- 엔드 투 엔드 테스트는 많은 코드를 테스트 하므로 회귀 방지를 훌륭히 해낸다
- 엔드 투 엔드 테스트는 거짓 양성에 면역이 돼 리팩터링 내성도 우수하다
  - 최종 사용자 관점에서 기능이 어떻게 동작하는지만 볼 수 있기 때문에, 구현 세부 사항을 최대한 제거했다
- 하지만 엔드 투 엔드 테스트는 느리다

### 4.4.3 극단적인 사례2: 간단한 테스트
- 간단한 테스트는 매우 빠르게 실행되고 빠른 피드백을 제공한다
- 그리고 거짓 양성이 생길 가능성이 매우 낮아 리팩터링 내성도 우수하다
- 하지만 기반 코드에 실수할 여지가 많지 않기 때문에 간단한 테스트는 회귀를 나타내지 않을 것이다
- 간단한 테스트는 동어 반복 테스트를 불러온다. 이러한 테스트는 무의미하다

### 4.4.4 극단적인 사례3: 깨지기 쉬운 테스트
- 깨지기 쉬운 테스트는 실행이 빠르고 회귀를 잡을 가능성이 높지만 거짓 양성이 많은 테스트를 의미한다
- 이는 리팩터링을 견디지 못하고, 해당 기능이 고장났는지와 상관 없이 테스트가 실패한다

### 4.4.5 이상적인 테스트를 찾아서: 결론
- 세 가지 특성은 상호 배타적이다
- 리팩터링 내성을 최대한 많이 갖는 것을 목표로 해야 한다
  - 테스트는 리팩터링 내성을 가지고 있거나 없거나 둘 중 하나이다. 중간이 없다
- 그리고 회귀 방지와 빠른 피드백 사이의 선택으로 절충이 귀결된다

### ETC: CAP 정리
- 좋은 단위 테스트의 처음 세 가지 특성은 CAP 정리와 유사하다
- CAP 정리는 분산 데이터 저장소가 다음 세 가지 보증 모두를 동시에 제공할 수 없음을 나타낸다
  - 일관성(consistency): 모든 읽기가 가장 최근의 쓰기 또는 오류를 수신하는 것을 의미한다
  - 가용성(availability): 모든 요청이 응답을 수신하는 것을 의미한다
  - 분할 내성(partition tolerance): 네트워크 분할(네트워크 노드간 연결 끊김)에도 시스템이 계속 작동함을 의미한다
- 두 가지 비슷한 점이 있다
  - 세 가지 중 두 가지를 선택하는 절충안을 선택해야 한다
  - 대규보 분산 시스템의 분할 내성도 타협할 수 없다. 

## 4.5 대중적인 테스트 자동화 개념 살펴보기
### 4.5.1 테스트 피라미드 분해
- 테스트 피리미드는 테스트 스위트에서 테스트 유형간의 일정한 비율을 일컫는 개념이다
  - 단위 테스트
  - 통합 테스트
  - 엔드 투 엔드 테스트
  - 순서로 테스트 수를 가진다
- 아래에 있을 수록 테스트 수가 많고, 위에 있을 수록 최종 사용자의 동작을 유사하게 흉내낸다
- 엔드 투 엔드 테스트가 피라미드의 최상단에 위치한다. 이는 최종 사용자의 동작을 가장 유사하게 나타낸다는 것이다
- 피라미드 상단의 테스트는 회귀 방지에 유리한 반면, 하단은 실행속도를 강조한다
- 어느 계층도 리팩터링 내성을 포기하지 않는다
- 모든 테스트는 거짓 양성을 가능한 한 적게 하는 것을 목표로 해야 한다
- 하지만 비즈니스 규칙이 없는 기본적인 CRUD 작업이라면 테스트 피라미드는 단위 테스트와 통합 테스트의 수가 같고 엔드 투 엔드 테스트가 없는 직사각형 모양일 것이다
- 단위 테스트는 알고리즘이나 비즈니스 복잡도가 없는 환경에서는 유용하지 않다

### 4.5.2 블랙박스 테스트와 화이트 박스 테스트간의 선택
- 블랙 박스 테스트
  - 시스템의 내부 구조를 몰라도 시스템의 기능을 검사할 수 있는 소프트웨어 테스트 방법이다
  - 어떻게 해야하는지가 아니라 무엇을 해야 하느지를 중심으로 구축된다
- 화이트박스 테스트
  - 애플리케이션의 내부 작업을 검증하는 테스트 방식이다

- 화이트박스 테스트가 좀 더 철저한 편이다
  - 외부 명세에만 의존할 때 놓칠 수 있는 많은 오류를 발견할 수 있다
- 하지만 테스트 대상 코드와 결합돼 있기 때문에 깨지기 쉽다
  - 거짓양성을 많이 만들어내고 리팩터링 내성이 부족하다
- 리팩터링 내성은 타협할 수 없으므로 블랙박스 테스트를 기본으로 한다
- 테스트를 작성할 떄는 블랙박스 테스트로 하고, 테스트를 분석할 떄는 화이트박스 방법을 사용할 수 있다