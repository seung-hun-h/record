# 5. 목과 테스트 취약성
- 목을 사용하는 것은 논란의 여지가 있는 주제이다
- 목을 사용하면 리팩터링 내성이 부족한 테스트를 초래할 수 있다
- 하지만 목을 적용할 수 있는 경우가 있고, 목 사용이 바람직한 경우도 있다

## 5.1 목과 스텁 구분
### 5.1.1 테스트 대역 유형
- 테스트 대역은 모든 유형의 비운영용 가짜 의존성을 설명하는 포괄적인 용어이다
- 테스트 대역에는 더미, 스텁, 스파이, 목, 페이크 다섯 가지가 있다
- 목: 외부로 나가는 상호 작용을 모방하고 검사하는데 도옴이 된다. 이러한 상호 작용은 SUT가 상태를 변경하기 위한 의존성을 호출하는 것에 해당한다
  - 목: 목 프레임워크의 도움을 받아 생성
  - 스파이: 수동으로 작성
- 스텁: 내부로 들어오는 상호 작용을 모방하는데 도움이 된다. 이러한 상호 작용은 SUT가 입력 데이터를 얻기 위한 의존성을 호출하는 것에 해당한다
  - 스텁: 시나리오마다 다른 값을 반환할 수 있게끔 구성할 수 있도록 필요한 것을 다 갖춘 완전한 의존성
  - 더미: 널 값이나 가짜 문자열과 같이 단순하고 하드 코딩된 값
  - 페이크: 스텁과 비슷하다. 보통 아직 존재하지 않는 의존성을 대체하고자 구현한다

- 목은 상호 작용을 모방하고 검사하는 반면 스텁은 모방만 한다는 차이점은 중요하다

### 5.1.2 도구로서의 목과 테스트 대역으로서의 목
- 목은 테스트 대역의 의미뿐 아니라 목 라이브러리의 클래스도 의미한다
- 태스트 대역으로서의 목과 도구로서의 목이 존재하는 것이다

```java
void test1() {
    IEmailGateway mock = Mockito.mock(IEmailGateway.class);
    Controller sut = new Controller(mock);

    sut.greetUser("user@gmail.com");
    Mockito.verify(mock, times(1)).sendGreetingsEmail("user@gmail.com"); 
}
```

- 도구로서의 목을 이용해 목과 스텁 두 가지 유형의 테스트 대역을 생성할 수 있기 때문에 도구로서의 목과 테스트 대역으로서의 목을 혼동하지 않는 것이 중요하다
- 다음 예제 테스트에서도 목 클래스를 사용하지만 해당 클래스의 인스턴슨는 목이 아니라 스텁이다

```java
void test2() {
    IDatabse stub = Mockito.mock(IDatabse.class);
    Mockito.when(stub.getNumberOfUsers()).thenReturn(10);
    Controller sut = new Controller(mock);

    Report report = sut.createReport();

    Assertions.assertThat(report.getNumberOfUsers()).isEqualTo(10);
}
```

- 이 테스트 대역은 SUT에 입력 데이터를 제공하는 호출을 모방한다
- test1의 `sendGreetingEmail()`에 대한 호출은 외부로 나가는 상호 작용이고 그 목적은 부작용을 일으키는 것뿐이다

### 5.1.3 스텁으로 상호 작용을 검증하지 마라
- 목은 SUT에서 관련 의존성으로 나가는 상호 작용을 모방하고 검사한다
- 스텁은 내부로 들어오는 상호 작용만 모방하고 검사하지 않는다
  - 이러한 호출은 최종 결과를 산출하기 위한 수단일 뿐이다
- 테스트에서 거짓 양성을 피랗고 리팩터링 내성을 향상시키는 방법은 구현 세부 사항이 아니라 최종 결과를 검증하는 것 뿐이다
- 결과가 올바르다면 SUT가 최종 결과를 어떻게 생성하는지는 중요하지 않다
- 다음 예제는 스텁으로 상호 작용을 검증하여 꺠지기 쉬운 테스트이다

```java
void test2() {
    IDatabse stub = Mockito.mock(IDatabse.class);
    Mockito.when(stub.getNumberOfUsers()).thenReturn(10);
    Controller sut = new Controller(mock);

    Report report = sut.createReport();

    Assertions.assertThat(report.getNumberOfUsers()).isEqualTo(10);
    Mock.verify(stub, times(1)).getNumberOfUsers();
}
```

- 최종 결과가 아닌 사항을 검증하는 이러한 관행을 과잉 명세(overspecification)이라 한다

### 5.1.4 목과 스텁 함께 쓰기
- 목과 스텁의 특성을 모두 나타내는 테스트 대역을 만들 필요가 때로는 있다

```java
public void test() {
    IStore storeMock = Mockito.mock(IStore.class);
    Mockito.when(storeMock.hasEnoughInventory(Product.shampoo, 5)).thenReturn(false);
    Customer sut = new Customer();

    boolean success = sut.purchase(storeMock, Product.shampoo, 5);

    Assertions.assertThat(success).isFalse();
    Mockito.verify(storeMock, times(0)).removeInventory(Product.shampoo, 5);
}
```

### 5.1.5 목과 스텁은 명령과 조회에 어떻게 관련돼 있는가?
- 목과 스텁의 개념은 명령 조회 분리(CQS, Command Query Seperation) 원칙과 관련있다
- CQS 원칙에 따르면 모든 메서드는 명령이거나 조회여야 하며, 둘을 혼용해서는 안된다
- 명령은 부작용을 일으키고 어떤 값도 반환하지 않는 메서드다
  - 부작용을 일으키는 메서드는 항상 동일한 결과를 반환해야 한다. 즉, 멱등성을 보장해야 한다
- 조회는 부작용이 없고 값을 반환한다
- 항상 CQS 원칙을 따를 수는 없지만 최대한 따르는 것이 좋다

## 5.2 식별할 수 있는 동작과 구현 세부 사항
- 테스트 취약성은 리팩터링 내성에 해당한다
  - 리팩터링 내성은 대부분 이진 선택이므로 리팩터링 내성 지표가 가장 중요하다
- 테스트에 거짓 양성(기능 정상, 테스트 실패)이 있는 주요 이유는 코드의 구현 세부 사항과 결합돼있기 떄문이다
- 강결합을 피하기 위해서는 코드가 생성하는 최종 결과를 검증하는 것이다
  - 어떻게가 아니라 무엇에 집중한다

### 5.2.1 식별할 수 있는 동작은 공개 API와 다르다
- 모든 제품 코드는 2차원으로 분류할 수 있다
  - 공개 API, 비공개 API
  - 식별할 수 있는 동작, 구현 세부 사항
- 대부분의 프로그래밍 언어는 공개 API와 비공개 API를 구별할 수 있는 간단한 메커니즘을 제공한다
- 식별할 수 있는 동작과 내부 구현 사항에는 미묘한 차이가 있다. 코드가 시스템의 식별할 수 있는 동작이라면 다음 중 하나를 해야 한다
  - 클라이언트가 목표를 달성하는 데 도움이 되는 연산을 노출하라. 연산은 계산을 수행하거나 부작용을 초래하거나 둘 다 하는 메서드다
  - 클라이언트가 목표를 달성하는 데 도움이 되는 상태를 노출하라. 상태는 시스템의 현재 상태이다
- 구현 세부 사항은 이 두 가지중 아무것도 하지 않는다
- 식별할 수 있는 동작은 클라이언트의 목표 중 하나라도 직접적인 관계가 있어야 한다
- 이상적으로는 공걔 API와 식별할 수 있는 동작과 일치해야 하며, 모든 구현 세부 사항은 클라이언트에게 노출되어선 안된다
- 구현 세부 사항이 공개 API로 유출될 때 문제가 발생할 수 있다

### 5.2.2 구현 세부 사항 유출: 연산의 예
- 생략

### 5.2.3 잘 설계된 API와 캡슐화
- 잘 설계된 API를 유지 보수하는 것은 캡슐화 개념과 관련있다
  - 캡슐화는 불변성 위반이라고도 하는 모순을 방지하는 조치이다  
  - 구현 세부 사항을 노출하면 불변성 위반을 가져온다

- 장기적으로 코드베이스 유지 보수에는 캡슐화가 중요하다
  - 지속적으로 증가하는 코드 복잡도에 대처할 수 있는 방법은 실질적으로 캡슐화 말고는 없다
  - 캡슐화를 올바르게 유지해 코드베이서에서 잘못할 수 있는 옵션조차 제공하지 않도록 하는 것이 좋다
- '묻지 말고 말하라(tell-don't-ask)'라는 원칙은 데이터를 연산 기능과 결합하는 것을 의미한다
  - 이 원칙을 캡슐화 실천의 귀결로 볼 수 있다
  - 코드 캡슐화가 목표이지만, 구현 세부 사항을 숨기고 데이터와 기능을 결합하는 것이 해당 목표를 달성하기 위한 수단이다
    - 구현 세부 사항을 숨기면 클라이언트의 시야에서 클래스 내부를 가릴 수 있기 때문에 내부 손상 위험이 적다
    - 데이터와 연산을 결합하면 해당 연산이 클래스의 불변성을 위반하지 않도록 할 수 있다

### 5.2.4 구현 세부 사항 유출: 상태의 예
- 생략

## 5.3 목과 테스트 취약성과의 관계
### 5.3.1 육각형 아키텍처 정의
- 전형적인 애플리케이션은 아래 그림과 같이 도메인과 애플리케이션 서비스라는 두 계층으로 구성된다
  - 도메인 계층은 애플리케이션의 중심부이기 때문에 도표 중앙에 위치하고, 비즈니스 로직이 포함돼 있다
  - 애플리케이션 서비스 계층은 도메인 계층 위에 있으며 외부 환경과의 통신을 조정한다

![image](https://user-images.githubusercontent.com/60502370/183280867-bd44ae03-2af0-4e7d-a8bf-0a568eda8675.png)

- 다음은 애플리케이션 서비스에 대한 조정의 예이다
  - 데이터베이스를 조회하고 해당 데이터로 도메인 클래스 인스턴스 구체화
  - 해당 인스턴스에 연산 호출
  - 결과를 데이터베이스에 저장

- 육각형은 애플리케이션을 나타내며 또 다른 애플리케이션과 소통할 수 있다
- 육각형 아키텍처가 강조하는 세 가지 지침은 아래와 같다
  - 도메인 계층과 애플리케이션 서비스 계층 간의 관심사 분리
    - 도메인 계층은 해당 비즈니스 로직에 대해서만 책임을 져야 하며, 다른 모든 책임에서는 제외돼야 한다
    - 외부 애플리케이션과 통신하거나 데이터베이스에서 데이터를 검색하는 것과 같은 책임은 애플리케이션 서비스에 귀속돼야 한다
    - 반대로 애플리케이션 서비스에는 어떤 비즈니스 로직도 있으면 안된다
    - 도메인 계층을 애플리케이션 도메인 지식 모음으로, 애플리케이션 서비스 계층을 일련의 비즈니스 유스케이스로 볼 수 있다
  - 애플리케이션 내부 통신
    - 육각형 아키텍처는 애플리케이션 서비스 계층에서 도메인 계층으로 흐르는 단방향 의존성 흐름을 규정한다
    - 도메인 계층 내부 클래스는 도메인 계층 내무 클래스끼리 서로 의존하고 애플리케이션 서비스 계층의 클래스에 의존하지 않는다
    - 도메인 계층은 외부 환경에서 완전히 격리되어야 한다
  - 애플리케이션 간의 통신
    - 외부 애플리케이션은 애플리케이션 서비스 계층에 있는 공통 인터페이스를 통해 해당 애플리케이션에 연결된다
    - 아무도 도메인 계층에 직접 접근할 수 없다

- 애플리케이션의 각 계층은 식별할 수 있는 동작을 나타내며 해당 구현 세부 사항을 포함하고 있다
- 잘 설계된 API 원칙에는 프랙탈 특성이 있는데, 이는 전체 계층만큼 크게도, 단일 클래스만큼 작게도 똑같이 적용되는 것이다
- 각 계층의 API를 잘 설계하면 테스트도 프랙탈 구조를 갖기 시작한다. 달성하는 목표는 같지만 서로 다른 수준에서 동작을 검증한다.
  - 애플리케이션 서비스를 다루는 테스트는 해당 서비스가 외부 클라이언트에게 매우 중요하고 큰 목표를 어떻게 이루는지 확인한다
  - 도메인 클래스 테스트는 그 큰 목표의 하위 목표를 검증한다

![image](https://user-images.githubusercontent.com/60502370/183281360-33a90ede-b07d-4161-87dc-0404a71a2a79.png)

- 식별할 수 있는 동작은 바깥 계층에서 안쪽으로 흐른다
- 잘 설계된 API로 코드베이스를 검증하는 테스트는 식별할 수 있는 동작만 결합돼 있기 때문에 비즈니스 요구 사항과 관계가 있다
- 코드베이스의 공개 API를 항상 비즈니스 요구 사항에 따ㅏ 추적하라는 이 지침은 대부분의 도메인 클래스와 애플리케이션 서비스에 적용되지만, 유틸리티나 인프라 코드에는 적용되지 않는다
  - 해당 코드로 해결하는 문제는 종종 너무 낮은 수준이고 세밀해서 구체적인 비즈니스 유스케이스로 추적할 수 없다

### 5.3.2 시스탬 내부 통신과 시스템 간 통신
- 시스템 내부 통신은 팰리케이션 내 클래스간의 통신이다
- 시스템 간 통신은 애플리케이션이 다른 애플리케이션과 통신하는 것을 말한다
- 시스템 내부 통신은 구현 세부 사항이고, 시스템 간 통신은 아니다
- 시스템 간 통신의 특성은 벼도 애플리케이션과 함께 성장하는 방식에서 비롯된다. 성장의 주요 원칙 중 하나로 하위 호환성을 지키는 것이다
  - 외부 애플리케이션과 통신할 때 사용하는 통신 패턴은 항상 외부 애플리케이션이 이해할 수 있도록 유지해야 한다
- 목을 사용하면 시스템과 외부 애플리케이션 간의 통신 패턴을 확인할 때 좋다
- 시스탬 내 클래스 간의 통신을 검증하는데 사용하면 테스트가 세부 구현 사항과 결합되며 그에 따라 리팩터링 내성 지표가 미흡해진다

### 5.3.3 시스템 내부 통신과 시스템 간 통신의 예
- 생략

## 5.4 단위 테스트의 고전파와 런던파 재고
- 런던파는 불변 의존성을 제외한 모든 의존성에 목 사용을 권장하며 시스템 내 통신과 시스템 간 통신을 구분하지 않는다
  - 그 결과, 테스트는 애플리케이션과 외부 시스템 간의 통신을 확인하는 것처럼 클래스 간 통신도 확인한다
- 런던파를 따라 목을 무분별하게 사용하면 종종 구현 세부 사항에 결합돼 테스트에 리팩터링 내성이 없게 된다
- 고전파는 테스트 간에 공유하는 의존성만 교체하자고 하므로 이 문제에 훨씬 유리하다.
- 그러나 고전파 역시 시스템 간 통신에 대한 처리에 이상적이지는 않다
- 고전파도 지나치게 목 사용을 장려한다

### 5.4.1 모든 프로세스 외부 의존성을 목으로 해야하는 것은 아니다
- 고전파에서는 공유 의존성을 피할 것을 권고한다
  - 테스트를 서로 격리할 수 없기 때문이다
- 공유 의존성이 프로세스 외부에 있는 것이 아니라면 각 테스트 실행 시 해당 의존성을 새 인스턴스로 써서 재사용을 피하기 쉽다
- 공유 의존성이 프로세스 외부에 있으면 테스트가 복잡해진다
  - 일반적인 접근법은 이러한 의존성을 테스트 대역, 즉 목과 스텁으로 교체하는 것이다
- 모든 프로세스 외부 의존성을 테스트 대역으로 교체해야 하는 것은 아니다
  - 프로세스 외부 의존성이 애플리케이션을 통해서만 접근할 수 있다면 이러한 의존성과의 통신은 시스템에서 식별할 수 있는 동작이 아니다
  - 외부에서 관찰할 수 없는 프로세스 외부 의존성은 애플리케이션의 일부로 동작한다
- 애플리케이션과 외부 시스템 간의 통신 패턴을 항상 지켜야 하는 요구 사항은 하위 호환성을 지켜야 한다는 점에서 비롯된다
  - 애플리케이션과 외부 시스템을 동시에 변경할 수 없기 때문이다
  - 배포주기가 다르거나 단순히 접근 제어 권한이 없을 수 있기 때문이다
- 애플리케이션이 외부 시스템에 대한 프록시 같은 역할을 하고 클라이언트가 직접 접근할 수 없으면 하위 호환성 요구 사항은 사라진다
  - 외부 시스템과 애플리케이션을 같이 배포할 수 있으면 클라이언트에 영향을 미치지 않는다. 이러한 통신 패턴은 구현 세부 사항이 된다
- 완전히 통제권을 가진 프로세스 외부 의존성에 목을 사용하면 깨지기 쉬운 테스트로 이어진다

### 5.4.2 목을 사용한 동작 검증
- 목은 애플리케이션의 경계를 넘나드는 상호 작용을 검증할 때와 이러한 상호 작용의 부작용이 외부 환경에서 보일 때만 동작과 관련있다