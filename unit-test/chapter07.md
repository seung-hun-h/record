# 7. 가치 있는 단위 테스트를 위한 리팩터링
- 가치 있는 테스트를 알아보는 데 그치지 않고 작성할 수 있어야 한다
- 작성하는 것은 알아보는 것에 그치지 않고 코드 설계 기법도 필요로 한다
- 단위 테스트와 기반 코드는 얽혀있기 떄문에 코드베이스에 노력을 기울여야 한다

## 7.1 리팩터링할 코드 식별하기
### 7.1.1 코드의 네 가지 유형
- 모든 제품 코드는 2차원으로 분류할 수 있다 
  - 복잡도 또는 도메인 유의성
  - 협력자 수
- 코드 복잡도는 코드 내 의사 결정(분기) 지점 수로 정의한다
- 도메인 유의성은 코드가 프로젝트의 문제 도메인에 대해 얼마나 의미 있는 지를 나타낸다
  - 도메인 계층의 모든 코드는 최종 사용자의 목표와 직접적인 연관이 있으므로 도메인 유의성이 높다
  - 유틸리티 코드는 연관성이 없다
- 복잡한 코드와 도메인 유의성을 갖는 코드가 테스트하기 이롭다
  - 도메인 코드는 복잡할 필요가 없고, 복잡한 코드는 유의하지 않아도 테스트할 가치가 있다
- 협력자가 많은 코드는 테스트 비용이 많이 든다
  - 협력자는 가변 의존성이거나 프로세스 외부 의존성이다
  - 도메인 모델이라면 프로세스 외부 협력자를 사용하면 안된다
  - 애플리케이션 경계를 넘는 상호 작용을 검증하는데만 신중하게 목을 사용한다
  - 프로세스 외부 의존성을 가진 모든 통신은 도메인 계층의 외부 클래스에 위임한다
- 코드의 네 가지 유형
  - 도메인 모델과 알고리즘: 높은 복잡도나 유의성, 적은 협력자 수
    - 단위 테스트의 노력 대비 가치가 높다
  - 간단한 코드: 낮은 복잡도나 유의성, 적은 협력자 수
    - 테스트할 가치가 없다
  - 컨트롤러: 낮은 복잡도나 유의성, 많은 협력자 수
  - 지나치게 복잡한 코드: 높은 복잡도나 유의성, 많은 협력자 수
    - 가장 문제가 되는 유형이다
    - 지나치게 복잡한 코드는 다시 컨트롤러와 도메인 모델과 알고리즘으로 나누는 것이 일반적이다
- 지나치게 복잡한 코드는 피하고 도메인 모델과 알고리즘만 단위 테스트하는 것이 매우 가치 있고 유지 보수가 쉬운 테스트 스위트로 가는 길이다
- 좋지 않은 테스트를 작성하는 것보다는 테스트를 전혀 작성하지 않는 편이 낫다

### 7.1.2 험블 객체 패턴을 사용해 지나치게 복잡한 코드 분할하기
- 지나치게 복잡한 코드를 쪼개려면, 험블 객체 패턴을 써야한다
- 코드가 프레임워크 의존성에 결합돼 있기 때문에 테스트가 어려워질 수 있다
- 테스트 대상 코드의 로직을 테스트 하려면 테스트가 가능한 부분을 추출해야 한다
- 결과적으로 코드는 테스트 가능한 부분을 둘러싼 얇은 험블 래퍼가 된다
- 험블 객체 패턴은 지나치게 복잡한 코드에서 로직을 추출해 코드를 테스트할 필요가 없도록 간단하게 만든다. 추출된 로직은 테스트하기 어려운 의존성에서 분리된 다른 클래스로 이동한다
- 육각형 아키텍처, 함수형 아키텍처도 이 패턴을 따른다
- 험블 객체 패턴을 보는 또 다른 방법은 단일 책임 원칙을 지키는 것이다
  - 이 패턴을 적용하면 비즈니스 로직을 거의 모든 것과 분리할 수 있다
- 예를 들어 비즈니스 로직과 오케스트레이션을 분리하는 경우가 있다
  - 함수형 아키텍처, 육각형 아키텍처, MVC, MVP 패턴, 도메인 주도 설계에 나오는 집계 패턴 등등이 이를 따른다
  - 테스트 용이성 뿐만 아니라 코드 복잡도도 줄어든다

## 7.2 가치 있는 단위 테스트를 위한 리팩터링 하기
- 생략

## 7.3 최적의 단위 테스트 커버리지 분석
- 비즈니스 로직과 오케스트레이션을 완전히 분리하면 코드베이스의 어느 부분을 테스트 단위로 할지 쉽게 결정할 수 있다

### 7.3.1 도메인 계층과 유틸리티 코드 테스트하기
- 복잡도와 도메인 유의성이 높은 코드는 비용 편익 측면에서 최상의 결과를 가져다 준다
- 회귀 방지가 뛰어나고 협력자가 거의 없어 유지비도 가장 낮다

### 7.3.2 나머지 세 사분면에 대한 코드 테스트하기
- 복잡도가 낮고 협력자가 거의 없는 코드는 단순해서 노력을 들일 필요가 없다
- 이러한 테스트는 회귀 방지가 떨어진다

### 7.3.3 전제 조건을 테스트해야 하는가?
- 도메인 유의성의 있는 모든 전제 조건은 테스트해야 한다
- 하지만 도메인 유의성이 없는 전제 조건을 테스트하는 데 시간을 들이지 마라

## 7.4 컨트롤러에서 조건부 로직 처리
- 조건부 로직을 처리하면서 동시에 프로세스 외부 협력자 없이 도메인 계층을 유지 보수하는 것은 까다롭고 절충이 있기 마련이다
- 비즈니스 로직과 오케스트레이션의 분리는 다음과 같이 비즈니스 연산이 셰 단계로 있을 때 가장 효과적이다
  - 저장소에서 테이터 검색
  - 비즈니스 로직 실행
  - 데이터를 다시 저장소에 저장
- 이렇게 단계가 명확하지 않은 경우가 많다
  - 의사 결정 프로세스의 중간 결과를 기반으로 프로세스 외부 의존성에서 추가 데이터를 조회해야 할수도 있다
  - 프로세스 외부 의존성에 쓰기 작업도 종종 그 결과에 따라 달라진다

- 이러한 상황에서는 다음과 같은 세 가지 방법이 있다
  - 외부에 대한 모든 읽기와 쓰기를 가장자리로 밀어낸다
    - 읽고-결정하고-실행하기 구조를 유지하지만 성능이 저하된다
    - 필요 없는 경우에도 컨트롤러가 프로세스 외부 의존성을 호출한다
  - 도메인 모델에 프로세스 외부 의존성을 주입하고 비즈니스 로직이 해당 의존성을 호출할 시점을 직접 결정할 수 있게 한다
  - 외사 결정 프로세스 단계를 더 세분화 하고 각 단계별로 컨트롤러를 실행하도록 한다

- 문제는 다음 세 가지 특성의 균형을 맞추는 것이다
  - 도메인 모델 테스트 유의성: 도메인 클래스의 협력자 수와 유형에 따른 함수
  - 컨트롤러 단순성: 의사 결정 지점이 있는지에 따라 다름
  - 성능: 프로세스 외부 의존성에 대한 호출 수로 정의

- 위에서 언급한 방법은 세 가지 특성 중 두 가지 특성만 가진다
  - 외부에 대한 모든 읽기와 쓰기를 비즈니스 연산 가장자리로 밀어내기
    - 컨트롤러를 계속 단순하게 하고 프로세스 외부 의존성과 도메인 모델을 분리하지만 성능이 저하된다
  - 도메인 모델에 프로세스 외부 의존성 주입하기
    - 성능을 유지하면서 컨트롤러를 단순하게 하지만 도메인 모델의 테스트 유의성이 떨어진다
  - 의사 결정 프로세스 단계를 더 세분화하기
    - 성능과 도메인 모델 테스트 유의성에 도움을 주지만 컨트롤러가 단순하지 않다
    - 이러한 세부 단계를 관리하려면 컨트롤러에 의사 결정 지점이 있어야 한다

- 대부분의 소프트웨어 프로젝트에서는 성능이 중요하므로 첫 번째 방법은 고려할 필요가 없다
- 두 번째 방법은 대부분의 코드를 지나치게 복잡한 사분면에 넣는다
- 세 번째 방법은 컨트롤러를 더 복잡하게 만들기 때문에 지나치게 복잡한 사분면에 더 가까워지게 된다

### 7.4.1 CanExecute/Execute 패턴 사용
```java
public String canChangeEmail() {
    if (isEmailConfirmed) {
        return "Can't change a confirmed email";
    }
    return null
}

public void changeEmail(String newEmail, Company company) {
    if (!canChangeEmail()) {
        return;
    }
    ...
}
```
- 컨트롤러에서 이메일 변경 프로세스를 알 필요가 없다
  - 유효성 검사가 컨트롤러로부터 캡슐화 되어 있다
- `changeEmail()`의 전제 조건이 추가돼도 먼저 확인하지 않으면 이메일을 변경할 수 없도록 보장한다

- 이 패턴을 사용하면 도메인 계층의 모든 결정을 통합할 수 있다

### 7.4.2 도메인 이벤트를 사용해 도메인 모델 변경 사항 추적
- 도메인 모델을 현재 상태로 만든 단계를 빼기 어려울 때가 있다
- 그러나 애플리케이션에서 정확히 무슨 일이 일어나는지 외부 시스템에 알려야 하기 때문에 이러한 단계들을 아는 것이 중요할지도 모른다
- 컨트롤러에 이러한 책임도 있으면 더 복잡해진다
- 이를 피하려면 도메인 모델에서 중요한 변경 사항을 추적하고 비즈니스 연산이 완료된 후에 해당 변경 사항을 프로세스 외부 의존성 호출로 변환한다
- 도메인 이벤트로 이러한 추적을 구현할 수 있다

```c#
public class EmailChangedEvent {
    public int UserId { get; }
    public string NewEmail { get; }
}
```

- 이메일이 변경될 때 이벤트를 추가하는 User

```c#
public void ChangeEmail(string newEmail, Company company) {
    Precondition.Requires(CanChangeEmail() == null);

    if (Email == newEmail) {
        return;
    }

    UserType newType = company.isEmailCorporate(newEmail) ? UserType.Employee : UserType.Customer;

    if (Type != newType) {
        int delta = newType = UserType.Employee ? 1 : -1;
        company.ChangeNumberOfEmployees(delta);
    }

    Email = newEmail;
    Type = newType;
    EmailChangedEvents.Add(new EmailChangedEvent(UserId, newEmail));
}
```

- 도메인 이벤트를 처리하는 컨트롤러

```c#
public string ChangeEmail(int userId, string newEmail) {
    object[] userData = _database.GetUserById(userId);
    User user = UserFactory.Create(userData);

    string error = user.CanChangeEmail();
    if (error != null) {
        return error;
    }

    object[] companyData = _database.GetCompany();
    Company company = CompanyFactory.Create(companyData);

    user.ChangeEmail(newEmail, company);

    _database.SaveCompany(company);
    _database.SaveUser(user);
    foreach ( var ev in user.EmailChangedEvents) {
        _messageBus.SendEmailChangedMessage(ev.UserId, ev.NewEmail);
    }

    return "OK";
}
```

- 저장 로직이 도메인 이벤트에 의존하지 않으므로 여전히 Company 인스턴스와 User 인스턴스는 무조건 데이터베이스에 저장된다
- 이는 데이터베이스의 변경 사항과 메시지 버스의 메시지가 다르기 때문이다
  
- 도메인 이벤트로 해법을 일반화 할 수 있다
  - DomainEvent 기초 클래스를 추출해서 모든 도메인 클래스에 대해 이 기초 클래스를 참조하게 한다
  - 컨트롤러에서 도메인 이벤트를 수동으로 발송하는 대신 별도의 이벤트 디스패처를 작성할 수도 있다
- 도메인 이벤트는 컨트롤러에서 의사 결정 책임을 제거하고 해당 책임을 도메인 모델에 적용함으로써 외부 시스템과의 통신에 대한 단위 테스트를 간결하게 한다

## 7.5 결론
- 이 장의 주제는 외부 시스템에 대한 애플리케이션의 부작용을 추상화하는 것이었다
- 비즈니스 연산이 끝날 때까지 이러한 부작용을 메모리에 둬서 추상화하고, 프로세스 외부 의존성 없이 단순한 단위 테스트로 테스트할 수 있다
- 도메인 이벤트는 메시지 버스에서 메시지에 기반한 추상화에 해당한다
- 도메인 클래스의 변경 사항은 데이터베이스의 향후 수정 사항에 대한 추상화다
- 도메인 이벤트와 Execute/CanExecute 패턴을 사용해 도메인 모델에 모든 의사 결정을 잘 담을 수 있지만 항상 그럴 수는 없다. 비즈니스 로직 파편화를 피할 수 없는 상황이 있다
- 잠재적인 파편화가 있더라도 비즈니스 로직을 오케스트레이션에서 분리하는 것은 많은 가치가 있다
- 도메인 클래스에 협력자가 꽤 많더라도 프로세스 외부 의존성을 참조하지 않는 한 도메인 클래스는 지나치게 복잡한 코드가 아닐 것이다
- 협렵자와의 상호 작용을 검증하려 목을 사용하지 말라
- 이러한 상호작용은 도메인 모델의 식별할 수 있는 동작과 아무런 관련이 없다
- 컨트롤러에서 도메인 모델로 가는 첫 번째 호출만 컨트롤러 목표에 직접적인 연관이 있다
- 메서드가 클래스의 식별할 수 있는 동작인지 여부는 클라이언트가 누구인지와 클라이언트의 목표가 무엇인지에 달려 있다
  - 클라이언트 목표 중 하나에 직접적인 연관이 있다
  - 외부 애플리케이션에서 볼 수 있는 프로세스 외부 의존성에서 부작용이 발생한다

- 전의 코드에서 클라이언트는 시스템의 최종 상태가 올바르고 메시지 버스 호출이 잘되는 한 컨트롤러가 이메일 변경을 어떻게 구현하기로 하든 전혀 상관없다
- 컨트롤러의 동작은 테스트할 때 컨트롤러가 User에 수행하는 호출을 검증해서는 안된다
- 식별할 수 있는 동작과 구현 세부 사항을 양파의 여러 겹으로 생각하라
  - 외부 계층의 관점에서 각 계층을 테스트하고, 해당 계층이 기저 계층과 어떻게 통신하는 지 무시하라
  - 이러한 계층을 하나씩 벗겨가면서 관점을 바꾸게 된다
  - 이전에는 세부 구현이었던 것이 식별할 수 있는 동작이 된다