# 7. 가치 있는 단위 테스트를 위한 리팩터링
- 가치 있는 테스트를 알아보는 데 그치지 않고 작성할 수 있어야 한다
- 작성하는 것은 알아보는 것에 그치지 않고 코드 설계 기법도 필요로 한다
- 단위 테스트와 기반 코드는 얽혀있기 떄문에 코드베이스에 노력을 기울여야 한다

## 7.1 리팩터링할 코드 식별하기
### 7.1.1 코드의 네 가지 유형
- 모든 제품 코드는 2차원으로 분류할 수 있다 
  - 복잡도 또는 도메인 유의성
  - 협력자 수
- 코드 복잡도는 코드 내 의사 결정(분기) 지점 수로 정의한다
- 도메인 유의성은 코드가 프로젝트의 문제 도메인에 대해 얼마나 의미 있는 지를 나타낸다
  - 도메인 계층의 모든 코드는 최종 사용자의 목표와 직접적인 연관이 있으므로 도메인 유의성이 높다
  - 유틸리티 코드는 연관성이 없다
- 복잡한 코드와 도메인 유의성을 갖는 코드가 테스트하기 이롭다
  - 도메인 코드는 복잡할 필요가 없고, 복잡한 코드는 유의하지 않아도 테스트할 가치가 있다
- 협력자가 많은 코드는 테스트 비용이 많이 든다
  - 협력자는 가변 의존성이거나 프로세스 외부 의존성이다
  - 도메인 모델이라면 프로세스 외부 협력자를 사용하면 안된다
  - 애플리케이션 경계를 넘는 상호 작용을 검증하는데만 신중하게 목을 사용한다
  - 프로세스 외부 의존성을 가진 모든 통신은 도메인 계층의 외부 클래스에 위임한다
- 코드의 네 가지 유형
  - 도메인 모델과 알고리즘: 높은 복잡도나 유의성, 적은 협력자 수
    - 단위 테스트의 노력 대비 가치가 높다
  - 간단한 코드: 낮은 복잡도나 유의성, 적은 협력자 수
    - 테스트할 가치가 없다
  - 컨트롤러: 낮은 복잡도나 유의성, 많은 협력자 수
  - 지나치게 복잡한 코드: 높은 복잡도나 유의성, 많은 협력자 수
    - 가장 문제가 되는 유형이다
    - 지나치게 복잡한 코드는 다시 컨트롤러와 도메인 모델과 알고리즘으로 나누는 것이 일반적이다
- 지나치게 복잡한 코드는 피하고 도메인 모델과 알고리즘만 단위 테스트하는 것이 매우 가치 있고 유지 보수가 쉬운 테스트 스위트로 가는 길이다
- 좋지 않은 테스트를 작성하는 것보다는 테스트를 전혀 작성하지 않는 편이 낫다

### 7.1.2 험블 객체 패턴을 사용해 지나치게 복잡한 코드 분할하기
- 지나치게 복잡한 코드를 쪼개려면, 험블 객체 패턴을 써야한다
- 코드가 프레임워크 의존성에 결합돼 있기 때문에 테스트가 어려워질 수 있다
- 테스트 대상 코드의 로직을 테스트 하려면 테스트가 가능한 부분을 추출해야 한다
- 결과적으로 코드는 테스트 가능한 부분을 둘러싼 얇은 험블 래퍼가 된다
- 험블 객체 패턴은 지나치게 복잡한 코드에서 로직을 추출해 코드를 테스트할 필요가 없도록 간단하게 만든다. 추출된 로직은 테스트하기 어려운 의존성에서 분리된 다른 클래스로 이동한다
- 육각형 아키텍처, 함수형 아키텍처도 이 패턴을 따른다
- 험블 객체 패턴을 보는 또 다른 방법은 단일 책임 원칙을 지키는 것이다
  - 이 패턴을 적용하면 비즈니스 로직을 거의 모든 것과 분리할 수 있다
- 예를 들어 비즈니스 로직과 오케스트레이션을 분리하는 경우가 있다
  - 함수형 아키텍처, 육각형 아키텍처, MVC, MVP 패턴, 도메인 주도 설계에 나오는 집계 패턴 등등이 이를 따른다
  - 테스트 용이성 뿐만 아니라 코드 복잡도도 줄어든다

### 7.2 가치 있는 단위 테스트를 위한 리팩터링 하기
- 생략