## @Entity
---
- JPA를 사용해서 테이블과 매핑할 클래스는 `@Entity` 어노테이션을 필수로 붙여야한다.
- name 속성: JPA에서 사용할 엔티티 이름을 지정한다. 기본 값으로 클래스의 이름을 사용한다.
  - 다른 패키지에 동일한 이름을 가진 엔티티가 있다면 이름을 지정하여 충돌하지 않도록 해야한다.
- 유의 사항
  - 기본 생성자 필수
  - final 클래스에 사용할 수 없다
  - final 필드를 사용할 수 없다

## @Table
---
- 엔티티와 매핑할 테이블을 지정한다
  - 생략하면 매핑한 엔티티 이름을 테이블 이름으로 사용한다
- name 속성: 매핑할 테이블 이름
- uniqueConstraints: DDL 생성 시에 유니크 제약조건을 만든다

## 데이터베이스 스키마 자동 생성
---
- JPA는 클래스의 매핑 정보와 데이터베이스 방언을 사용해서 데이터베이스 스키마를 생성한다.
- 실제 운영 환경에서 사용할만큼 완벽하지 않아서 개발 환경에서 사용하거나 매핑을 어떻게 해야하는 지 참고하는 정도로만 한다.


### DDL 주의 사항
- 개발 초기 단계 create, update
- 자동화 테스트나 CI 단계 create, create-drop
- 테스트 서버 update, validate
- 스테이징이나 운영서버 validate, none
- DDL 자동 생성 기능은 JPA의 실행로직에는 영향을 주지 않는다.
  - DDL을 직접 만든다면 사용할 일이 없지만 애플리케이션 개발자가 어노테이션만 보고도 손쉽게 제약 조건을 확인할 수 있다는 장점이 있다.

## 기본키 매핑
---
- 직접 할당: 기본 키를 애플리케이션에서 직접 할당
- 자동 생성: 대리 키 사용방식
  - IDENTITY: 기본 키 생성을 데이터베이스에 위임한다
  - SEQUENCE: 데이터베이스 시퀀스를 사용해서 기본 키를 할당한다
  - TABLE: 키 생성 테이블을 사용한다

`@Id` 어노테이션이로 기본 키를 지정하고 `@GeneratedValue` 어노테이션으로 데이터베이스에 키 생성을 위임할 수 있다.

### IDENTITY 전략
- 기본 키 생성을 데이터베이스에 위임하는 전략
- MySQL, PostgreSQL, SQL Server 등에서 사용한다
  - MySQL은 대표적으로 AUTO_INCREMENT를 사용한다.
- 컬럼의 값을 비워두면 데이터베이스에서 자동으로 생성한다

- `@GeneratedValue(strategy = GenerationType.IDENTITY)`로 설정한다
- IDENTITY 전략 적용하면 JPA는 기본 키를 얻어오기 위해 데이터베이스를 추가로 조회한다
  - 데이터베이스에 데이터를 insert 한 후에 기본 키를 조회할 수 있다
  - 하지만 JDBC3에 추가된 `Statement.getGeneratedKeys()`를 사용하면 데이터를 저장하면서 동시에 생성된 기본 키 값도 얻어올 수 있다. 하이버네이트는 이 메소드를 사용해서 데이터베이스와 한 번만 통신한다.

**주의**

엔티티가 영속 상태가 되려면 식별자가 반드시 필요하다. IDENTITY 전략을 적용하려면 엔티티가 데이터베이스에 저장되어야 한다. **따라서 `em.persist()`를 호출하는 즉시 INSERT SQL이 데이터베이스에 전달된다. 즉 쓰기 지연이 지원되지 않는다.**

### SEQUENCE 전략
- 데이터베이스 시퀀스는 유일한 값을 순서대로 생성하는 특별한 데이터베이스 오브젝트이다.
- PosetgreSQL, H2 등에서 제공한다
- `em.persist()`를 호출할 때 먼저 데이터베이스 시퀀스를 사용해서 식별자를 조회한다.
  - 조회한 식별자를 엔티티에 할당한 후에 엔티티를 영속성 컨텍스트에 저장한다
  - 이후 트랜잭션을 커밋해서 플러시가 일어나면 엔티티를 데이터베이스에 저장한다

**SEQUENCE 전략 최적화**

SEQUENCE 전략은 데이터베이스 시퀀스를 통해 식별자를 조회하는 추가 작업이 필요하다. 따라서 데이터 베이스와 2번 통신한다
- 식별자를 구하기 위한 통신
- 시퀀스를 기본 키로 엔티티를 저장

JPA는 데이터베이스와 통신 횟수를 줄이기 위해 `@SequenceGenerator.allocationSize`를 사용한다. allocationSize가 50으로 설정되어 있으면 한 번에 50 만큼 시퀀스를 생성하고 엔티티에 할당한 다음 또 50개씩 시퀀스를 증가하며 할당하는 방식이다.

시퀀스 값을 선점하기 때문에 JVM이 동시에 동작해도 기본 키 값이 충돌하지 않는다는 장점이 있는 반면에, 데이터베이스에 직접 접근하여 데이터를 등록할 때 시퀀스 값이 한 번에 크게 증가한다는 단점이 있다.

### TABLE 전략 
기본 키 생성을 담당하는 전용 테이블을 만들어 시퀀스 전략을 흉내내는 것이다. 잘 사용하지 않으니 필요하면 알아보자.

### AUTO 전략
IDENTITY, SEQUENCE, TABLE 중 데이터베이스 방언에 따라 자동으로 전략을 선택하는 것이다. 데이터베이스를 변경해도 코드를 수정할 필요가 없다는 장점이 있다. 키 생성 전략이 확정되지 않은 개발 초기 단계나 프로토타입 개발 시 편하게 사용할 수 있다.

### 키 생성 전략에서 유의 사항
데이터베이스의 기본 키는 다음 3가지 조건을 모두 만족해야한다
- null 값은 허용하지 않는다
- 유일해야 한다
- 변해선 안된다

테이블 기본 키를 선택하는 전략은 크게 2가지가 있다
- 자연 키
  - 비즈니스에 의미가 있는 키
  - 주민등록번호, 이메일, 전화번호

- 대리 키
  - 비즈니스와 관련 없는 임의로 만들어진 키, 대체 키로 불린다
  - 시퀀스, auto_increment

**자연 키보다는 대리 키를 권장한다.**
자연 키는 대부분 유일 하지 않고 변경될 가능성이 높다. 그리고 비즈니스 환경은 시간이 지남에 따라서 변할 수 있기 때문에 대리 키를 사용하는 것이 좋다!

## 데이터 중심 설계의 문제점

```java

public class Order {

    ...
    @Column(name = "member_id")
    private Long memberId;
}

```

객체 중심적으로 생각해보면 Order 클래스가 Member의 id를 가지는 것 보다 Member를 참조하는 것이 더 자연스럽다. 데이터베이스는 외래 키를 통해 테이블의 연관관계가 설정 되지만 자바의 클래스는 그렇지 않기 때문이다. 따라서 클래스의 연관관계를 설정해주기 위해서 Member 클래스를 참조하는 것이 더 좋다.
