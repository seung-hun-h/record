# 19강 결합 알고리즘과 성능
---
- 옵티마이저가 선택 가능한 결합 알고리즘
	- Nested Loops
	- Hash
	- Sort Merge
- 옵티마이저가 어떤 알고리즘을 선택할 지는 데이터의 크기 또는 결합 키의 분산이라는 요인에 의존한다
	- 가장 빈번하게 사용되는 알고리즘은 Nested Loops이다
	- 다음은 Hash, 마지막으로 Short Merge 순으로 중요하다

## 1. Nested Loops
### Nested Loops의 작동
- Nested Loops는 이름 그대로 중첩 반복을 사용하는 알고리즘이다
- 세부 처리는 다음과 같다
	1. 결합 대상 테이블(Table_A)에서 레코드를 하나씩 반복해가며 스캔한다. 이 테이블은 구동 테이블(Driving Table) 또는 외부 테이블(Outer Table)이라 한다. 다른 테이블(Table_B)은 내부 테이블(Inner Table)이라고 부른다
	2. 구동 테이블의 레코드 하나마다 내부 테이블의 레코드를 하나씩 스캔해서 결합 조건에 맞으면 리턴한다
	3. 이러한 작동을 구동 테이블의 모든 레코드에 반복한다

- Nested Loops의 특징
	- Table_A, Table_B의 결합 대상 레코드를 R(A), R(B)라고 하면 접근되는 레코드 수는 R(A) * R(B)가 된다. Nested Loops의 실행 시간은 이러한 레코드 수에 비례한다
	- 한 번의 단계에서 처리하는 레코드의 수가 적으므로 Hash 또는 Short Merge에 비해 메모리 소모가 적다
	- 모든 DBMS에서 지원한다
- Nested Loops에서 스캔 레코드 수가 R(A) * R(B) 보다 작아지는 경우도 있다
	- EXISTS, NOT EXISTS를 사용하면 반드시 내부 테이블의 모든 레코드에 접근할 필요는 없으므로 레코드 수가 감소하는 경향이 있다
	- 하지만 이러한 경우에도 다중 반복이라는 기본 로직은 같다
 
### 구동 테이블의 중요성
- Nested Loops의 성능을 개선하는 격언 중  '구동 테이블로는 작은 테이블을 선택하는 것'이라는 것이 있다
	- 이는 **내부 테이블의 결합 키  필드에 인덱스가 존재**해야 한다는 암묵적인 전제가 포함된다
- 이상적인 경우는 구동 테이블의 레코드 한 개에 내부 테이블의 레코드가 한 개가 대응하고, 해당 레코드를 내부 테이블의 인덱스를 사용해 찾을 수 있는 경우이다

```SQL
SELECT e.emp_id, e.emp_name, e.dept_id, d.dept_name
FROM Employees e INNER JOIN Departments d
					ON e.dept_id = d.dept_id
;
```

- 여기서 내부 테이블의 결합 키 인덱스(department_pkey, PK_DEP)가 사용된다면 내부 테이블의 반복을 생략할 수 있어 Nested Loops가 빨라진다
- 내부 테이블의 반복을 완전하게 생략할 수 있는 경우는 결합 키가 내부 테이블에 대해 유일한 경우 뿐이다
	- Oracle의 실행 계획 중 'INDEX UNIQUE SCAN'이라고 나타나는 것이 이 경우다
- 결합 키가 내부 테이블에 대해 유일하지 않는 경우에는 여러 레코드가 히트될 수 있다
	- 이 경우 히트된 여러 레코드에 대해 반복을 적용 해야 한다
- **'구동 테이블이 작은 Nested Loops' + '내부 테이블의 결합 키에 인덱스'** 라는 조합은 SQL 튜닝의 기본이다
	- 어떤 테이블을 내부 테이블로하고, 어떤 결합 키에 인덱스를 작성해야 하느지를 초기부터 고민해야 한다는 뜻이다

### Nested Loops의 단점
- 히트 되는 레코드가 너무 많으면 Nested Loops의 성능이 기대만큼 나오지 않을 수 있다
- 이러한 단점을 해결하기 위한 방법은 두 가지다
	1. 구동 테이블로 큰 테이블을 선택하는 역설적인 방법이다. 내부 테이블에 대한 접근이 기본 키로 수행되어 항상 하나의 레코드로 접근하는 것이 보장된다. 극단적으로 성능이 저하되는 것을 막을 수 있다
	2. Hash를 사용한다

## 2. Hash
### 작동
- 입력에 대해서 어느 정도 유일성과 균일성을 가진 값을 출력하는 함수를 해시라고 한다
- 절차
	1. 일단 작은 테이블을 스캔하고, 결합 키에 해시 함수를 적용해서 해시값으로 변환한다
	2. 다른 테이블(큰 테이블)을 스캔하고, 결합 키가 해시 값에 존재하는 지를 확인한다
	3. 존재하면 결합한다
- 해시는 워킹 메모리를 사용하므로 작은 테이블을 대상으로 해시 테이블을 생성한다
- 해시가 사용되는 경우에는 어떤 한 쪽의 테이블이 극단적으로 크지 않기 때문에 Nested Loops처럼 작은 테이블을 구동 테이블이라 부르는 것은 별 의미없다

### Hash의 특징
- 해시 테이블을 만들기 때문에 Nested Loops에 비해 메모리를 크게 소모한다
- 메모리가 부족하면 저장소를 사용하므로 지연이 발생한다
- 출력되는 해시값은 입력값의 순서를 알지 못하므로 등치 결합에만 사용할 수 있다

### Hash가 유용한 경우
- Nested Loops에서 적절한 구동 테이블이 존재하지 않은 경우
- 구동 테이블로 사용할만 한 작은 테이블이 존재하지만 히트되는 레코드가 너무 많은 경우
- Nested Loops의 내부 테이블에 인덱스가 존재하지 않는(인덱스를 추가할 수 없는)경우
- Nested Loops가 효율적으로 동작하지 않는 경우의 차선책이 Hash다

### 주의점
- Nested Loops보다 사용되는 메모리 양이 많으므로 동시 실행성이 높은 OLTP 처리를 할 때는 사용하면 안된다
	- 야간 배치 또는 BI/DWH(Business Inteligence/Data Warehouse)와 같은 시스템에 한해서 사용해야 한다
- Hash 결합은 두 테이블을 모두 읽어야 하므로 테이블 풀 스캔이 사용되는 경우가 많다
	- 테이블의 규모가 굉장히 크다면 풀 스캔에 걸리는 시간도 고려해야 한다

## 3. Sort Merge
- Sort Merge는 간단하게 Merge 또는 Merge Join이라 부르기도 한다
- 결합 대상 테이블들을 각각 결합 키로 정렬하고, 일치하는 결합 키를 찾으면 결합한다

### Short Merge의 특징
- 대상 테이블을 모두 정렬해야 하므로 Nested Loops 보다 많은 메모리를 소비한다. Hash는 한 테이블에 대한 해시 테이블을 만들지만, Short Merge는 두 테이블 모두 정렬하므로 더 많은 메모리를 소비할 수 있다
- 메모리가 부족하면 저장소를 사용하므로 지연이 발생할 수 있다
- Hash와 다르게 동치 결합뿐 아니라 부등호를 사용한 결합에도 사용할 수 있다
	- 하지만 부정 조건 결합에는 사용할 수 없다
- 원리적으로는 테이블이 결합 키로 정렬되어 있다면 정렬을 생략할 수 있다
	- 이러한 전략은 구현에 의존적이다
- 테이블을 정렬하므로 한쪽 테이블을 모두 스캔한 시점에서 결합을 완료할 수 있다

### Short Merge가 유효한 경우
- 테이블 정렬을 생략할 수 있는 경우에는 고려 해볼만 하다
- 그 외의 경우에는 Nested Loops나 Hash를 우선적으로 고려해야 한다

## 4. 의도하지 않는 크로스 결합
- '삼각 결합'이라 부르는 패턴으로 인해 의도하지 않게 크로스 결합이 발생하는 경우가 있다

```SQL
SELECT A.col_a, B.col_b, C.col_c
FROM Table_A A
	INNER JOIN Table_B B
		ON A.col_a = B.col_b
	INNER JOIN Table_C C
		ON A.col_a = C.col_c
;
```
- 결합 조건은 'Table_A - Table_B'와 'Table_A - Table_C'에만 존재하고, 'Table_B - Table_C'에는 결합조건이 존재하지 않는다는 점이 포인트다
- 이런 경우 다음과 같은 4가지 형태의 실행 계획이 나올 수 있다
	- Table_A를 구동 테이블로 Table_B와 결합하고 그 결과를 Table_C와 결합
	- Table_A를 구동 테이블로 Table_C와 결합하고 그 결과를 Table_B와 결합
	- Table_B를 구동 테이블로 Table_A와 결합하고 그 결과를 Table_C와 결합
	- Table_C를 구동 테이블로 Table_A와 결합하고 그 결과를 Table_B와 결합

### Nested Loops가 선택되는 경우
- 'Table_A를 구동 테이블로 Table_B와 결합하고 그 결과를 Table_C와 결합'하는 순서로 Nested Loops를 사용해 결합한다
- 이 실행 계획에서는 딱히 문제될 것이 없다

### 크로스 결합이 선택되는 경우
- 'Table_B - Table_C'처럼 결합 조건이 없는 경우, 결합 조건이 없는 테이블들을 크로스 결합으로 결합해버리는 경우가 있다
- Oracle에서는 'MERGE JOIN CARTESIAN'으로 표시된다
- 작은 테이블끼리 크로스 결합이 발생하는 것은 큰 문제가 되지 않는다.
- 하지만 문제는 큰 테이블끼리 결합할 때 크로스 결합이 선택되는 경우다
	- 레코드 수를 꽤 압축할 수 있는 정도의 입력이 들어왔을 때 옵티마이저가 '크로스 결합으로 충분하겠다'는 판단을 한다
	- 그리고 레코드 수를 압축할 수 없는 입력이 들어왔을 때도 저장된 정보를 바탕으로 같은 실행 계획을 선택해버리는 일이 있다

### 의도하지 않은 크로스 결합을 피하는 방법
- 의도하지 않은 크로스 결합을 피하는 방법 중, 결합 조건에 존재하지 않는 테이블 사이에 불필요한 결합 조건을 추가해주는 방법이 있다
	- 현재 상황에서는 Table_B와 Table_C 사이에 결합 조건을 설정해주는 것이다
	- 이 방법은 Table_B와 Table_C 사이에 결합 조건을 설정할 수 있고, 결합 조건을 설정해도 결과에 아무런 영향도 주지 않는 경우에만 사용할 수 있다

```SQL
SELECT A.col_a, B.col_b, C.col_c
FROM Table_A A
	INNER JOIN Table_B B
		ON A.col_a = B.col_b
	INNER JOIN Table_C C
		ON A.col_a = C.col_c
		AND C.col_C = B.col_b
;
```