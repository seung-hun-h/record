# 20강 결합이 느리다면
---

## 1. 상황에 따른 최적의 결합 알고리즘
- Nested Loops
	- 장점
		- '작은 구동 테이블' + '내부 테이블의 인덱스'라는 조건이 있다면 굉장히 빠르다
		- 메모리 또는 디스크 소비가 적으므로 OLTP에 적합
		- 비등가 결합에서도 사용가능
	- 단점
		- 대규모 테이블들의 결합에는 부적합
		- 내부 테이블의 인덱스가 사용되지 않거나, 내부 테이블의 선택률이 높으면 느리다
- Hash
	- 장점
		- 대규모 테이블들을 결합할 때 적합
	- 단점
		- 메모리 소비량이 큰 OLTP에는 부적합
		- 메모리 부족이 일어나면 TEMP 탈락 발생
		- 등가 결합에서만 사용가능
- Sort Merge
	- 장점
		- 대규모 테이블들을 결합할 때 적합
		- 비등가 결합에서도 사용 가능
	- 단점
		- 메모리 소비량이 큰 OLTP에는 부적합
		- 메모리 부족이 일어나면 TEMP 탈락 발생
		- 데이터가 정렬되어 있지 않다면 비효율적

- 최적의 결합 알고리즘을 결합 대상 레코드 수의 관점에서 정리
	1. 소규모 - 소규모
	   - 결합 대상 테이블이 작은 경우에는 어떤 알고리즘을 사용해도 성능 차이가 없다
	2. 소규모 - 대규모
	   - 소규모 테이블을 구동 테이블로하는 Nested Loops를 사용한다
	   - 대규모 테이블의 결합 키에 인덱스를 만들어야 한다
	   - 내부 테이블의 대상 레코드가 너무 많다면 구동 테이블과 내부 테이블을 바꾸거나 Hash를 사용해 볼 것
	3. 대규모 - 대규모
	   - 일단은 Hash를 사용한다
	   - 결합 키로 처음부터 정렬되어 있는 상태라면 Sort Merge를 사용한다

- 일단은 Nested Loops 잘 안되면 Hash

## 2. 실행 계획 제어
- 일반적으로 힌트 구를 사용해 실행 계획을 제어할 수 있다

### 실행 계획을 사용자가 제어할 때 리스크
- 데이터의 양과 카디널리티는 DBMS를 운용함에 따라 변한다
	- 그 시점에 적절했던 실행 계획이 또 다른 시점에 이르러서는 그렇지 않을 수 있다
- 이러한 변화에 대처하기 위해 나타난 것이 비용 기반의 동적 실행 계획이다
	- 사람의 판단에 따라 실행 계획을 고정시켜 버리는 것은 DBMS의 진화에 역행하는 발상이다
- 데이터의 특성을 바탕으로 시간에 따라 데이터가 어떻게 변화할지를 유사적으로 모방하고 성능 테스트를 실시해야 한다

## 3. 흔들리는 실행계획
- 실행 계획을 옵티마이저에게 맡겨도 최적의 실행 계획이 선택되지 않는 경우가 있다
- 대표적인 '옵티마이저의 실패'는 장기적인 운용 중에 실행 계획이 안 좋은 방향으로 변화해버리는 것이다
	- 데이터 양의 증가에 따라 통계 정보가 변했을 때, 일정한 역치를 넘으면 옵티마이저가 실행 계획을 변화시키면서 일어난다
- 이러한 실행 계획 변동이 일어나기 가장 쉬운 연산이 결합이다
- 따라서 SQL 성능 변동 위험을 줄이려면 되도록 결합을 피해야 한다

---

### EXISTS 사용
```SQL
SELECT department_id, 
       department_name
FROM Departments d
WHERE EXISTS(SELECT *
             FROM Employees e
             WHERE e.department_id = d.department_id);
```

**실행 계획**
<img width="900" alt="image" src="https://user-images.githubusercontent.com/60502370/194852576-422ef5d6-b7be-42fb-b9c0-d9c8543d19c6.png">
- 주목해야 하는 부분은 'SEMI'라는 키워드다
- 'Semi-Join'은 한국어로 준결합 혹은 반결합이라 불린다
	- 일반적인 결합에는 나타나지 않고 EXISTS 혹은 IN을 사용할 때 쓰이는 특수한 알고리즘이다
- 특징
	- 결과에 구동 테이블의 데이터만 포함되며, 1개의 레코드는 반드시 1개의 결과만 생성한다
	- 내부 테이블에서 조건에 맞는 레코드를 1개라도 발견한 시점에서 남은 레코드의 검색을 생략하므로, 일반적인 결합보다 성능이 좋다

### NOT EXISTS 사용
```SQL
SELECT department_id, 
       department_name
FROM Departments d
WHERE NOT EXISTS(SELECT *
             FROM Employees e
             WHERE e.department_id = d.department_id);
```

**실행 계획**
<img width="900" alt="image" src="https://user-images.githubusercontent.com/60502370/194854230-ed8f0066-a6da-413e-a4fa-33c14cb8d2c4.png">
- 'Anti-Join'은 한국어로 반결합이라 한다
- 반결합의 동작은 준결합과 거의 비슷하다
	- 내부 테이블에서 조건에 맞는 레코드를 1개라도 발견한 시점에 남은 레코드의 검색을 생략한다는 점은 같다
	- 다만 이번에는 구동 테이블의 레코드 데이터가 결과에서 제외된다는 차이가 있다
	- 반결합도 일반적인 결합에 비해 반복 횟수가 감소하므로 성능적으로 좋다


- EXISTS와 IN은 결과가 같을 때 실행 계획도 같을 가능성이 크다
- NOT EXISTS와 NOT IN은 결과가 같다해도 실행 계획이 다를 가능성이 높다