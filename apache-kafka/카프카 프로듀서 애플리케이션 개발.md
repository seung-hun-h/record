# 프로듀서 소개
---

## 프로듀서 
- 프로듀서는 카프카에서 데이터의 시작점이다
- 프로듀서는 카프카에 필요한 데이터를 선언하고 브로커의 특정 파티션에 전송한다
- 프로듀서는 리더 파티션을 가지고 있는 브로커와 직접 통신한다

## 프로듀서 내부 구조
![image](https://user-images.githubusercontent.com/60502370/204720657-0a697c47-530e-443f-a787-7048325bcf8e.png)
- ProducerRecord
	- 프로듀서에서 생성하는 레코드
	- 오프셋은 포함하지 않는다
- send()
	- 레코드를 전송 요청하는 메서드
- Partitioner
	- 데이터를 전송할 파티션을 지정한다
	- 기본값은 DefaultPartitioner로 설정된다
- Accumulator
	- 데이터를 배치로 묶는 버퍼

# 프로듀서 파티셔너
---
- Producer API를 사용하면 `UniformStickyPartitioner`, `RoundRobinPartitioner`가 제공된다
- 카프카 클라이언트 라이브러리 2.5 버전을 기준으로 기본 파티셔너는 `UniformStickyPartitioner`이다

## 메시지 키 유무에 따른 동작
- 메시지 키가 있는 경우
	- `UniformStickyPartitioner`, `RoundRobinPartitioner` 모두 메시지 키가 있을 때는 메시지 키의 해시값과 파티션을 매칭하여 전송한다
	- 동일한 메시지 키를 가진 레코드는 동일한 파티션에 전송된다
	- 파티션의 개수가 변경될 경우 메시지 키와 파티션의 매핑 정보는 깨지게 된다

- 메시지 키가 없는 경우
	- 메시지 키가 없을 때는 파티션에 최대한 동일하게 분배하는 로직이 동작한다
	- `RoundRobinPartitioner`
		- ProducerRecord가 들어도는 순서대로 파티션을 순회하며 전송
		- Accumulator에서 데이터가 묶이는 정도가 적기 때문에 전송 성능이 낮다
	- `UniformStickyPartitioner`
		- 메시지 키가 없는 경우 round robin 방식에서 레코드가 분산되어 전송 성능이 낮아지는 단점을 해결
		- 데이터가 배치 사이즈 만큼 채워지거나, 아니면 다른 방식으로 배치가 완료될 때까지 레코드를 한 배치에 묶어 전송한다
		- 배치를 전송한 이후 새로운 배치에 레코드를 다시 묶는다

## 커스텀 파티셔너
- 카프카 클라이언트 라이브러리에서 제공하는 `Partitioner` 인터페이스를 구현한다
- 메시지 키뿐 아니라 메시지 값에 따른 파티션 로직을 작성할 수도 있다

# 프로듀서 주요 옵션
---
## 필수 옵션

| Option           | Description                                                                                                                                                                                                |
| ---------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| bootstrap.server | 프로듀서가 데이터를 전송할 카프카 클러스터에 속한 브로커의 호스트이름:포트이다. 1개 이상 작성하고, 2개 이상 브로커 정보를 작성하여 일부 브로커에 이유가 발생하더라도 접속하는데 이슈가 없도록 설정가능하다 |
| key.serializer   | 레코드의 메시지 키를 직렬화하는 클래스를 지정한다                                                                                                                                                          |
| value.serializer | 레코드의 메시지 값을 직렬화하는 클래스를 지정한다                                                                                                                                                          |

## 선택 옵션

| Option                                | Description                                                                                                                                    |
| ------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------- |
| acks                                  | 프로듀서가 전송한 데이터가 브로커들에 정상적으로 저장되었는이 확인하는 옵션이다. 0, 1, -1(all) 중 하나로 설정할 수 있다                        |
| linger.ms                             | 배치를 전송하기 전까지 기다리는 최소시간이다. 기본값은 0이다                                                                                   |
| retries                               | 브로커에게 에러를 응답받고 난 뒤 재전송을 시도하는 횟수이다. 기본값은 2147483647이다                                                           |
| max.in.flight.requests.per.connection | 한 번에 요청하는 최대 커넥션 수이다. 설정된 값만큼 동시에 전달을 요청한다. 기본값은 5이다. Seneder Thread 개수로 보면 된다                     |
| partitioner.class                     | 레코드를 파티션에 전송할 때 적용하는 파티셔너 클래스를 지정한다. 기본값은 `org.apache.kafka.clients.producer.internals.DefaultPartitioner`이다 |
| enable.idempotence                    | 멱등성 프로듀서로 동작할 지 여부를 설정한다. 기본값은 false이다                                                                                |
| transactional.id                      | 프로듀서가 레코드를 전송할 때 레코드를 트랜잭션 단위로 묶을지 여부를 설정한다. 기본값은 null이다                                               |


# ISR과 acks 옵션
---
## ISR(In-Sync-Replicas)
- ISR은 리더 파티션과 팔로워 파티션이 모두 싱크가 된 상태를 뜻한다
- 동기화가 완료됐다는 의미는 리더 파티션의 모든 데이터가 팔로워 파티션에 복제된 상태를 말한다
- 리더 파티션에 데이터가 적재된 이후 팔로워 파티션에 복제하는 시간차 때문에 리더 파티션과 팔로워 파티션간 오프셋 차이가 발생할 수 있다

## acks
- 카프카 프로듀셔의 acks 옵션은 0, 1, -1(all) 값을 가질 수 있다

### acks=0
- 프로듀서가 리더 파티션으로 데이터를 전송했을 때 리더 파티션에 데이터 저장이 완료됐는지 확인하지 않겠다는 뜻이다
- 프로듀서는 리더 파티션에게 데이터가 저장됐는 지 응답을 받지 않는다
- 데이터 유실이 발생하더라도 전송 속도가 중요한 경우에 사용한다

### acks=1
- 프로듀서가 리더 파티션에 대해서만 데이터 저장이 완료됐는지에 대한 응답을 받는다
- 리더 파티션에 데이터가 정상적으로 저장되지 않았다면, 리터 파티션에 적재될 때까지 재시도할 수 있다
- 리더 파티션에 데이터가 적재 되었더라도 데이터가 유실될 수 있다
	- 리더 파티션에 데이터가 적재되고, 팔로워 파티션에 데이터가 복제되기전 브로커에 장애가 발생하면 데이터가 유실된다
- 일반적으로 가장 많이 사용하는 값이다

### acks=-1(all)
- 프로듀서가 리더 파티션과 팔로워 파티션까지 데이터가 적재되었는 지 확인한다
- 0, 1 옵션 보다는 속도가 느리다
- 팔로워 파티션에 데이터가 정상 적재됐는지 확인하기 때문에 브로커에 장애가 발생하더라도 안전하게 데이터를 보관할 수 있다
- 해당 옵션을 사용하는 경우 토픽 단위로 데이터 복제 설정을 할 수 있다
	- `min.insync,replicas` 옵션값에 따라서 프로듀서가 데이터가 정상 적재됐는지 확인한다

### min.insync.replicas
- 프로듀서가 리더 파티션과 팔로워 파티션에 데이터가 적재됐는지 확인하기 위한 최소 ISR 그룹의 파티션 개수이다
- 옵션값이 1이라면 ISR중 최소 1개 이상의 파티션에 데이터가 적재됐음을 의미한다
- 이 경우 acks가 1인 경우와 동일하게 동작한다. ISR 중 가장 먼저 적재되는 파티션은 리더 파티션이기 때문이다

### acks=-1, min.insync.replicas=2
- 해당 옵션을 설정하게 되면 최소 2개 이상의 파티션에 데이터가 정상 적재된 것을 의미한다
- 카프카 클러스터를 운영하면서 2개의 브로커가 동시에 중단되는 경우는 드물기 때문에 대부분의 경우 데이터가 유실되지 않는다

