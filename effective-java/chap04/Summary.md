## ITEM15 클래스와 멤버의 접근을 최소화 하라
- 프로그램 요소에 대한 접근을 최소화 해야 한다
- 꼭 필요한 것만 골라 public API를 설계해야 한다
- 클래스는 상수 필드 (`public static final`)를 제외한 그 어떤 `public` 필드도 가져서는 안된다

#### 정보 은닉의 장점
- 시스템 개발 속도를 높인다
- 시스템 관리 비용을 낮춘다
- 정보 은닉 자체가 성능을 높여주지는 않지만 성능 최적화에 도움을 준다
- 소프트웨어 재사용성을 높인다
- 큰 시스템을 제작하는 난이도를 낮춰준다

#### 자바의 정보 은닉
- 접근 제어자(access modifier)를 제공한다
	- public, package-private, protected, private
- 모듈 시스템
---
## ITEM16 public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라
- public 클래스는 절대 가변 필드를 직접 노출해서는 안된다
- 필드를 public으로 공개하면 클래스는 캡슐화의 이점을 누릴 수 없다
- 패키지 바깥에서 접근할 수 있는 접근자를 제공하라
---
## ITEM17 변경 가능성을 최소화 하라
- 가능한 불변 클래스를 만들어 변경 가능성을 최소화하라

#### 불변 클래스를 만들기 위한 규칙
1. 객체의 상태를 변경하는 메서드를 제공하지 않는다
2. 클래스를 확장할 수 없도록 한다
3. 모든 필드를 final로 선언한다
4. 모든 필드를 private으로 선언한다
5. 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다

### 불변 클래스의 장점
1. 단순하다
2. 스레드 안전하다
3. 불변 객체 내부 데이터를 공유할 수 있다
4. 불변 객체를 다른 불변 객체의 구성요소로 사용하면 이점이 많다
5. 그 자체로 실패 원자성을 제공한다

### 불변 클래스의 단점
1. 값이 다르면 반드시 독립된 객체로 만들어야 한다
2. 원하는 객체를 완성하기까지의 단계가 많고, 그 중간 단계에 만들어진 객체들이 모두 버려진다면 성능 문제가 불거진다
---
## ITEM18 상속보다는 컴포지션을 사용하라
- 상속은 여러가지 문제점을 지니고 있기 떄문에 컴포지션을 사용하는 것이 더 좋을때가 많다

### 상속의 문제점
- 상속은 위험하다
- 상속은 캡슐화를 깨뜨린다
- 상위 클래스에 새로운 메서드가 추가될 수 있다

### 컴포지션을 사용하자
- 상속으로 인해 발생할 수 있는 문제를 해결할 수 있다
- private 필드로 기존 클래스를 참조
- 새 클래스의 인스턴스들은 기존 클래스에 대응하는 메서드를 호출한다

### 상속을 사용할 때 주의점
- 상속은 반드시 하위 클래스가 상위 클래스의 '진짜' 하위 타입인 상황에만 쓰여야한다
- 컴포지션을 사용해야 할 때 상속을 사용하면 내부 구현을 불필요하게 노출하는 꼴이다
- 상속을 사용하기로 결정할 때 자문하라
	- 확장하려는 클래스의 API에 아무런 문제가 없는가
	- 결함이 있다면, 이 결함이 여러분 클래스 API까지 전파되어도 되는가
	- 컴포지션은 결함을 숨길 수 있지만 상속은 결함까지 전파된다
---
## ITEM19 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라
- 상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지 문서로 남겨야 한다
	- `@ImpleSpec` 태그를 달면 자바독 도구가 만들어준다
	- 재정의 가능 메서드를 호출할 수 있는 모든 상황을 문서로 남겨야 한다
	- 재정의 가능 메서드가 다른 재정의 가능 메서드를 호출할 수도 있다
- 효율적인 하위 클래스를 어려움 없이 만들기 위해서 내부 동작 과정에 끼어들 수 있는 훅을 protected로 공개해야 할 수도 있다
- 상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어보는 것이다

### 상속용 클래스의 제약
- 상속용 클래스의 생성자는 직간점적으로 재정의 가능 메서드를 호출해서는 안된다
	- 클래스가 두 가지 상태를 가질 수 있다
- Cloneable과 Serializable 인터페이스는 상속용 클래스 설계의 어려움을 더한다
	- 둘 중 하나라도 구현한 클래스를 상속용으로 설계한다는 것은 일반적으로 좋지 않은 방법이다
- 상속용으로 설계하지 않은 클래스는 상속을 금지하자
---
## ITEM20 추상 클래스보다는 인터페이스를 우선하라
- 일반적으로 다중 구현용 타입으로는 인터페이스가 적합하다
	- 복잡한 인터페이스라면 골격 구현을 함께 제공해도 좋다
	- 골격은 가능한 한 인터페이스의 디폴트 메서드로 제공하라
	- 하지만 종종 인터페이스의 구현상 제약으로 인해서 골격 구현을 추상 클래스로 제공할 수도 있다

### 인터페이스의 장점
- 기존 클래스에도 쉽게 새로운 인터페이스를 구현해 넣을 수 있다
- 믹스인 정의에 안성맞춤이다
	- 선택정 행위를 제공하기 쉽다는 뜻이다
- 계층 구조가 없는 타입 프레임워크를 만들 수 있다
	- 인터페이스가 다른 인터페이스를 확장해서 유연하게 조합할 수 있다
- 래퍼 클래스와 함께 사용해 기능을 향상 시킬 수 있다
- 구현 방법이 명백한 것은 디폴트 메서드로 제공할 수 있다

### 인터페이스와 추상 골격 구현
- 인터페이스와 추상 클래스의 장점을 모두 취하는 방법이다
- 인터페이스로 타입을 정의하고, 필요하다면 디폴트 메서드를 몇개 제공한다
- 골격 구현 클래스는 나머지 메서드를 구현한다
- 작성 방법
	1. 인터페이스를 잘 살펴 다른 메서드들의 구현에 사용되는 기반 메서드를 선정한다
	2. 기반 메서드를 사용해 직접 구현할 수 있는 메서드를 모두 디폴트 메서드로 제공한다
	3. 인터페이스를 구현하는 골격 구현 클래스를 하나 만들어 남은 메서드를 작성해 넣는다
---
## ITEM21 인터페이스는 구현하는 쪽을 생각해 설계하라
- 디폴트 메서드라는 도구가 생겼어도 인터페이스를 설계할 때는 세심한 주의를 기울여야 한다
- 기존 인터페이스에 디폴트 메서드를 추가하면 커다란 위험도 같이 따라온다
- 새로운 인터페이스라면 릴리즈 전에 반드시 테스트 해봐야 한다
- 인터페이스를 릴리즈한 후라도결함을 수정하는게 가능할 수 있지만, 절대 그 가능성에 기대서는 안된다
---
## ITEM22 인터페이스는 타입을 정의하는 용도로만 사용하라
- 인터페이스는 자신을 구현한 클래스의 인터페이스를 참조할 수 있는 타입 역할을 하고, 이것만을 위해 사용해야 한다
- 상수를 인터페이스에 선언하고 해당 인터페이스의 구현 클래스를 만드는 경우가 있다
	- 이는 내부 구현을 외부로 공개하는 꼴이다
- 상수는 특정 클래스와 인터페이스에 강하게 연관되는 경우 거기에다 작성하고, 그렇지 않을 경우에는 유틸리티 클래스에 담아 공개하라
---
## ITEM23 태그 달린 클래스보다는 클래스 계층 구조를 활용하라
- 태그 달린 클래스를 써야하는 상황은 거의 없다
- 새로운 클래스를 작성하는데 태그 필드가 등장한다면 태그를 없애고 계층구조로 대체하는 방법을 생각해보자
- 기존 클래스가 태그 필드를 사용하고 있다면 계층구조로 리팩터링 하라

### 계층 구조의 장점
- 간결하고 명확하다
- 각 의미를 독립된 클래스로 분리하여 관련없던 데이터 필드가 사라졌다
- 각 클래스의 필드를 final로 선언할 수 있다
- 각 클래스의 생성자가 모든 필드를 초기화 했는지, 추상 메서드를 구현했는지 컴파일러가 검사해준다
- 프로그래머들이 독립적으로 계층구조를 확장하고 사용할 수 있다
- 변수의 의미를 명시 하거나 제한할 수 있고, 특정 의미만 매개 변수로 받을 수 있다
---
## ITEM24 멤버 클래스는 되도록 static으로 만들어라
- 중첩 클래스는 다른 클래스안에 정의된 클래스를 말한다
	- 정적 멤버 클래스, 멤버 클래스, 익명 클래스, 지역 클래스가 존재한다
- 정적 멤버 클래스
	- 바깥 클래스의 private 멤버에도 접근할 수 있다는 점만 제외하면 다른 클래스와 동일하다
	- 바깥 클래스와 함께 쓰일 때만 유용한 public 도우미 클래스로 쓰인다
- 비정적 멤버 클래스
	- 정적 멤버 클래스와 static 유무의 문법상 차이가 있다. 의미상은 차이가 많이 난다
	- 비정적 멤버 클래스는 바깥 클래스의 인스턴스와 암묵적으로 연결된다
	- 개념상 중첩 클래스의 인스턴스가 바깥 인스턴스와 독립적으로 존재할 수 있다면 정적 멤버 클래스로 만들어야 한다
	- 비정적 멤버 클래스와 바깥 인스턴스와 관계는 멤버 클래스가 인스턴스화 될 때 확립되며, 더이상 변경할 수 없다
	- 비정적 멤버 클래스는 어댑터를 정의할 때 자주 쓰인다
	- 멤버 클래스에서 바깥 인스턴스에 접근할 일이 없다면 무조건 static을 붙여서 정적 멤버 클래스로 만들자
- 익명 클래스
	- 이름이 없는 클래스
	- 쓰이는 시점에 선언과 동시에 인스턴스가 만들어진다
	- 정적 문맥에서라도 상수 변수 이외에 정적 멤버는 가질 수 없다
	- 정적 팩터리 메서드를 구현할 때 주로 사용된다
	- 제약
		- 선언한 지점에만 인스턴스를 만들 수 있다
		- instanceof 검사나 클래스의 이름이 필요한 작업은 수행할 수 없다
		- 여러 인터페이스를 구현할 수 없고, 인터페이스를 구현하는 동시에 다른 클래스를 상속할 수 없다
		- 짧지 않으면 가독성이 떨어진다
		- 익명 클래스를 사용하는 클라이언트는 그 익명 클래스가 상위 타입에서 상속한 멤버 외에는 호출할 수 없다
- 지역 클래스
	- 지역 변수를 선언할 수 있는 곳이면 실질적으로 어디든 사용할 수 있고, 유효 범위도 지역변수와 같다
	- 익명 클래스와 비슷한 제약을 가진다
---
## ITEM25 톱클래스는 한 파일에 하나만 담으라
- 소스 파일 하나에 톱레벨 클래스 여러개를 선언하더라도 컴파일 에러는 발생하지 않는다
- 이렇게 하면 한 클래스를 여러 가지로 정의할 수 있으며, 그 중 어느 것을 사용할지는 어느 소스 파일을 먼저 컴파일하냐에 따라 달라진다
- 톱클래스는 한 파일에 하나만 담도록 하