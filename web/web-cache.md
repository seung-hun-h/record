# 캐시
- 웹 캐시는 자주 쓰이는 문서의 사본을 자동으로 보관하는 HTTP 장치이다
  - 웹 요청 시 대상 문서가 캐시에 존재하면 그 문서를 서버가 아닌 캐시에서 제공한다

## 웹 캐시의 장점
### 불필요한 데이터 전송을 줄인다
- 원 서버가 중복해서 트래픽을 주고받는 낭비가 줄어들게 된다
- 서버의 응답을 캐시에 저장하여 불필요한 데이터 전송을 막는다
  - 불필요한 데이터 전송은 네트워크 대역폭을 잡아먹고, 전송을 느리게 만들며, 웹 서버에 부하를 준다

### 네트워크 병목을 줄인다
- 많은 네트워크가 원격 서버보다 로컬 네트워크 클라이언트에 더 넓은 대역폭을 제공한다
- 크기가 큰 문서의 사본을 로컬 네트워크 캐시에 저장하면 네트워크 병목을 줄일 수 있다
  - 네트워크 대역폭은 크기가 큰 문서일수록 지연이 발생한다

### 갑작스런 요청 쇄도에 대한 대응
- 캐싱은 갑작스런 요청 쇄도에 대처하기 위해 특히 중요하다
  - 많은 사람이 거의 동시에 문서를 요청하면 트래픽이 급증하여 네트워크와 웹 서버에 심각한 장애를 일으킨다

### 거리로 인한 지연 감소
- 빛의 속도 그 자체가 유의미한 지연을 일으킨다
  - 빛은 1초에 300,000km를 이동한다
- 클라이언트와 서버 사이에 유의미한 거리 차가 존재하면 빛의 속도로인한 지연이 발생할 수 있다

## 캐시 적중과 부적중
- 캐시에 요청이 도착했을때 사본이 존재하면 사본을 전달하여 빠르게 응답할 수 있다
  - 하지만 사본이 존재하지 않는다면 요청이 원 서버로 전달될 것이다
- 캐시에 사본이 존재하는 것을 캐시 적중(HIT), 존재하지 않는 것을 부적중(MISS)라 한다

### 재검사(Revalidation)
- 원 서버의 콘텐츠는 변경될 수 있기 때문에, 캐시는 반드시 가지고있는 사본이 원 서버의 콘텐츠와 동일한지 확인해야 한다
  - HTTP는 효과적인 검사를 위해 전체 콘텐츠를 가져오지 않고도 검사할 수 있는 방법을 제공한다
- 네트워크 대역폭을 효과적으로 사용하기 위해 사본이 충분히 오래된 경우에만 재검사를 진행한다
- 콘텐츠가 변경되지 않았다면 `304 Not Modified` 응답을 보낸다

## 캐시 토폴로지
- 캐시는 한 명의 사용자에게만 할당될 수도 있고, 수 많은 사람들간 공유될 수도 있다
  - 개인에게 할당된 캐시를 개인 캐시(Private Cache), 공유된 캐시를 공용 캐시(Public Cache)라 한다

### 개인 캐시(Private Cache)
- 개인 캐시는 많은 저장 공간을 필요로하지 않는다
- 웹 브라우저는 개인 캐시를 내장하고 있다
  - 자주 쓰이는 문서를 개인 컴퓨터의 디스크와 메모리에 캐시해 놓는다
  - 사용자가 캐시의 크기와 설정을 수정할 수 있도록 허용한다

### 공용 프락시 캐시
- 공용 캐시는 캐시 프락시 서버 혹은 프락시 캐시라고 불리는 특별한 종류의 프락시 서버이다
- 공용 캐시는 여러 사용자가 접근하기 때문에 개인 캐시에 비해 불필요한 트래픽을 더 많이 줄일 수 있다
- 공용 캐시는 원 서버로부터 자주 요청되는 문서를 가져외 캐싱한다

## 캐시 처리 단계
### 1. 요청 받기
- 네트워크 커넥션에서의 활동을 감지하고 들어오는 데이터를 읽는다

### 2. 파싱
- 요청 메시지를 파싱하여 헤더 부분을 조작하기 쉬운 자료구조에 담는다

### 3. 검색
- URL을 알아내고 해당하는 로컬 사본이 있는지 확인한다
  - 사본은 메모리나 디스크 심지어 근처의 다른 컴퓨터에 위치할 수도 있다
- 문서를 로컬에서 가져올 수 없다면 상황이나 설정에 따라 원 서버나 부모 프락시에서 가져오거나 실패를 반환한다
- 캐시된 객체는 서버 응답 본문과 원 서버 응답헤더를 포함하고 있다
  - 캐시 적중동안 올바른 서버 헤더가 반환될 수 있다
  - 얼마나 오랫동안 캐시에 머물고 있었는지, 얼마나 자주 사용되었는지 등에 대한 메타데이터를 포함한다

### 4. 신선도 검사
- HTTP는 캐시가 일정 기간 동안 원 서버 문서의 사본을 보유할 수 있도록 해준다
  - 이 기간 동안 해당 사본은 신선한 것으로 간주된다
  - 일정 기간이 지나면 해당 사본은 신선하지 않은 것으로 간주되어 재검사를 실시해야 한다

### 5. 응답 생성
- 캐시는 캐시된 서버 응답 헤더를 토대로 응답 헤더를 생성한다
- 캐시는 클라이언트에 맞게 헤더를 조정해야 하는 책임이 있다

### 6. 전송
- 응답 헤더가 준비되면, 캐시는 응답을 클라이언트들에게 전달한다

### 7. 로깅
- 대부분의 캐시는 로그 파일과 캐시 사용에 대한 통계를 유지한다

## 사본을 신선하게 유지하기
- HTTP는 캐시를 위한 문서 만료와 서버 재검사 메커니즘을 가지고 있다

### 문서 만료
- HTTP는 `Cache-Control`과 `Expires`라는 특별한 헤더들을 이용해서 원 서버가 각 문서에 유효기간을 붙일 수 있게 해준다
- 캐시 문서가 만료되기 전, 캐시는 원 서버와 접촉없이 클라이언트에게 문서를 제공할 수 있다
- 캐시된 문서가 만료되면 반드시 캐시는 원 서버의 문서에 변경된 것이 있는지 확인해야 한다

### 유효기간과 나이
- `Cache-Control: max-age`
  - 문서의 최대 나이를 정의한다
  - 초 단위로 작성한다
- `Expires`
  - 절대 유효기간을 명시한다
  - 유효기간이 경과하면 해당 문서는 신선하지 않은 것으로 간주한다

### 서버 재검사
- 캐시 문서가 만료되었다는 것은 원 서버의 문서가 변경되었는지 재검사가 필요하다는 것을 의미한다
  - 반드시 원본과 사본이 다르다는 것을 의미하지 않는다
- 서버 재검사는 캐시가 원 서버에게 문서가 변경되었는지 물어보는 것을 의미한다
  - 재검사 결과 콘텐츠가 변경되었다면 캐시는 새로운 사본을 가져와 저장하고 클라이언트에게 전달한다
  - 재검사 결과 콘텐츠가 변경되지 않았다면 캐시는 새 만료일을 포함한 새 헤더들만 가져와서 캐시 안의 헤더들을 갱신한다

### 조건부 메서드와의 재검사
- HTTP의 조건부 메서드는 재검사를 효율적으로 만들어준다
  - HTTP는 캐시가 서버에게 '조건부 GET'이라는 요청을 보낼 수 있게 한다
  - 서버가 갖고 있는 문서가 캐시가 갖고 있는 문서와 다른 경우에만 객체 본문을 보내달라는 요청이다
  - 조건부 GET은 조건부 헤더를 추가해야 한다
- HTTP가 제공하는 조건부 헤더
  - `If-Modified-Since: <date>`
    - 문서가 주어진 날짜 이후로 수정되었다면 요청 메서드를 처리한다
    - 캐시된 버전으로부터 콘텐츠가 변경된 경우에만 콘턴츠를 가져오기 위해 `Last-Modified` 헤더와 함께 사용된다
  - `If-None-Match: <tags>`
    - 서버가 문서에 대한 일련번호와 같이 동작하는 특별한 태그를 제공한다
    - 캐시된 태그와 서버에 있는 문서의 태그가 다를때 요청을 처리한다

### If-Modified-Since: 날짜 재검사
- IMS 요청이라고도 한다
- 서버에게 리소스가 특정 날짜 이후로 변경된 경우에만 본문을 보내달라고 요청한다
  - 문서가 주어진 날짜 이후에 변경된 경우 GET 요청은 성공한다
    - 새로운 문서, 새로운 만료 날짜 그리고 그 외 다른 정보들이 담긴 헤더가 함께 전달된다
  - 문서가 주어진 날짜 이후에 변경되지 않으면 서버는 `304 Not Modified`를 응답한다
    - 효율을 위해 본문을 보내지 않는다
- 응답 헤더의 `Last-Modified` 헤더와 함께 동작한다
- 변경 일시 재검사가 어려운 경우
  - 어떤 문서는 일정 시간 간격으로 다시 쓰여지지만 내용에는 변화가 없을 수 있다
  - 어떤 문서들의 변경은 전 세계의 캐시들이 그 데이터를 다시 읽어들이기엔 사소한 것일 수 있다(철자나 주석의 변경)
  - 어떤 서버들은 그들이 갖고 있는 페이지에 대한 최근 변경 일시를 정확하게 판별할 수 없다
  - 1초보다 작은 간격으로 갱신되는 문서를 제공하는 서버들에게는, 변경일에 대한 1초 정밀도는 충분하지 않을 수 있다

### If-None-Match: 엔터티 태그 재검사
- 변경 일시 재검사가 어려운 경우에는 엔터티 태그 재검사를 사용할 수도 있다
- 엔터티 태그가 변경되지 않은 경우에는 `304 Not Modified`응답을 전달한다
- `If-None-Match`에 여러 엔터티 태그가 포함될 수 있다

### 약한 검사기와 강한 검사기
- HTTP/1.1은 약한 검사기를 지원한다
  - 약한 검사기란 콘턴츠가 조금 변경되더라도 그 정도면 같다고 서버가 주장할 수 있는 것을 의미한다
  - 약한 검사기는 어느 정도 콘턴츠 변경을 허용하지만 콘텐츠의 중요한 의미가 변경되만 함께 변경된다

- 강한 검사기는 콘텐츠가 바뀔 때마다 바뀐다
  - 대응하는 엔터티의 값이 어떻게 바뀌든 매번 반드시 같이 바뀌어야 한다
  - 약한 검사기와 구분할 수 있도록 엔터티 태그 앞에 `W/`를 붙인다

### 엔터티 태그, Last-Modified 사용 시점
- HTTP/1.1 클라이언트는 서버가 엔터티 태그를 반환했더라면 반드시 엔터티 태그 검사기를 사용해야 한다
- 서버가 `Last-Modifed`를 반환헀다면 변경 시점 검사기를 사용할 수 있다
- 엔터티 태그와 최근 변경 일시가 모두 사용가능하다면 HTTP/1.0과 HTTP/1.1 캐시 모두 적절히 응답할 수 있도록 두 가지 재검사 정책을 모두 사용해야 한다
- HTTP/1.1 원 서버는 실현 불가능하지 않다면, 엔터티 태그 검사기를 보내야 한다.
  - 강한 엔터티 태그 대신 약한 엔터티 태그를 보낼 수도 있다
  - `Last-Modified` 값을 같이 보내는 것도 선호된다

## 캐시 제어
- 문서가 만료되기 전까지 얼마나 오랫동안 캐시될 수 있게 할 것인지 서버가 설정할 수 있는 여러가지 방법을 정의한다
- Cache-Control: no-store
- Cache-Control: no-cache
- Cache-Control: must-revalidate
- Cache-Control: max-age
- Expries
- 휴리스틱 만료

### no-cache, no-store
- no-store
  - 캐시가 그 응답의 사본을 만드는 것을 금지한다
- no-cache
  - 서버와 재검사를 하지 않고 캐시에서 클라이언트로 제공될 수 없다
  - 로컬 캐시 저장소에 저장할 수는 있다
- Pragma: no-cache
  - HTTP/1.0+와의 하위 호환성을 위함

### max-age
- 문서가 서버로부터 온 이후로 캐싱 될 수 있는 시간이며 초로 나타낸다
- max-age=0 으로 설정해 캐시가 매 접근마다 문서를 캐시하거나 리프레시하지 않도록 요청할 수 있다
  - 최근에는 거의 사용하지 않는다

### Expires 헤더
- 실제 만료 날짜를 명시한다

### must-revalidate
- 캐시가 신선하지 않은 삽손을 원 서버와 최초의 재검사 없이는 제공해서는 안됨을 의미한다
- 캐시가 must-revalidate 신선도 검사를 시도했을 때 원 서버가 사용할 수 없는 상태라면, 캐시는 반드시 `504 Gateway Timeout error`를 반환해야한다
  - 클라이언트가 요청시 프록시 캐시가 사본을 전달할지, 원 서버에 요청을 전달할지 결정한다
  - Cache-Control: no-cache가 요청 헤더에 있다면 원 서버로 요청을 전달한다
  - 이때 원 서버가 사용할 수 없는 상태라면, 프록시는 정책상 200을 전달할 수도 있다
  - Cache-Control: must-revalidate가 헤더에 포함되면 이러한 상황에서 반드시 `504 Gateway Timeout error`를 반환해야 한다

### 휴리스틱 만료
- `Cache-Control: max-age` 헤더나 `Expires` 헤더 중 어느 것도 포함되지 않는 경우에 캐시는 경험적인 방법으로 최대 나이를 계산한다




