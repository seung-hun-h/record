## 목차
- [실용주의 접근법](#실용주의-접근법)
  - [좋은 설계의 핵심](#좋은-설계의-핵심)
    - [ETC는 규칙이 아니라 가치](#etc는-규칙이-아니라-가치)
  - [DRY: 중복의 해악](#dry-중복의-해악)
    - [DRY는 코드 밖에서도](#dry는-코드-밖에서도)
    - [모든 코드 중복이 지식의 중복은 아니다](#모든-코드-중복이-지식의-중복은-아니다)
    - [문서화 중복](#문서화-중복)
    - [데이터의 DRY 위반](#데이터의-dry-위반)
    - [표현상의 중복](#표현상의-중복)
    - [개발자 간의 중복](#개발자-간의-중복)
  - [직교성](#직교성)
    - [직교성이란](#직교성이란)
    - [직교성의 장점](#직교성의-장점)
    - [설계](#설계)
    - [툴킷과 라이브러리](#툴킷과-라이브러리)
    - [코딩](#코딩)
    - [테스트](#테스트)
    - [문서화](#문서화)
  - [가역성](#가역성)
    - [가역성](#가역성-1)
    - [유연한 아키텍처](#유연한-아키텍처)
  - [예광탄](#예광탄)
    - [어둠 속에서 빛을 내는 코드](#어둠-속에서-빛을-내는-코드)
    - [예광탄이 언제나 목표물을 맞히는 것은 아니다](#예광탄이-언제나-목표물을-맞히는-것은-아니다)
    - [예광탄 코드 vs 프로토타이핑](#예광탄-코드-vs-프로토타이핑)
  - [프로토타입과 포스트잇](#프로토타입과-포스트잇)
    - [프로토타이핑 대상](#프로토타이핑-대상)
    - [프로토타입을 어떻게 사용할 것인가?](#프로토타입을-어떻게-사용할-것인가)
    - [아키텍처 프로토타이핑](#아키텍처-프로토타이핑)
    - [프로토타입 코드를 사용하지 않도록 하려면?](#프로토타입-코드를-사용하지-않도록-하려면)
  - [도메인 언어](#도메인-언어)
    - [도메인 언어의 특성](#도메인-언어의-특성)
    - [내부와 외부 언어의 장단점](#내부와-외부-언어의-장단점)

# 실용주의 접근법
## 좋은 설계의 핵심
> TIP: 좋은 설계는 나쁜 설계보다 바꾸기 쉽다

- 잘 설계된 코드는 바뀜으로써 사용하는 사람에게 맞춰져야 한다
  - 그래서 ETC(Easy To Change) 원칙을 따라야 한다
- 결합도를 줄이는 것, 단일 책임 원칙을 지키는 것, 이름을 잘 짓는 것은 모두 ETC를 위함이다

### ETC는 규칙이 아니라 가치
- ETC는 선택의 갈림길에서 도움을 주는 안내자이다
- 가치를 내면화하기 위해서는 초기에는 의식적으로 노력해야 한다
- 앞으로 어떤 모습으로 바뀔지 잘 모르겠을 때 언제건 궁극의 '바꾸기 쉽게'를 선택한다
  - 교체 가능하게 작성하라는 말은 코드의 결합도를 낮추고 응집도를 높이라는 이야기이다
- 실마리가 없는 경우를 본인의 직관을 발전시키는 기회로 삼으라
  - 엔지니어링 일지에 현재 상황과 본인의 선택, 그리고 변경 사항에 대한 추측을 정리 해둬라
  - 소스 코드에 이에 대한 표시를 해두고, 나중에 이 코드를 바꿔야 하는 시점이 왔을 때, 뒤를 돌아보고 자신에게 피드백을 할 수 있다

## DRY: 중복의 해악
- DRY: Don't Repeat Yourself
  - 모든 지식은 시스템 내에서 단 한 번만, 애매하지 않고, 권위 있게 표현되어야 한다
- 지식은 변화 한다. 때로는 급격하게 변화한다
- 사람들은 애플리케이션이 출시되었을 때 유지보수가 시작된다고 말하지만, 사실이 아니다
- 개발자는 항상 유지보수를 해야 한다
- 소프트웨어를 신뢰성 높게 개발하는 유일한 길, 개발을 이해하고 유지 보수하기 쉽게 만드는 유일한 길은 DRY 원칙을 따르는 것이다
  
### DRY는 코드 밖에서도
- DRY는 지식의 증복, 의도의 중복에 대한 것이다
- 똑같은 개념을 두 군데서 표현하면 안된다는 것을 의미한다

### 모든 코드 중복이 지식의 중복은 아니다
- 온라인 와인 주문 프로그램에서 사용자의 연령과 주문 수량을 기록하고 검증하는 기능이 있다고 가정
  - 연령과 주문 수량은 모두 숫자이고 0 보다 커야 한다고 가정

```python
def validate_age(value):
  validate_type(value, :integer)
  validate_min_integer(value, 1)

def validate_quantity(value):
  validate_type(value, :integer)
  validate_min_integer(value, 1)
```

- 위 함수 2개는 내용이 동일하지만, 표현하는 지식이 다르다
- 서로 다른 것을 검증하고 있지만, 우연히 규칙이 같은 것일 뿐이다

### 문서화 중복
- 주석을 다는 것은 지식의 중복이다
- 코드가 의도를 잘 나타낸다면 주석을 달 필요 없다

### 데이터의 DRY 위반
```java
class Line {
  private Point start;
  private Point end;
  private double length;
}
```

- 자료 구조는 지식을 표현하고, DRY 원칙을 위배할 수 있다
- 위 클래스에서 시작점과 끝점이 결정되면 그 사이의 길이를 알 수 있다
  - 따라서 `length`는 DRY를 위반했다
  - 시작점과 끝점이 달라지면 `length`가 변경된다
  - 길이는 계산되는 필드로 만드는 편이 낫다

```java
class Line {
  private Point start;
  private Point end;
  double length() { return start.distanceTo(end); }
}
```

- 개발을 진행하다 보면 성능 상의 이유로 DRY 원칙을 위배할 수 있다
- 중요한 것은 중복의 영향을 국소화 하는 것이다.
  - 바깥 세상에는 DRY 원칙 위배를 노출하지 않는다

```java
class Line {
  private Point start;
  private Point end;
  private double length;

  public Line(Point start, Point end) {
    this.start = start;
    this.end = end;
    calculateLength();
  }

  public void setStart(Point start) {
    this.start = start;
    calculateLength();
  }

  public void setEnd(Point end) {
    this.end = end;
    calculateLength();
  }

  private void calculateLength() {
    this.length = start.distanceTo(end);
  }
}
```

- 객체의 속성을 읽고 쓸 때는 접근자 함수를 사용하라
  - 모듈이 자료 구조를 노출하면 모듈 구현과 그 자료 구조를 사용하는 코드 사이에 결합이 생긴다

### 표현상의 중복
코드는 바깥 세상과 연결되기 때문에 중복을 완전히 피할 수 없다. 하지만 다소 완화 할 수는 있다.

- 내부 API에서 생기는 중복
  - 언어나 기술에 중립적인 형식으로 내부 API를 정의할 수 있는 도구를 찾아보라
  - 이러한 도구는 일반적으로 문서와 목 API, 기능 테스트를 생성해 주고, API 클라이언트도 여러 가지 언어로 생성해준다
- 외부 API에서 생기는 중복
  - 공개 API는 OpenAPI 같은 형식으로 문서화 하는 경우가 많다
  - 이런 형식의 APi 명세를 본인의 API 도구로 불러와 사용하면 더욱 신뢰성있게 해당 서비스를 연동할 수 있다
- 데이터 저장소와의 중복
  - 많은 데이터 저장소가 데이터 스키가 분석 기능을 제공한다
  - 이러한 기능을 사용하면 데이터 저장소와 코드간 중복을 줄일 수 있다
  - 영속성 프레임워크를 사요하면 데이터를 객체로 옮기기 위한 코드를 직접 작성하지 않아도 된다
  - 때에 따라서는 데이터를 단순한 키-값으로 저장하는 방식도 있다

### 개발자 간의 중복
- 같이 일하는 개발자들 사이에서 중복이 발생할 수 있다
- 대처하기 위해서는 의사소통을 잘하는 튼튼하고 유대가 돈독한 팀을 만들어야 한다
- 슬랙 같은 공통 채널을 만들 수 있고, 팀원 한 사람을 프로젝트 사서로 임명해 지식의 교환을 도울 수도 있다
- 코드 리뷰를 통해서 다른 사람의 코드를 읽을 수도 있다


## 직교성
직교성은 설계와 빌드, 테스트, 확장이 쉬운 시스템을 만드는 데에 있어 매우 중요한 개념이다. 직교성의 원칙을 적용하는 방법을 직접 배우면 시스템의 품질을 즉각 개선할 수 있을 것이다

### 직교성이란
- 두 직선이 직각으로 만나는 경우
- 벡터 용어로 표현하면 두 직선은 독립적이다
- 컴퓨터 과학에서는 독립성이나 결합도 줄이기(Decoupling)을 의미한다
  - 하나가 바뀌어도 나머지에 어떤 영향도 주지 않으면 서로 직교하는 것이다

### 직교성의 장점
> Tip 17: 관련 없는 것들 간에 서로 영향이 없도록 하라

개발자는 자족적인(self-contained) 컴포넌트, 즉 단일하고 잘 정의된 목적을 가진 독립적인 컴포넌트를 설계해야 한다. 요던과 콘스탄틴은 이를 응집이라고 부른다. 자족적인 컴포넌트는 각기 격리 되어 있으므로 변경되어도 그 영향이 외부로 퍼져나가지 않는다.

- 생산성 향상
  - 변화를 국소화 해서 개발 시간과 테스트 시간이 줄어든다
  - 컴포넌트에 명확하고 잘 정의된 책임이 할당되어 있으면 구현자가 생각하지 못한 방식으로 새로운 컴포넌트와 결합할 수 있다
  - 직교적인 컴포넌트를 결합함으로써 단위 노력당 더 많은 기능을 얻을 수 있다
- 리스크 감소
  - 감염된 코드가 격리되어 있어 그 증상이 전파될 확률이 낮다
  - 시스템이 잘 깨지지 않는다
  - 테스트를 더 많이 하게 된다
  - 특정 업체나 제품, 플랫폼에 덜 종속된다

### 설계
- 시스템은 서로 협력하는 모듈의 집합으로 구성되어야 하고, 각 모듈은 다른 부분과 독립적인 기능을 구현해야 한다
- 계층 구조는 직교적 시스템을 설계하는 강력한 방법이다
- 설계가 직교적인지 확인하는 방법은 특정 모듈을 변경하는 경우 그 영향이 몇개의 모듈에 퍼져나가는 지 확인하는 것이다
- 현실 세계의 변화와 설계 사이의 결합도을 줄이는 것도 확인해야 한다
  - 전화번호를 고객 식별자로 사용하는 등
  - 자신의 힘으로 제어할 수 없는 속성에 의존하지 말라

### 툴킷과 라이브러리
- 외부에서 만든 툴킷이나 라이브러리를 도입할 때 시스템의 직교성을 해치지 않는지 주의 깊게 살펴보아야 한다

### 코딩
직교성을 유지하기 위한 몇 가지 방법이 있다
- 코드의 결합도를 줄여라
  - 불필요한 것은 다른 모듈에 보여 주지 않으며, 다른 모듈의 구현에 의존하지 않는 코드를 작성하라
  - 객체의 상태는 객체가 직접 바꾸도록 하라
- 전역 데이터를 피하라
  - 코드가 전역 데이터를 참조할 때마다 코드는 해당 데이터를 공유하는 다른 컴포넌트와 묶이게 된다
  - 싱글턴는 전역 데이터를 참조하도록 해 불필요한 결합을 만들 수 있다
- 유사한 함수를 피하라
  - 유사해 보이는 함수를 여럭 구현해야 할 때가 있다
  - 시작과 끝에는 동일한 코드를 사용하지만, 중간의 아고리즘이 다를경우 전략 패턴을 고려해보라

### 테스트
- 직교적으로 설계하고 구현한 시스템은 테스트하기 쉽다
- 테스트를 정규 빌드 과정의 일부로 수행하라
- 단위 테스트시 나머지 시스템 중 상당부분을 불러와야 할 경우 시스템 사이의 결합도를 줄이지 못했다는 뜻이다

### 문서화
- 마크다운을 사용하면 내용을 쓸 때는 내용에만 집중하고, 예쁘게 꾸미는 것은 다른 변환 도구에 맡길 수 있다

## 가역성
> 당신이 가진 생각이 딱 하나밖에 없다면, 그것만큼 위험한 것은 없다. - 에밀 오귀스트 샤르티에

영원한 것은 없다. 본인이 어떤 사실을 굳게 믿고 그 사실에 전적으로 의존하고 있더라도 그 사실 역시 언젠가 변하기 마련이다. 프로젝트를 진행하면서 특정 업체의 데이터베이스나 아키텍처 패턴, 어떤 배포 모델을 사용하기로 결정했따면 큰 비용을 치르지 않고는 되돌릴 수 없는 행동을 하기로 묶여버린 셈이다.

### 가역성
- 프로젝트 초기에는 최선의 결정을 내리지 못하기 때문에 되돌릴 수 없는 결정을 줄여야 한다
- 결정은 돌에 새겨진 것이 아니라 바닷가의 모래 위에 쓰인 글씨라 생각하라
- 개념을 올바르게 추상화하여 서비스를 제공하도록 만들었다면 달리는 도중에 말을 갈아탈 수 있는 유연성이 생긴다.
> Tip 18: 최종 결정이란 없다.


### 유연한 아키텍처
- 아키텍처가 변덕스러운 환경에서 계획을 세울 수는 없다
  - 할 수 있는 것은 바꾸기 쉽게 만드는 것이다
> Tip 19: 유행을 좇지 말라

## 예광탄
예광탄이 목표물을 맞힌다면 일반 탄환도 궤적을 일치시키면 목표물을 맞힐 수 있다. 군인들은 예광탄을 사용하여 조준을 조정한다. 군인에게 예광탄은 실시간 피드백을 제공하는 것이다. 

### 어둠 속에서 빛을 내는 코드
- 코딩에서 예광탄과 동일한 효과를 얻으려면 최종 시스템의 일부 측면까지 빨리, 눈에 보이게, 반복적으로 도달하게 해 줄 무언가를 찾아야 한다
  - 시스템을 정의하는 중요한 요구 사항을 찾아라
  - 의문이 드는 부분이나 가장 위험이 커 보이는 곳을 찾아라
  - 이런 부분의 코드를 먼저 작성하도록 우선 순위를 정하라
> Tip 20: 목표물을 찾기 위해 예광탄을 써라

- 예광탄 코드 접근 방법의 장점
  - 사용자가 뭔가 작동하는 것을 일찍부터 보게 된다
  - 개발자가 들어가서 일할 수 있는 구조를 얻는다
  - 통합 작업을 수행할 기반이 생긴다
  - 보여줄 것이 생긴다
  - 진행 상황에 대해 더 정확하게 감을 잡을 수 있다

### 예광탄이 언제나 목표물을 맞히는 것은 아니다
- 예광탄이 목표물에 맞을 때까지 조준을 옮겨야 한다
- 예광탄 코드도 요구사항에 맞출때 까지 수정해 나가야 한다

### 예광탄 코드 vs 프로토타이핑
- 프로토타입은 최종 시스템의 어떤 특정한 측면을 탐사해보는 것이 목표이다
  - 프로토타입은 목적을 달성하고 모두 버린다
- 예광탄 코드 접근 방법은 프로토타입과 다르다
  - 애플리케이션이 전체적으로 어떻게 연결되는 지
  - 사용자에게 실제 애플리케이션 요소들어 어떻게 상호작용 하는 지
  - 개발자에게 코드를 붙일 아키텍처 골격을 제시하고 싶을 때
- 프로토타입은 예광탄을 발사하기 전에 먼저 수행하는 정찰이나 정보 수집 같은 것이다.

## 프로토타입과 포스트잇
다양한 산업 분야에서 구체적인 아이디어를 실험해 보기 위해 프로토타입을 사용한다. 프로토타입이 실제 제품보다 저렴하기 때문이다. 소프트웨어 프로토타입도 같은 이유에서 같은 방식으로 만든다. 프로토타입을 반드시 코드로 작성할 필요는 없다. 포스트잇이나 화이트보드를 활용할 수 있다. 세부 사항을 포기할 수 없는 환경이라면 프로토타입을 만들고 있는게 맞는지 자문해볼 필요가 있다. 이때는 예광탄 방식의 개발이 더 적절할 수 있다.

### 프로토타이핑 대상
- 위험을 수반하는 모든 것이 프로토타이핑의 대상이 될 수 있다
- 해 본적이 없는 것, 증명되지 않았거나 실험적인 것 등 모든 것이 대상이 될 수 있다
  - 아키텍처
  - 새로운 기능
  - 외부에서 가져온 도구나 컴포넌트
  - 성능 문제
  - 사용자 인터페이스 설계
> Tip 21: 프로토타이핑으로 학습하라

### 프로토타입을 어떻게 사용할 것인가?
- 프로토타입을 만들 때 무시해도 좋을 세부 사항
  - 정확성
  - 완전성
  - 안정성
  - 스타일
- 프로토타입은 파이썬이나 루비 같은 고수준 스크립트언어를 사용해도된다.
  - 어차피 프로토타입은 버릴 것이기 떄문이다

### 아키텍처 프로토타이핑
- 프로토타이핑의 목적은 전체적으로 시스템이 어떻게 동작할지에 대해 감을 잡는 것이다
- 다음은 프로토타이핑에서 규명할 만한 사항이다
  - 주요 영역의 책임이 잘 정의되었고 적절한가?
  - 주요 컴포넌트 간의 협력 관계가 잘 정의되었는가?
  - 결합도는 최소화했는가?
  - 중복이 발생할 만한 곳이 있는가?
  - 정의된 인터페이스와 제약 사항은 수용할 만한가?
  - 각 모듈이 싱핼 중에 필요한 데이터에 접근할 수 있는 경로를 갖고 있는가? 모듈에 데이터가 필요한 시점에 데이터 접근이 가능한가?

### 프로토타입 코드를 사용하지 않도록 하려면?
- 프로토타입 코드를 폐기할 것이고, 불완전하며, 완성할 수 없다는 사실을 분명히 주지시켜야 한다

## 도메인 언어
> 언어의 한계가 곧 자기 세계의 한계다. - 루트비히 비트겐슈타인

모든 언어는 제각기 일련의 특징들을 내세운다. 이러한 특징들은 어떠한 해결방안을 제시하기도 하지만, 가려버리기도 한다. 문제 도메인의 언어가 어떤 프로그래밍 해결 방안을 제안하기도 하는데, 이는 어쩌면 프로그래밍 언어의 사고방식보다 더 중요하다.

### 도메인 언어의 특성
- 도메인 언어는 내부 도메인 언어와 외부 도메인 언어로 나눌 수 있다
- 본인이 실행하는 코드 안으로 들어가는 도메인 언어를 내부 도메인 언어라고 한다
  - 도메인 언어가 원래 코드의 어휘를 진짜로 확장시키는 것이다
- 외부 도메인언어는 별도의 코드가 이 언어를 읽어 들여 사용할 수 있는 형태로 만든것을 의미한다

### 내부와 외부 언어의 장단점
- 내부 언어
  - 호스트 언어의 기능을 사용할 수 있다
  - 호스트 언어의 문법과 의미론을 따라가야 한다
- 외부 언어
  - 내부 언어가 호스트 언어로 인해 받는 제약이 없다
  - 프로젝트에서 도메인 언어를 만드는데 어느 정도 추가 비용이 발생한다
- 기본적으로는 YAML, JSON, CSV 같은 널리 통용되는 외부 언어를 사용하라
- 그게 아니라면 내부 언어를 고려하라
- 단, 외부 언어 도입은 애플리케이션의 사용자가 직접 도메인 언어로 코드를 작성하는 경우에만 추천한다