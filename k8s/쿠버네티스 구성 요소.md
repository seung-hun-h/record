![image](https://user-images.githubusercontent.com/60502370/234229730-2515d4e6-1213-4eba-bab9-57ac872e54f2.png)

## 마스터 노드
- 쿠버네티스 클러스터의 제어를 담당
- 클러스터 전반의 작업을 관리하고 각 노드에서 실행 중인 파드의 상태를 모니터링하여 필요한 작업을 수행한다

#### kubctl
- 쿠버네티스 클러스터에 명령을 내리는 역할
- 바이너리로 배포되어 마스터 노드에 있을 필요는 없다
- API 서버와 주로 통신한다

#### API 서버
- 쿠버네티스 클러스터의 중심 역할을 하는 통로
- 주로 상태 값을 저장하는 etcd와 통신

#### etcd
- 구성 요소들의 상태 값이 저장되는 곳
- 분산 데이터베이스
- etcd 외 다른 구성 요소는 상태 값을 저장하지 않는다

#### 컨트롤러 매니저
- 쿠버네티스 클러스터 오브젝트의 상태를 관리
- 컨트롤러 매니저는 노드 컨트롤러, 레플리카셋 컨트롤러, 엔드 포인트 컨트롤러 등이 있다
- 워커 노드와 통신이 되지 않는 경우 상태 체크와 복구는 노드 컨트롤러에서 한다
- 레플리카셋 컨트롤러는 요청받은 파드 개수대로 파드를 생성한다
- 엔드 포인트 컨트롤러는 서비스와 파드를 연결하는 역할을 한다

#### 스케줄러
- 파드를 어떤 워커 노드에 생성할 것인지 결정하고 할당한다
- 노트의 상태, 자원, 레이블, 요구 조건등을 고려한다

## 워커 노드
- 마스터 노드에서 전달 받은 작업을 실행
- 마스터 노드에서 전달 받은 파드를 실행하고, 상태 정보를 마스터 노드에 보내며, 마스터 노드와 통신하여 클러스터 전반의 작업을 수행한다

#### kubelet
- 파드의 구성 내용(PodSpec)을 받아서 컨테이너 런타임으로 전달하고, 파드 안의 컨테이너들이 정상적으로 작동하는지 모니터링 한다

#### 컨테이너 런타임(CRI)
- 파드를 이루는 컨테이너를 실행을 담당한다
- 파드 내부 다양한 종류의 컨테이너가 문제없이 작동되도록하는 표준 인터페이스이다

#### 파드
- 한 개 이상의 컨테이너로 단일 목적의 일을 하기 위해서 모인 단위
- 언제라도 죽을 수 있는 존재

#### kube-proxy
- 쿠버네티스 클러스터에서 서비스의 가상 IP 주소를 유지하고, 로드 밸런싱을 수행
- 네트워크 프록시로써 동작
- 노드의 iptables 룰을 수정하여 가상 IP 주소와 포트 번호를 실제 서비스 엔드 포인트에 매핑한다
	- 파드를 외부에 노출시키기 위함

##### iptables
- 리눅스 운영체제에서 사용하는 방화벽 프로그램
- 패킷 필터링 및 NAT(Network Address Translation) 기능을 수행하여 네트워크 보안을 강화하고, 네트워크 트래픽의 흐름을 제어한다
- IP 주소, 포트, 프로토콜 등 정보를 기반으로 패킷을 필터링한다
	- 특정 IP 주소에서 들어오는 패킷을 차단할 수 있다
	- 개인 네트워크의 IP 주소를 공인 IP 주소로 변환할 수 있다
- kube-proxy가 iptables를 사용하여 가상 IP 주소와 포트 번호를 실제 서비스 엔드포인트 IP 주소와 포트 번호를 매핑하는데 사용된다


## 부가 요소
#### 네트워크 플러그인
- 쿠버네티스 클러스터와 통신을 하기 위해서는 네트워크 플러그인을 설치해야 한다
- 네트워크 플러그인은 일반적으로 CNI로 구성된다

#### 컨테이너 네트워크 인터페이스(CNI)
- 컨테이너 네트워크 안정성과 확장성을 보장하기 위해 개발되었다
- 컨테이너 간 통신과 호스트와 컨테이너 간 통신을 관리하는 인터페이스
- 캘리코, 플래널, 실리움, 큐브 라우터 등등이 존재한다

#### CoreDNS
- 빠르고 유연한 DNS 서버
- 쿠버네티스 클러스터에서 도메인 이름을 이용해 통신하는데 사용

# 파드의 생명주기로 구성 요소 확인하기
![image](https://user-images.githubusercontent.com/60502370/234240799-0794106d-7b02-4374-bc1f-1d11379f4025.png)

1. kubectl를 통해 API 서버에 파드 생성을 요청한다
2. API 서버에 전달된 대용이 있으면 etc에 전달된 내용을 모두 기록하여 클러스터의 정보를 최신으로 유지한다. 
3. API 서버에 파드 생성이 요청된 것을 인지하면 컨트롤러 매니저는 파드를 생성하고, 이 상태를 API 서버에 전달한다. 아직 어떤 워커 노드에 파드를 적용할지는 결정되지 않은 상태다
4. API 서버에 파드가 생성됐다는 정보를 스케줄러가 인지한다. 파드를 생성할 워커 노드를 결정하고 파드를 띄우도록 요청한다
5. API 서버에서 전달된 정보를 토대로 지정한 워커 노드에 파드가 속해있는지 스케줄러가 kublete으로 확인한다
6. kubelet에서 컨테이너 런타임으로 파드 생성을 요청한다
7. 파드가 생성된다
8. 파드가 사용가능한 상태가 된다

- 쿠버네티스는 **선언적인(declarative)** 시스템 구조를 가지고있다
	- 각 요소가 **추구하는 상태(desired status)** 를 선언하면 **현재 상태(current status)** 와 맞는지 점검하고 그것에 맞추려고 노력하는 구조로 되어있다
	- 추구하는 상태를 API 서버에 전달하면 각 요소가 API 서버에 접근하여 현재 상태와 비교해 그에 맞게 상태를 변경한다
- 워커 노드는 워크플로 구조에 따라 설계됐다
	- kubelet과 컨테이너 런타임을 통해 파드를 새로 생성하고 제거해야하는 구조여서 선언적인 방식으로 구조화하기 어려움이 있기 때문이다
	- 파드의 배포, 업그레이드, 롤백 등의 작업은 워크플로 기반으로 수행된다.
	- 자원의 동적인 할당과 해제가 빈번하게 발생해 워크플로 기반의 동적인 시스템 구조가 더욱 유리하다