# 트랜잭션

## 트랜잭션이란?
트랜잭션은 작업의 완전성을 보장해주는 것이다. 즉 논리적인 작업 셋을 모두 완벽하게 처리하거나, 처리하지 못할 경우에는 원 상태로 복구해서 작업의 일부만 적용되는 현상이 발생되지 않게 만들어주는 기능이다.

### 트랜잭션의 상태
- Active: 트랜잭션이 활성화된 상태
- Failed: 트랜잭션 실패 상태
- Partially committed: 트랜잭션의 COMMIT 명령이 도착한 상태. COMMIT 이전 SQL문이 수행되고 COMMIT만 남은 상태
- Aborted: 트랜잭션 취소 상태
- Commited: 트랜잭션 완료 상태

### 트랜잭션과 잠금(Lock)
잠금과 트랜잭션은 비슷한 기능처럼 보이지만 잠금은 동시성 제어를 위한 기능이고 트랜잭션은 데이터의 정합성을 보장하기 위한 기능이다. 하나의 회원정보를 여러 커넥션에서 동시에 변경하려고 하는데 잠금이 없다면 하나의 데이터를 여러 커넥션에서 동시에 변경할 수 있게된다. 결과적으로 해당 레코드의 값은 예측할 수 없는 상태가 된다. **잠금**은 여러 커넥션에서 동시에 동일한 자원을 요청할 경우 **순서대로 한 시점에는 하나의 커넥션만 변경**할 수 있게 해주는 역할을 한다. 격리 수준이라는 것은 하나의 트랜잭션 내에서 또는 여러 트랜잭션 간의 작업 내용을 어떻게 공우하고 차단할 것인지를 결정하는 레벨을 의미한다.

### 트랜잭션의 특성
트랜잭션은 ACID라는 네 가지 특성을 만족한다

- 원자성(Atomicity): 트랜잭션 중간에 문제가 발생하면 원 상태로 복구되고, 아무런 문제 없이 모든 작업이 수행될 때만 수행 결과를 반영한다
- 일관성(Consistency): 트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나거 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.
- 고립성(Isolation): 각각의 트랜잭션은 서로의 간섭없이 독립적으로 수행해야한다.
- 지속성(Durability): 트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.

## 트랜잭션 격리 수준
여러 트랜잭션이 동시에 추리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지를 결정하는 것이다.

- READ UNCOMMITED
- READ COMMITED
- REPEATABLE READ
- SERIALIZABLE

데이터베이스의 격리 수준을 이야기하면 항상 언급되는 세 가지 부정합 문제점이있다. 이 세 가지 부정합 문제는 격리 수준에 따라 발생할 수도 있고 발생하지 않을 수 도있다.
- DIRTY READ
- NON-REPEATABLE READ
- PHANTOM READ

<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/149607796-3c2b7fed-efba-46af-b79d-ab926ba6f2fa.png width=700>
</p>

### READ UNCOMMITED
각 트랜잭션에서의 변경 내용이 COMMIT이나 ROLLBACK 여부와 상관없이 다른 트랜잭션에서 보인다.

<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/149607835-f4e51581-016d-48d1-aa53-2232af78b6cb.png width=700>
</p>

위 그림에서 사용자A가 (emp_no, first_name)이 (50000, Lara)인 데이터를 INSERT 하고 아직 COMMIT 하지 않는 상태에서 사용자B가 emp_no=50000인 데이터를 읽었다. 사용자A의 작업이 COMMIT 된다면 문제가 발생하지 않겠지만 만약 어떠한 이유로 ROLLBACK 되더라도 사용자B는 작업을 계속 수행할 것이다.

이처럼 어떤 트랜잭션에서 처리하는 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있는 현상을 더티 리드(Dirty Read)라 한다.

### READ COMMITED
READ COMMITED는 오라클 DBMS에서 가장 기본으로 사용되는 격리 수준이며, 온라인 서비스에서 가장 많이 선택되는 격리 수준이다. 더티 리드 현상은 발생하지 않는다. 어떤 트랜잭션이 데이터를 변경했더라도 COMMIT이 완료된 이후에 다른 트랜잭션에서 조회할 수 있기 때문이다.

<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/149607999-81a10093-fa2c-46cb-905f-bab9db5a561c.png width=700>
</p>

사용자A가 Lara의 이름을 Toto로 변경했는데 이때 새로운 값인 Toto는 employees 테이블에 즉시 기록되고 이전 값인 Lara는 언두 영역으로 백업된다. 따라서 사용자B가 조회하는 first_name의 컬럼 값은 Lara로 조회된다. 최종적으로 사용자A가 변경된 내용을 COMMIT하면 그때부터는 다른 트랜잭션에서도 백업된 언두 레코드가 아니라 새롭게 변경된 Toto라는 값을 참조할 수 있다.

READ COMMITED 격리 수준에서는 NON-REPEATABLE READ라는 부정합 문제가 있다.

<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/149608141-2acf3378-7f60-4642-9271-e0e9e3a6a1d5.png width=700>
</p>

처음 사용자B가 트랜잭션을 시작하고 first_name이 Toto인 사용자를 검색했는데, 일치하는 결과가 없다. 하지만 사용자 A가 emp_no=500000인 사원의 이름을 Toto로 변경하고 커밋한 후, 사용자 B가 다시 똑같은 SELECT 쿼리로 조회하면 이번에는 결과가 1건 조회된다. 별다른 문제가 없어 보이지만, 사용자 B가 하나의 트랜잭션 내에서 똑같은 SELECT 쿼리를 실행했을 때 항상 같은 결과를 가져와야 한다는 REPEATABLE READ 정합성에 어긋나는 것이다.

일반적인 웹 프로그램에서는 문제가 되지 않을 수 있지만 동일 데이터를 여러번 읽고 변경하는 작업이 금전적인 처리와 연결되면 문제가 될 수 있다. 다른 트랜잭션에서 입금과 출금 처리가 계속 진행될 때 다른 트랜잭션에서 오늘 입금된 총액을 조회한다고 가정하면, REPEATABLE READ가 보장되지 않기 때문에 총합을 계산하는 SELECT 쿼리가 실행될 때마다 다른 결과를 가져올 것이다.

### REPEATABLE READ
MySQL InnoDB 스토리지 엔진에서 기본으로 사용되는 격리수준이다. 이 격리 수준에서는 READ COMMITED 수준에서 발생하는 REPEATABLE READ 부정합이 발생하지 않는다. REPEATABLE READ 격리 수준에서는 트랜잭션이 ROLLBACK 될 것을 대비해 변경되기 전에 레코드를 언두 공간에 백업 해두고 실제 레코드 값을 변경한다. 언두 영역에 저장된 이전 레코드를 통해 동일 트랜잭션에서 동일한 결과를 보여줄 수 있는 것이다. READ COMMITED 수준도 동일한 원리로 COMMIT 전에 동일한 데이터를 보여주지만, 둘의 차이점은 언두 영역에 백업된 레코드의 여러 버전 가운데 몇 번째 이전 버전까지 찾아 들어가야 하느냐에 있다.

모든 InnoDB 트랜잭션은 고유한 트랜잭션 번호를 가지며, 언두 영역에 백업된 모든 레코드에는 변경을 발생시킨 트랜잭션의 번호가 있다. 그리고 언두 영역에 백업된 데이터들은 엔진이 불필요하다고 판단하면 주기적으로 삭제된다. REPEATABLE READ 격리 수준에서는 가장 오래된 트랜잭션 번호보다 앞선 데이터는 삭제할 수 없다.

<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/149608621-5984f86e-76f4-4c5e-a52d-b7ccf2dfdba6.png width=700>
</p>

사용자 B가 트랜잭션을 시작하고 트랜잭션 번호는 10번을 부여받았다. 이제 사용자B의 쿼리는 자신의 트랜잭션 번호 10보다 작은 트랜잭션 번호를 가진 데이터를 조회한다.

그림에서 사용자 A가 사원 번호 500000인 Lara의 이름을 Toto로 변경했다 하더라도 사용자 B의 트랜잭션 번호 보다 크기 때문에 사용자 B가 다시 같은 사원 번호로 조회하더라도 언두 영역에 저장되어 있는 데이터를 가져온다.

<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/149608827-6a0d20b5-8a70-4e3c-8595-9589e47bd647.png width=700>
</p>

REPEATABLE READ에서도 부정합 문제가 발생할 수 있다. 그림처럼 사용자 B가 SELECT... FOR UPDATE 쿼리를 실행하더라도 결과가 달라질 수 있다. 이렇게 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다 안 보였다 하는 현상을 PHANTOM READ라 한다. 이는 SELECT... FOR UPDATE 쿼리 수행시 쓰기 잠금을 걸어야 하는데 언두 로그에는 잠금을 걸 수 없기 때문이다. 그래서 SELECT... FOR UPDATE 쿼리는 현재 레코드의 값을 가져오게된다.

### SERIALIZABLE
가장 단순한 격리 수준이면서 동시에 가장 엄격한 격리수준이다. 그만큼 동시 처리 성능도 다른 트랜잭션 격리 수준보다 떨어진다. 격리 수준이 SERIALIZABLE로 설정되면 단순한 읽기 작업도 공유 잠금을 획득해야만 하며, 동시에 다른 트랜잭션은 그러한 레코드를 변경하지 못하게 된다. 따라서 일반적인 DBMS에서 발생하는 PHANTOM READ 문제가 발생하지 않는다. 하지만 MySQL InnoDB에서는 갭 락과 넥스트 키락 덕분에 REPEATABLE READ가 발생하지 않기 때문에 굳이 사용할 필요가 없다.