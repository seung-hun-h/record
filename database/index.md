# 인덱스

## 디스크 읽기 방식

### HDD VS SSD
- HDD는 플레이트를 회전하며 데이터를 읽는 반면, SSD는 플래시 메모리로 되어있어 원판을 기계적으로 회전할 필요가 없다
- 순차I/O와 랜덤 I/O 모두 HDD에 비해서 SSD가 성능이 우수하다
- 순차I/O에서는 그 차이가 크지 않을 수 있지만 데이터베이스 서버에서는 랜덤I/O의 비중이 훨씬 크다


### 랜덤I/O VS 순차I/O

<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/149604393-dd5cd21d-c0e1-440b-9a65-1c6ae4e1383b.png width=300>
</p>

- 순차I/O는 3개의 페이지를 디스크에 기록하기 위해 1번의 시스템 콜을 요청했고, 랜덤I/O는 3번의 시스템 콜을 요청했다
  - 즉 디스크 헤더를 순차I/O는 한번, 랜덤I/O는 세번 움직인 것이다.
- 디스크의 성능은 헤더가 몇번 움직이냐에 따라 결정되므로 랜덤I/O의 부하가 훨씬 크다
- SSD에서도 순차I/O 보다 랜덤I/O의 부하가 훨씬 크다
- 일반적으로 쿼리를 튜닝한다는 것은 랜덤I/O 자체를 줄여주는 것이 목적이다.
  - 꼭 필요한 데이터만 읽도록 쿼리를 개선하는 것
- 데이터웨어하우스나 통계 작업에서는 인덱스를 사용하지 않고 풀 테이블 스캔하도록 유도하기도 한다.

## 인덱스란?

테이블의 특정 컬럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍(key-value)으로 삼아 별도로 정렬하여 저장한 자료구조이다. 테이블의 모든 데이터를 검색하면 시간이 오래걸리기 때문에 사용한다.

인덱스는 항상 정렬된 상태를 유지하기 때문에 값을 탐색하는 작업은 빠르지만 값을 삭제하거나 수정하는 작업은 느리다. 결론적으로 인덱스는 데이터의 저장 성능을 희생하고 대신 데이터의 검색 속도를 높인 것이다.

### 인덱스 알고리즘

**B-Tree 알고리즘**

인덱스의 컬럼 값을 변형하지 않고 원래 값을 이용해 인덱싱하는 알고리즘이다. MySQL 서버에서는 위치 기반 검색을 위한 R-Tree 인덱스 알고리즘도 있지만, R-Tree 인덱스도 B-Tree의 응용 알고리즘이다.

**Hash 인덱스 알고리즘**

컬럼의 값으로 해시값을 계산해서 인덱싱하는 알고리즘으로, 매우 빠른 검색을 지원한다. 하지만 값을 변형해서 인덱싱하므로 값의 일부만 검색하거나 범위를 검색할 때는 해시 인덱스를 사용할 수 없다. Hash 인덱스는 주로 메모리 기반의 데이터베이스에서 많이 사용한다

**Hash가 아닌 B-Tree를 사용하는 이유**

SELECT 질의에는 부등호 연산도 포함된다. Hash 알고리즘의 경우 등호 연산만 가능하기 때문에 부등호 연산의 경우 문제가 발생한다.

