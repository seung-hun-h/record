# Microservice와 Spring cloud 소개
## Miscoservice란?
### The History of IT System
- 1960 - 1980s: Fragile, Cowboys
  - Mainframe, Hardware
  - 하드웨어의 비용이 커서 하드웨어 중심으로 소프트웨어의 아키텍처가 형성되었다 
- 1990 - 2000s: Robust, Distributed
  - Changes
- 2010s ~: Resilient/Anti-Fragile, Cloud Native
  - Flow of Value의 지속적인 개선
  - Clound Native란 클라우드에서 빌드되고 클라우드 컴퓨팅 모델을 최대한 활용하는 접근방식이다.

### Antifragile
- Auto Scailing
  - 최소한의 서버 인스턴스를 확보하고, 리소스 요구에 따라 동적으로 스케일 아웃을 한다
- Microservices
  - 하나의 서비스를 구성하는 수많은 독립적인 서비스를 운영하는 접근방식
- Chaos engineering
  - 서비스의 각종 장애 조건을 견딜 수 있는 시스템의 신뢰성을 확보하기 위해 분산 시스템을 실험하고 배우는 분야
  - 시스템에 내재된 혼란을 관리함으로서 유연성과 속도를 증가시키고, 복잡성이 존재하고 있더라도 프로덕션 배포에 신뢰를 가질 수 있도록 함
- Continous deployments

## Cloud Native Architecture
- 클라우드 네이티브 아키텍처 및 기술은 클라우드에서 빌드되고 클라우드 컴퓨팅 모델을 최대한 활용하는 워크로드를 디자인, 생성, 운영하는 접근 방식이다.
- 클라우드 네이티브는 속도와 민첩성에 관한 것이다
  - 비즈니스가 성장하고 시장에 민첩하게 대응하면서 비즈니스 시스템은 진화한다
  - 비즈니스 시스템이 진화하면서 더욱더 복잡해진다
  - 더이상 성능 문제나 반복적으로 발생하는 에러, 느린 변화는 용납되지 않는다

### 특징
- 확장 가능한 아키텍처
  - 시스템의 수평적 확장에 유연
  - 확장된 서버로 시스템의 부하 분산, 가용성 보장
  - 시스템 또는 서비스 애플리케이션 단위의 패키지
  - 모니터링
- 탄력적 아키텍처
  - 서비스 생성-통합-배포, 비즈니스 환경 변화에 대응 시간 단축
  - 분할된 서비스 구조
  - 무상태 통신 프로토콜
  - 서비스의 추가와 삭제 자동으로 감지
  - 변경된 서비스 요청에 따라 사용자 요청 처리
- 장애 격리
  - 특정 서비스에 오류가 발생해도 다른 서비스에 영향 주지 않음

## 클라우드 네이티브의 핵심 요소

![image](https://user-images.githubusercontent.com/60502370/179396077-7fe9648f-a26f-46f2-9ea3-85416646f557.png)

### Modern Design - 12factors
1. Code base
   - 자페 리포지토리에 저장된 각 마이크로 서비스에 대한 단일 코드 베이스
   - 버전 제어를 사용하여 추적하면 여러 환경에 배포할 수 있다
2. Dependencies
   - 각 마이크로서비스는 자체 종속성을 격리하고 패키징하여 전체 시스템에 영향을 주지 않고 변경 내용을 수용한다
3. Configurations
   - 구성 정보는 마이크로서비스에서 이동되고 코드 외부의 구성 관리 도구를 통해 외부화된다
   - 동일한 배포가 올바른 구성이 적용된 호나경에서 전파할 수 있다
4. Backing Services
   - 보조 리소스는 주소 지정 가능한 URL을 통해 노출되어야 한다.
   - 이렇게하면 리소스를 애플리케이션에서 분리하여 교환할 수 있다
5. Build, Release, Run
   - 각 릴리즈는 빌드, 릴리즈, 실행 스테이지마다 엄격히 구분되어야 한다
   - 각각은 고우햔 ID로 태그를 지정하고 롤백 기능을 지원해야 한다
6. Processes
   - 각 마이크로서비스는 실행 중인 다른 서비스와 격리된 자체 프로세스에서 실행되어야 한다
   - 분산 캐시 또는 데이터 저장소와 같은 지원 서비스에 필요한 상태를 외부화 한다
7. Port Binding
   - 각 마이크로서비스는 자체 포트에 노출되는 인터페이스 및 기능으로 자체 포함되어야 한다
   - 이렇게하면 다른 서비스에서 격리된다
8. Concurrency
   - 용량을 늘려야 하는 경우 수평적 확장한다
9.  Disposability
    - 서비스 인스턴스는 삭제 가능해야 한다
10. Dev/Prod Parity
    - 애플리케이션 수명 주기에서 환경을 가능한 한 비슷하게 유지하여 비용이 많이 드는 바로가기를 방지한다
11. Logging
    - 마이크로서비스에서 생성된 로그를 이벤트 스트림으로 처리한다
12. Admin Processes
    - 일회성 프로세스로 데이터 정리 또는 컴퓨팅 분석과 같은 관리/관리 작업을 실행한다.

### Modern Design - 12 + 3factors
13. API First
    - 모든 것을 서비스로 만든다
14. Telemetry
    - 워크스테이션에서는 애플리케이션 및 해당 동작을 자세히 볼 수 있다
    - 클라우드에서는 그렇지 않고, 디자인에 모니터링, 도메인별 및 상태/시스템 데이터 컬렉션이 포함되어 있는지 확인한다
15. Authentication/Authorization
    - 처음부터 ID를 구현한다
    - 공용 클라우드에서 사용할 수 있는 RBAC(역할 기반 액세스 제어) 기능을 고려한다

### Microservices
- 클라우드 네이티브 시스템의 가장 유명한 아키텍처 스타일이다
- shared fabric을 통해 상호 작용하는 소규모 독립 서비스의 분산 집합이다
  - 각각은 더 큰 도메인 컨텍스트 내에서 특정 비스니스 기능을 구현한다
  - 각각은 자율적으로 개발되며 독립적으로 배포할 수 있다
  - 각각은 자체 데이터 스토리지 기술, 종속성 및 프로그래밍 플랫폼을 캡슐화한다
  - 각 프로세스는 자체 프로세스에서 실행되며 HTTP/HTTPS, gRPC, WebSockets 또는 AMQP와 같은 표준 통신 프로토콜을 사용하여 다른 사용자들과 통신한다

**Monolithic VS MSA**

![image](https://user-images.githubusercontent.com/60502370/179397415-289a2767-41ac-46e2-a831-150656c4f600.png)

- MSA 사용 이유
  - 각 마이크로서비스는 자율 수명주기가 있으며 독립적으로 발전하고 자주 배포할 수 있다
    - 새 기능을 배포하거나 업데이트하기 위해 분기별 릴리스를 기다릴 필요가 없다
    - 애플리케이션을 완전히 다시 배포하지 않고도 업데이트를 수행할 수 있다
  - 각 마이크로서비스는 독립적으로 확장할 수 있다
    - 더 많은 처리 능력이 필요한 서비스만 확장할 수 있다

- MSA 문제
  - 통신
  - 복원력
  - 분산 데이터
  - 보안