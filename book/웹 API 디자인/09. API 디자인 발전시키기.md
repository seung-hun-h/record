- 브레이킹 체인지(Breaking Change)는 사용자들이 API를 사용할 수 없는 변화를 말한다
- 브레이킹 체인지는 피하거나 변경점을 서로 인지하는 것이 좋다

## 1. API 진화 디자인
- 브레이킹 체인지 유발 요소
	- 데이터 구조 변화: 일반 값에서 오브젝트로의 변화
	- 값의 종류나 범위 변화
	- 포착하기 어려운 오류

### 출력 데이터의 브레이킹 체인지 피하기
- 출력 데이터의 브레이킹 체인지 결과

| 변경                                              | 결과                                                             |
| ------------------------------------------------- | ---------------------------------------------------------------- |
| 속성 이름 변경                                    | 구현에 따라 다름(UI에서 데이터가 사라짐, 데이터 오염, 충돌 등등) |
| 속성의 위치 이동                                  | 구현에 따라 다름(UI에서 데이터가 사라짐, 데이터 오염, 충돌 등등) |
| 필수 속성의 제거                                  | 구현에 따라 다름(UI에서 데이터가 사라짐, 데이터 오염, 충돌 등등) |
| 필수 속성에서 선택 사항으로 변경                  | 구현에 따라 다름(UI에서 데이터가 사라짐, 데이터 오염, 충돌 등등) |
| 속성의 타입 변경                                  | 파싱 에러                                                        |
| 속성의 포맷 변경                                  | 파싱 에러                                                        |
| 속성의 특징 변경(길이, 범위, 배열의 길이 확장 등) | 구현에 따라 다름(UI에서 데이터가 사라짐, 데이터 오염, 충돌 등등) |
| 속성의 의미 변경                                  | 최악의 결과                                                      |
| enum 값 추가                                      | 구현에 따라 다름(UI에서 데이터가 사라짐, 데이터 오염, 충돌 등등) |

- 안전한 출력 데이터의 변경
	- 새로운 속성을 추가하는 것이 제일 단순하고 안전하다
	- 완전히 새로운 속성을 추가하는 것은 간단하지만, 기존 속성 값을 조금씩 바꾸는 것은 API에 중복되는 데이터를 만들어 이해하기 힘들고 어색한 형태가 될 수 있다

### 입력 데이터와 파라미터에서 브레이킹 체인지 피하기
- 입력 데이터와 파라미터에서 브레이킹 체인지 결과
  
| 변경                           | 결과                           |
| ------------------------------ | ------------------------------ |
| 속성 이름 변경                 | API 에러                       |
| 속성 위치 이동                 | API 에러                       |
| 필수 속성 제거                 | API 에러                       |
| 선택 사항을 필수 사항으로 변경 | API 에러                       |
| 속성 타입 변경                 | API 에러                       |
| 속성 포맷 변경                 | API 에러                       |
| 속성 특징 변경                 | API 에러                       |
| 속성 의미 변경                 | 최악의 경우(프로바이더에 영향) |
| enum 값 제거                   | API 에러                       |
| 필수 속성 추가                 | API 에러                       |

- 안전한 입력 데이터와 파라미터의 변경
	- 속성을 추가하는 것이 안전하다. 추가된 속성이 오브젝트라면 내부 속성이 필수 값인지는 중요하지 않다
	- 필수 속성을 선택으로 변경하거나 속성의 범위를 늘리는 것은 비교적 안전하다

### 성공, 에러 피드백에서 브레이킹 체인지 피하기
- 성공, 에러 피드백의 속성 이름 변경은 광범위한 브레이킹 체인지를 유발할 수 있다
	- `errors`를 `items`로 변경하면 모든 목표에 영향을 줄 수 있다
- HTTP 상태 코드도 브레이킹 체인지를 유발할 수 있다
	- 컨슈머는 알 수 없는 상태 코드를 반환 받더라도 `X00`이라는 상태 코드와 동일하게 취급할 수 있도록 해야 한다
	- 단, 컨슈머의 코드를 눈으로 직접 확인하지 않는 이상 컨슈머가 잘 처리했을 것이라고 믿지 말라

> 명시적인 상태코드가 존재할지라도, HTTP 클라이언트는 모든 상태 코드를 알 필요가 없다. 하지만 클라이언트는 반드시 그 상태 코드의 첫 글자를 이용해서 클래스를 알아야하며, 이를 통해 식별되지 않은 상태 코드라도 X00이라는 상태 코드와 동일하게 취급해야 한다. - RFC 7231

### 목표와 흐름에서 브레이킹 체인지 회피하기
- 목표의 이름을 변경할 때
	- `/transfers`를 `/money-transfers`로 변경하면 기존 명칭을 사용하던 컨슈머들은 `404 Not Found` 응답을 받게 된다
	- 이때 `301 Moved Permanantly`를 사용해 `/transfers`의 요청을 모두 `/money-transfers`로 리다이렉션할 수도 있다
- 목표를 제거할 때
	- 기존의 GET 메서드를 제거하면, 컨슈머가 해당 리소스르 사용하려 할 때 `405 Method Not Allowed` 응답을 받게 된다
- 목표를 추가할 때
	- 기존의 목표에서 새로운 검증 목표를 추가하는 경우, 새로운 검증 목표를 호출하지 않는 컨슈머들은 기존 목표를 사용할 수 없게된다
	- 새로운 목표를 추가하는 것은 다른 것을 망가뜨리지 않겠지만, 컨슈머가 안전하지 않은 목표를 계속 사용하게 되므로 보안상 문제가 발생할 수도 있다

### 브레이킹 체인지의 보안 취약 발생 회피하기
- 모든 API 변경은 보안을 염두해야 한다
	- 컨슈머에게 전달되선 안되는 데이터가 포함될 수 있다
- OAuth2.0 같은 토큰 기반의 인증 방식을 사용할 때 토큰에 첨부된 보안 데이터를 수정하면 구현에 심각한 문제를 초래할 수 있다

### 보이지 않는 인터페이스 컨트랙트 주의하기
- 컨슈머가 반환 데이터의 순서나 길이를 스스로 파악하고 단정하여 API를 사용할 수도 있다
- 문서화하지 않은 부분도 API를 변경할 때 신경 써야할 필요가 있다


### 브레이킹 체인지가 항상 문제는 아니다
- 컨텍스트에 따라 모든 컨슈머가 API를 사용하여 동기적으로 업데이트할 수 있다면 주요 브레이킹 체인지를 도입해도 문제가 되지 않을 수 있다

## 2. API 버전 정하기
- API 버전 관리는 API 디자인, 세부 구현, 제품 관리에 영향을 미친다
- API 버전 관리와 구현상의 버전관리는 명백히 다르다

### API 버전 관리 VS 구현 버전 관리
- API 버전은 인터페이스 컨트랙트에 영향을 주는지에 따라 바뀐다. 세부 구현 버전과 관련없다
	- 세부 구현이 어떻게 변경되는지 관련없다
	- Java 코드를 Kotlin 코드로 변경하는 것은 API 버전과 관련 없다

> 시멘틱 버저닝(Sementic Versioning)
> `메이저.마이너.패치` 형식의 버저닝 방식이다. 메이저는 브레이킹 체인지가 발생하는 경우에 올라간다. 마이너는 새로운 기능이 추가되고 하위 호환성이 유지되는 경우에 올라간다. 패치는 하위 호환이 가능한 버그 수정의 경우에 올라간다

- API는 시멘틱 버저닝이 필요하지 않다. `브레이킹.논브레이킹` 두 개의 숫자로 이루어진다
- 컨슈머 입장에서는 논브레이킹 버전도 중요하지 않다. 중요한 것은 브레이킹 버전이다
	- 새로운 버전을 출시할 때는 컨슈머에 어떤 영향을 미치는지 평가해야 한다

### 버전 표현 선택
- 경로:  `GET /v1/transfers`
- 도메인: `GET /transfers`, `Host: apiv1.bankingcompany.com`
	- 경로, 도메인 방식이 가장 선호된다
- 쿼리 파라미터:  `GET /transfers?version=1`
	- 버저닝과 기능적 요구사항으로인한 파라미터가 혼재된다
- 커스텀 헤더: `GET /transfers`, `Host: api.bankingcompany.com`, `Accept: application/vnd.bank.1+json`
	- 비표준 커스텀 헤더
- 콘텐츠 네고시에이션: `GET /transfers`, `Host: api.bankingcompany.com`, `Authorization: Bearer 4R57TD78`

### API 버저닝 세분화

| 세분화 정도   | 장점                                                                             | 단점                                                                                                  | 추천 여부                                                                     |
| ------------- | -------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------- |
| API           | 어떤 버전의 동작이나 리소스가 함께하는지 고민할 필요가 없다. 일괄적으로 변경된다 | 브레이킹 체인지를 유발한 요소가 무엇인지 알 수 없다                                                   | REST API의 기본이다                                                           |
| 리소스        | 변경에 대한 힌트를 제공한다                                                      | 어떤 버전끼리 같이 동작하는지 추측하기 어렵다                                                         | REST API에는 추천하지 않는다. 리소스가 완전히 독립적인 경우에만 사용해야 한다 |
| 목표/동작     | 어떤 목표가 변경되었는지 표시가 가능하다                                         | 어떤 버전끼리 같이 동작하는지 추측하기 어렵다                                                         | REST API에는 추천하지 않는다. 리소스가 완전히 독립적인 경우에만 사용해야 한다 |
| 데이터/메시지 | 어떤 데이터/메시지가 변경되었는지 표시가 가능하다                                | 데이터/메시지가 어떤 버전끼리 같이 동작하는지 추측이 불가능하다. HTTP에서 요청/응답 바디에만 유효하다 | REST API에는 추천하지 않는다. API 세분화 과정에서 병용할 수는 있다            |

### API 버저닝이 미치는 여향
- API가 변경되면 컨슈머 영역의 일관성에 영향을 미치고, 이로인해 새로운 버전으로 전환을 고려하지 않을 수 있다
- 컨슈머가 새로운 버전으로 전환할 수 있도록 해야 한다
	- 컨슈머가 원하는 기능을 새로운 기능에 같이 도입해 변경에 대한 불편함을 완화한다
	- 변경 사항을 신중하게 기록하여 컨슈머에게 전달한다
- 여러 버전의 API를 노출할 때는 몇 개의 버전을 언제까지 지원할 지 의사결정이 되어야 한다

## 3. API 디자인에 확장성 고려하기
- 데이터, 상호작용, 흐름, 적절한 수준의 버저닝을 통해 확장 가능한 API를 구성할 수 있다

### 확장 가능한 데이터 디자인
- 불리언은 확장성이 떨어진다
	- 문자열이나 숫자를 사용하는편이 낫다
	- 상태를 자기 설명적인 오브젝트로 만들어 코드와 사람이 이해 가능한 레이블로 만들 수 있다

```JSON
%% 새로운 속성이 추가될 때마다 사용자는 코드에 새로운 속성을 처리하도록 해야한다 %%
"executed": true,
"validated": true,
"postponed": true,
```

```JSON
%% 사용자는 새로운 속성을 추가할 필요없다 %%
"status": {
	"code": "POSTPONDED",
	"label": "postponded"
}
```

- 속성이 유사하다면 리스트로 만들어라
```JSON
"creationDate": "2023-01-01",
"executionDate": "2023-02-01",
"validationDate": "2023-03-01"
```

```JSON
"events": [
	{
		"date": "2023-01-01",
		"status": "CREATED"
	},
		{
		"date": "2023-02-01",
		"status": "EXECUTED"
	},
		{
		"date": "2023-03-01",
		"status": "VALIDATED"
	}
	
]
```

### 확장가능한 상호작용
- 의미있는 피드백을 제공하라

```JSON
{
	"errors": [
		{
			"source": "amount",
			"type": "MISSING_MANDATORY_ATTRIBUTE",
			"message": "필수값인 금액이 누락되었습니다."
		}
	]
}
```

- `type`이 포괄적일수록 에러 피드백의 확장 가능성이 커진다
- 이해할 수 없는 파라미터에 대해 에러 피드백을 줄 수 있지만, 기본 값 등을 활용해 처리할 수도 있다

- 에러, 알 수 없거나 잘못된 파라미터에 대한 처리방식과 응답을 잘 정의 해야한다
	- 컨텍스트에 따라 달라진다
	  
### 확장 가능한 흐름 디자인
- 흐름에 속한 각 목표를 어떻게 디자인하는지 그리고 흐름 그 자체는 API 확장성에 영향을 미친다
- 확장성은 API가 최초에 의도된 목저보다 더 넓은 의미의 유즈케이스에 대응할 수 있게 해주는 것이기도 하다
- 보다 범용적으로 쓸 수 있는 입력과 출력을 택하면(특히 ID를 사용하면) 이를 달성하는데 도움이된다

### 확장가능한 API 디자인하기
- API는 커질 수록 브레이킹 체인지가 발생할 확률이 높아진다
- 따라서 작은 API를 여러개 만드는 것이 좋다
	- 하지만, 연관 있는 목표 그룹을 정의하고 각 목표들이 쉽게 결합할 수 있게 하는 것은 쉽지 않다