- 브레이킹 체인지(Breaking Change)는 사용자들이 API를 사용할 수 없는 변화를 말한다
- 브레이킹 체인지는 피하거나 변경점을 서로 인지하는 것이 좋다

## 1. API 진화 디자인
- 브레이킹 체인지 유발 요소
	- 데이터 구조 변화: 일반 값에서 오브젝트로의 변화
	- 값의 종류나 범위 변화
	- 포착하기 어려운 오류

### 출력 데이터의 브레이킹 체인지 피하기
- 출력 데이터의 브레이킹 체인지 결과

| 변경                                              | 결과                                                             |
| ------------------------------------------------- | ---------------------------------------------------------------- |
| 속성 이름 변경                                    | 구현에 따라 다름(UI에서 데이터가 사라짐, 데이터 오염, 충돌 등등) |
| 속성의 위치 이동                                  | 구현에 따라 다름(UI에서 데이터가 사라짐, 데이터 오염, 충돌 등등) |
| 필수 속성의 제거                                  | 구현에 따라 다름(UI에서 데이터가 사라짐, 데이터 오염, 충돌 등등) |
| 필수 속성에서 선택 사항으로 변경                  | 구현에 따라 다름(UI에서 데이터가 사라짐, 데이터 오염, 충돌 등등) |
| 속성의 타입 변경                                  | 파싱 에러                                                        |
| 속성의 포맷 변경                                  | 파싱 에러                                                        |
| 속성의 특징 변경(길이, 범위, 배열의 길이 확장 등) | 구현에 따라 다름(UI에서 데이터가 사라짐, 데이터 오염, 충돌 등등) |
| 속성의 의미 변경                                  | 최악의 결과                                                      |
| enum 값 추가                                      | 구현에 따라 다름(UI에서 데이터가 사라짐, 데이터 오염, 충돌 등등) |

- 안전한 출력 데이터의 변경
	- 새로운 속성을 추가하는 것이 제일 단순하고 안전하다
	- 완전히 새로운 속성을 추가하는 것은 간단하지만, 기존 속성 값을 조금씩 바꾸는 것은 API에 중복되는 데이터를 만들어 이해하기 힘들고 어색한 형태가 될 수 있다

### 입력 데이터와 파라미터에서 브레이킹 체인지 피하기
- 입력 데이터와 파라미터에서 브레이킹 체인지 결과
  
| 변경                           | 결과                           |
| ------------------------------ | ------------------------------ |
| 속성 이름 변경                 | API 에러                       |
| 속성 위치 이동                 | API 에러                       |
| 필수 속성 제거                 | API 에러                       |
| 선택 사항을 필수 사항으로 변경 | API 에러                       |
| 속성 타입 변경                 | API 에러                       |
| 속성 포맷 변경                 | API 에러                       |
| 속성 특징 변경                 | API 에러                       |
| 속성 의미 변경                 | 최악의 경우(프로바이더에 영향) |
| enum 값 제거                   | API 에러                       |
| 필수 속성 추가                 | API 에러                       |

- 안전한 입력 데이터와 파라미터의 변경
	- 속성을 추가하는 것이 안전하다. 추가된 속성이 오브젝트라면 내부 속성이 필수 값인지는 중요하지 않다
	- 필수 속성을 선택으로 변경하거나 속성의 범위를 늘리는 것은 비교적 안전하다

### 성공, 에러 피드백에서 브레이킹 체인지 피하기
- 성공, 에러 피드백의 속성 이름 변경은 광범위한 브레이킹 체인지를 유발할 수 있다
	- `errors`를 `items`로 변경하면 모든 목표에 영향을 줄 수 있다
- HTTP 상태 코드도 브레이킹 체인지를 유발할 수 있다
	- 컨슈머는 알 수 없는 상태 코드를 반환 받더라도 `X00`이라는 상태 코드와 동일하게 취급할 수 있도록 해야 한다
	- 단, 컨슈머의 코드를 눈으로 직접 확인하지 않는 이상 컨슈머가 잘 처리했을 것이라고 믿지 말라

> 명시적인 상태코드가 존재할지라도, HTTP 클라이언트는 모든 상태 코드를 알 필요가 없다. 하지만 클라이언트는 반드시 그 상태 코드의 첫 글자를 이용해서 클래스를 알아야하며, 이를 통해 식별되지 않은 상태 코드라도 X00이라는 상태 코드와 동일하게 취급해야 한다. - RFC 7231

### 목표와 흐름에서 브레이킹 체인지 회피하기
- 목표의 이름을 변경할 때
	- `/transfers`를 `/money-transfers`로 변경하면 기존 명칭을 사용하던 컨슈머들은 `404 Not Found` 응답을 받게 된다
	- 이때 `301 Moved Permanantly`를 사용해 `/transfers`의 요청을 모두 `/money-transfers`로 리다이렉션할 수도 있다
- 목표를 제거할 때
	- 기존의 GET 메서드를 제거하면, 컨슈머가 해당 리소스르 사용하려 할 때 `405 Method Not Allowed` 응답을 받게 된다
- 목표를 추가할 때
	- 기존의 목표에서 새로운 검증 목표를 추가하는 경우, 새로운 검증 목표를 호출하지 않는 컨슈머들은 기존 목표를 사용할 수 없게된다
	- 새로운 목표를 추가하는 것은 다른 것을 망가뜨리지 않겠지만, 컨슈머가 안전하지 않은 목표를 계속 사용하게 되므로 보안상 문제가 발생할 수도 있다

### 브레이킹 체인지의 보안 취약 발생 회피하기
- 모든 API 변경은 보안을 염두해야 한다
	- 컨슈머에게 전달되선 안되는 데이터가 포함될 수 있다
- OAuth2.0 같은 토큰 기반의 인증 방식을 사용할 때 토큰에 첨부된 보안 데이터를 수정하면 구현에 심각한 문제를 초래할 수 있다

### 보이지 않는 인터페이스 컨트랙트 주의하기
- 컨슈머가 반환 데이터의 순서나 길이를 스스로 파악하고 단정하여 API를 사용할 수도 있다
- 문서화하지 않은 부분도 API를 변경할 때 신경 써야할 필요가 있다


### 브레이킹 체인지가 항상 문제는 아니다
- 컨텍스트에 따라 모든 컨슈머가 API를 사용하여 동기적으로 업데이트할 수 있다면 주요 브레이킹 체인지를 도입해도 문제가 되지 않을 수 있다
