- API 사용자들은 사용성을 기대한다
	- 직관적인 상호작용
	- 직관적인 흐름

## 직관적인 표현
### 명확한 이름 정하기
- 컨텍스트를 활용하여 짧고 분명한 이름을 지어야 한다
- `bkAccOverProtFtActBln`
	- 줄여쓰지 않는다: `bankAccountOverdraftProtectionFeatureActiveBln`
	- 내부 코딩 규칙을 노출하지 않는다: `bankAccountOverdraftProtectionFeatureActive`
	- 불필요한 단어를 사용하지 않는다:  `bankAccountOverdraftProtectionFeature`
	- 무의미한(유용하지 않은) 단어는 사용하지 않는다: `bankAccountOverdraftProtection`
	- 당연한 내용은 포함하지 않는다:  `overdraftProtection`

> 이름을 정할때는 세 단어에서 두 단어의 조합까지만 하기를 권장한다

### 사용하기 쉬운 데이터 타입과 포맷 정하기
- API가 사용하는 원시 데이터는 개발자들의 명확히 이해할 수 있어야 한다
- 일반적으로 숫자로 된 코드를 이용하는 것은 좋은 생각이 아니다
- 단순히 읽기만 해도 이해할 수 있는 데이터 포맷이나 타입을 사용하는 것이 좋다

### 바로 사용할 수 있는 데이터 선택하기
- 어떠한 이유로 숫자 명명법을 사용하게 됐다면 추가 정보를 제공할 수 있다
	- `type: 1(저축), 2(당좌)`인 경우 `typeName: savings, checking` 추가 정보를 제공해 이해를 돕는다
- 기본 데이터를 더 연관성이 높은 데이터로 변경할 수도 있다
	- 계좌 개설일이 아닌 계좌 개설 후 기간을 알고 싶다면 그러한 정보를 바로 제공해줄 수 도 있다
- 의미 있는 데이터를 제공하여 모든 값에 대한 사용성과 이해를 용이하게 할 수 있다

## 직관적인 상호작용
### 직관적인 사용자 입력 요청하기
- 명확한 이름
- 이해하기 쉬운 데이터 포맷
- 간단한 입력

### 발생 가능한 모든 에러 피드백 식별하기
- 규격에 맞지 않는에러
	- 컨슈머가 잘못된 데이터 포맷, 타입으로 데이터를 제공하는 경우
	- 서버가 요청을 이해할 수 없는 경우
- 기능적 에러
	- 컨슈머가 데이터를 생성하거나 수정하거나 삭제할 때나 어떠한 액션을 실행시킬 때 주로 발생
- 서버 에러
	- 데이터베이스 서버의 장애나 구현의 버그

### 유용한 에러 피드백 반환하기
- REST API는 HTTP 상태 코드를 이용하여 요청의 성공 여부를 보여준다

| 유즈 케이스           | 사용 예                                                 | HTTP 상태 코드            |
| --------------------- | ------------------------------------------------------- | ------------------------- |
| 잘못된 파라미터       | GET /accounts/123 요청에 존재하지 않는 계좌에 대한 조회 | 404 NOT FOUND             |
| 필수 속성의 누락      | amount 누락됨                                           | 400 BAD REQUEST           |
| 잘못된 데이터 타입    | "startDate": 12345                                      | 400 BAD REQUEST           |
| 기능적 에러           | 금액이 소비 한도 초과                                   | 403 FORBIDDEN             |
| 기능적 에러           | 보내는 계좌에서 받는 계좌로의 이체가 금지됨             | 403 FORBIDDEN             |
| 기능적 에러           | 지난 5분이내에 동일한 송금이 발생한 전력이 있음         | 409 CONFLICT              |
| 예견치 못한 서버 에러 | 구현에 버그가 숨겨져 있음                               | 500 INTERNAL SERVER ERROR |

- 상세한 에러 응답
```JSON
{
	"source": "amount",
	"type": "AMOUNT_OVER_SAFE",
	"message": "금액이 사용가능 금액을 초과합니다."
}
```

- 위 응답은 API 사용자와 프로그램 모두 에러를 해석할 수 있다
- 하지만 에러를 정의할 때 에러마다 특정 타입을 정의할 필요는 없다. 포괄적인 타입을 정의하는 편이 좋다

```JSON
{
	"source": "amount",
	"type": "MISSING_MANDATORY_PROPERTY",
	"message": "금액은 필수입니다."
}
```

- 가능하다면 컨슈머가 문제를 스스로 해결할 수 있도록 응답을 해야한다

### 철저한 에러 피드백 반환하기
- 에러 피드백은 가능한 철저하게 제공하는편이 좋다
- 규격에 맞지 않는 요청에러 두 개를 목록 하나에 포함해 응답해야 한다
- 여러 개의 기능적 에러도 유사하게 처리해야 한다

```JSON
{
	"message": "Invalid request",
	"errors": [
		{
			"source": "source",
			"type": "MISSING_MANDATORY_PROPERTY",
			"message": "Source is mandatory"
		},
		{
		 	"source": "destination",
			"type": "MISSING_MANDATORY_PROPERTY",
			"message": "Destination is mandatory"
		},
	]
}
```

- `400 BAD REQUEST`로 한 번에 잘못된 유형의 요청 에러와 기능적 에러에 대한 응답을 추천한다
- 하지만 만능은 아니며, 각자 처한 상황을 분석해 에러 카테고리를 나눌 지 하나로 처리할 지 고민해야 한다

### 유용한 성공 피드백 반환하기
- `200 OK`: 모든 성공에 사용할 수 있다
- `201 CREATED`: 송금에 대한 요청이 즉시 처리됨
- `202 ACCEPTED`: 예약 이체가 성공됨. 요청은 접수되었지만 수행은 아직되지 않음


## 직관적인 흐름
### 직관적인 목표 연쇄 만들기

| 누가   | 무엇을                                                | 어떻게                            | 입력(원천)                                                                                              | 출력(사용처)                         | 목표                       |
| ------ | ----------------------------------------------------- | --------------------------------- | ------------------------------------------------------------------------------------------------------- | ---------------------------- | -------------------------- |
| 컨슈머 | 계좌에서 가지고 있는 계좌나 외부 계좌로 돈을 송금한다 | 계좌 목록 조회                    |                                                                                                         | 계좌 목록(송금)                    | 계좌 목록조회              |
|        |                                                       | 기존에 등록된 받는 계좌 목록 조회 |                                                                                                         | 기존에 등록된 받는 계좌 목록(송금) | 등록된 받는 계좌 목록 조회 |
|        |                                                       | 송금                              | 보내는 계좌(계좌 목록 조회), 받는 계좌(계좌 목록 조회, 기존에 등록된 받는 계좌 목록 조회), 금액(컨슈머) | 송금 결과                    | 송금                       |
- 위 캔버스는 즉시 이체에 대해 설명한다
- 즉시 이체에 대한 흐름은 다음과 같다

<img width="609" alt="image" src="https://github.com/seung-hun-h/record/assets/60502370/52db96c1-04a8-40e3-a41f-378d33547855">

- 송금 목표를 위한 입력들은 직관적이지만, 송금은 다양한 에러를 반환할 수 있다
- 만약 `400 BAD REQUEST` 에러만 반환 받는다면 컨슈머는 성공적으로 송금할 때까지 여러번 고생해야할 수도 있다
- 간단한 API 목표의 연쇄로 가는 첫 번째 단계는 컨슈머가 제공할 수 있는 간단한 입력이나 연쇄에 포함된 다른 목표를 요청하고, 요청/에러 사이클을 제한하기 위해 완전하고 유용한 에러 피드백을 반환하는 것이다
	- 하지만 에러를 방지함으로써 더 짧고 유연하게 만들 수 있다

### 에러 방지
- 송금 목표에서 발생할 수 있는 기능적 에러
	- 금액이 사용 가능 한도를 초과하는 경우
	- 금액의 누계가 1일 송금 한도를 초과하는 경우
	- 보내는 계좌가 송금이 불가능한 계좌인 경우
	- 받는 계좌가 보내는 계좌와 동일한 경우
- 보내는 계좌가 송금이 불가능한 계좌인 경우 발생하는 에러를 예방한다
	- `forbiddenTransfer`속성을 추가한다

<img width="607" alt="image" src="https://github.com/seung-hun-h/record/assets/60502370/fa7a3038-f0d8-43b9-87ec-c7d0dba6891d">

- 송금이 가능한 계좌들만 반환하는 새로운 목표가 추가되었다
- 에러를 예방하는 것은 목표들의 흐름을 보다 유동적으로 할 수 있게 해준다. 이를 위해서는 다음과 같은 것들을 해야한다
	- 가능한 오류를 분석하여 이를 예방할 수 있는 추가 값 데이터를 결정한다
	- 기존 목표의 성공 피드백을 향상시켜 이러한 데이터를 제공한다
	- 이렇나 데이터를 제공하기 위한 새로운 목표를 수립한다

> REST 제약사항: 코드 온 디멘드
> 특정한 도움을 주려는 목적의 목표나 규칙적인 목표를 통해 적절한 데이터를 제공함으로써 일종의 'Code on demand'를 달성할 수 있다. 많은 비즈니스 규칙을 단순하거나 복잡한 데이터로 표현함으로써 컨슈머가 비즈니스 규칙을 코드처럼 사용할 수 있도록 해준다

### 목표 통합
- 받는 계좌가 계좌 목록과 받는 계좌 목록 목표 양쪽에서 등장할 수 있다는 점이 신경쓰인다
	- 컨슈머 입장에서 한 번 더 무언가를 해야 하는 디자인은 프로바이더 관점이 아직 남아있다는 증거이기도 하다
- 출금 계좌에 대응되는 송금 계좌 리스트를 제공하는 목표를 새로 만들어 개선할 수 있다
	- 기존의 혼란스로운 계좌 목록과 받는 계좌 목록을 대체하게 하여 받는 계좌 속성 값으로 쓸 수 있게 만들어 문제를 해결한다

<img width="613" alt="image" src="https://github.com/seung-hun-h/record/assets/60502370/685e9d9e-da7d-46c7-86b9-cb5a5b453c54">
- 새로 통합된 목표는 목록에서 주어지는 출금 계좌에서 가능한 송금 계좌만 반환해준다
- 마지막으로 최적화까지 가능하다

<img width="612" alt="image" src="https://github.com/seung-hun-h/record/assets/60502370/5ff65466-8c4a-48d7-bcc4-3f20c880a3eb">

- 보내는 계좌마다 송금이 가능한 받는 계좌를 조합하면 그 수는 제한되어 있기 때문에 모든 조합을 목록화 시켜서 보내는 계좌에 따라 송금이 가능한 받는 계좌를 반환해줄 수도 있다
- 반드시 해야하는 것은 아니다
- 이러한 통합은 성능적인 이슈를 발생시킬 수도 있다는 점을 명심해야 한다

### 상태가 없는 흐름 디자인하기
- 다음과 같은 흐름으로 송금이 이뤄진다고 생각해본다
1. 보내는 계좌의 목록을 보여준다
2. 선택한 보내는 계좌에서 송금할 수 있는 받는 계좌의 목록을 보여준다. (선택된 보내는 계좌의 정보는 서버측 세션에 저장되어 있다)
3. 받는 계좌에서 일정 금액을 송금한다.(서버측 세션에 저장되었던 보내는 계좌를 이용한다.)

- 이러한 흐름은 상태가 존재한다
- 상태가 있는 구조는 좋은 생각이 아니다
- 이미 명확하게 정의된 목표는 다른 목표에 의존할 필요 없이 단독으로 사용할 수 있어야 한다
- 완벽하게 직관적인 흐름을 디자인 하려면 다음 규칙을 따라야 한다
	- 각 목표가 직관적인 상호작용을 제공하는지 확인한다
	- 목표의 호출에서 입력과 출력이 한결 같은지 확인한다
	- 가능한 경우 기존 목표에 데이터를 추가하여 오류를 방지하여 새로운 목표를 만든다
	- 가능한 경우 컨슈머의 관점에서 기능적으로 합리적이라면 목표들을 통합한다
	- 연쇄되어있는 모든 목표는 상태가 없어야 한다


