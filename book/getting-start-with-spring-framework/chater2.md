# 스프링 프레임워크 기초
## 인터페이스를 사용하는 프로그래밍 설계 원칙
- 의존 중인 클래스가 의존 관계의 구체적인 클래스를 직접 참조한다면, 두 클래스 사이의 긴밀한 결합이 생긴다
  - 긴밀한 결합이 생기면 의존 관계의 구현을 변경하면 의존 중인 클래스도 변경해야 한다
- 자바 인터페이스는 구현 클래스가 준수해야 하는 계약을 정의한다
  - 인터페이스에 의존하면 의존 관계의 구현이 변경되어도 의존 중인 클래스는 변경하지 않아도 된다

### 인터페이스를 사용하는 프로그래밍 설계방식 지원
- 스프링 애플리케이션에서 인터페이스를 사용하는 프로그래밍 설계 방식을 사용하기 위해서는 다음과 같은 일을 할 수 있어야 한다
  - 의존 관계에 구체적인 구현 클래스가 아닌 의존 관계 인터페이스를 참조하는 빈 클래스를 만든다
  - 의존 중인 빈에 주입하고 싶은 구체적인 구현을 지정할 수 있는 `<bean>` 엘리먼트를 정의한다

## 빈 스코프
- 싱글턴 스코프
  - 빈을 공유하기 위한 단 하나의 인스턴스를 만든다
- 프로토타입 스코프
  - 빈이 요청될 때마다 새로운 빈 인스턴스를 생성한다
- request, session, websocket, application 스코프 (나중에 다룸)

### 싱글턴
- 스프링 컨테이너가 생성될 때 함께 생성되고, 스프링 컨테이너가 파괴될 때 함께 파괴된다
- 스프링 컨테이너는 싱글턴 스코프 빈의 인스턴스를 단 하나만 만들고, 그 빈에 의존하는 모든 빈에 대한 유일한 인스턴스를 공유한다

### 싱글턴 패턴
- 장점
  - 런타임에 하나의 인스턴스를 공유하기 떄문에 웹 환경처럼 클라이언트의 요청이 많은 경우 메모리를 절약할 수 있다
- 단점
  - 인스턴스가 공유되기 때문에 가변 상태를 가지면 문제가 발생할 수 있다
  - 컴파일 타임에 구체 클래스가 결정된다
  - OCP, DIP에 위배된다
  - 테스트가 어렵다

- 여러 단점으로인해 안티 패턴이다
- 이러한 단점을 스프링 컨테이너가 해결해준다


**여러 스프링 컨테이너에 있는 싱글턴 스코프 빈**
- 싱글턴 스코프 빈 인스턴스의 존재 범위는 한 스프링 컨테이너 인스턴스 내부로 제한된다
- 똑같은 설정 메타데이터로부터 2개의 스프링 컨테이너를 만들면 각 스프링 컨테이너마다 자신만의 싱글턴 빈 인스턴스를 갖게된다

### 프로토타입
- 스프링 컨테이너가 항상 프로토타입 스코프 빈의 새로운 인스턴스를 반환한다
- 프로토타입 빈은 항상 지연 초기화된다

> **지연 초기화**
> 스프링 컨테이너가 빈 인스턴스를 요청 받는 시점에 초기화 하는 방벙이다 <br>
> 싱글턴 스코프에서도 지연 초기화가 가능하지만, 인스턴스 생성 시 발생하는 문제점을 컴파일 타입에 잡을 수 없다는 문제점이 있다

## 의존성 주입(Dependency Injection)
### Field
- `@Autowired public Hello hello`
- 간단하지만 권장하지 않는다
- final을 사용할 수 없다
- 테스트하기 어렵다
### Setter
- `@Autowired public void setHello(Hello hello){ ... }`
- final을 사용할 수 없다
- 객체의 상태가 가변적이다
- 의존관계 주입이 되지 않아도 객체가 생성가능 해지므로 NPE가 발생할 가능성도 있다

### Constructor
- 가장 권장하는 방식
- final을 사용할 수 있다
- 의존관계가 모두 주입되어야 객체가 생성된다