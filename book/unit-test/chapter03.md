# 3. 단위 테스트 구조
## 3.1 단위 테스트를 구성하는 방법
### 3.1.1 AAA 패턴 사용
- AAA 패턴은 각 테스트를 준비-실행-검증이라는 세 부분으로 나눌 수 있다

```java
public void sumTest() {
    // 준비
    double first = 10;
    double second = 20;
    Calculator calculator = new Calculator();

    // 실행
    double sum = calculator.sum(first, second);

    // 검증
    Assertions.assertThat(sum).isEqualTo(first + second);
}
```

- **AAA 패턴의 구조**
  - 준비 구절에서는 SUT와 해당 의존성을 원하는 상태로 만든다
  - 실행 구절에서는 SUT에서 메서드를 호출하고 준비된 의존성을 전달하며 출력 값을 캡처 한다
  - 검증 구절에서는 결과를 검증한다

- **AAA 패턴과 Given-When-Then 패턴**
  - 두 패턴은 동일하다
  - 프로그래머가 아닌 사람들에게는 Given-When-Then 구조가 더 읽기 쉽다
  
- **제품 코드가 먼저 준비된 경우**
  - 테스트를 준비 구절부터 시작하는 것이 자연스럽다

- **제품 코드가 먼저 준비되지 않은 경우(TDD)**
  - TDD를 실천할 떄는 아직 기능이 어떻게 동작할 지 충분히 알지 못한다
  - 따라서 먼저 기대하는 동작으로 윤곽을 잡은 다음, 이러한 기대에 부응하기 위한 시스템을 어떻게 개발할지 아는 것이 좋다

### 3.1.2 여러 개의 준비, 실행, 검증 구절 피하기
- 검증 구절로 구분된 여러 실행 구절을 보면 여러 개의 동작 단위를 검증하는 테스트를 뜻한다
- 이러한 테스트는 단위 테스트가 아닌 통합테스트이다
- 이러한 구조는 피하는 것이 좋다

### 3.1.3 테스트 내 if문 피하기
- if 문이 있는 테스트는 안티 패턴이다
- 모든 테스트는 분기가 없는 간단한 일련의 단계여야 한다
- if 문은 한 번에 너무 많은 테스트를 수행한다는 증거이다

### 3.1.4 각 구절은 얼마나 커야 하는가?
- 준비 구절이 세 구절 중 가장 크다
  - 너무 크면 비공개 메서드 또는 별도의 팩토리 클래스를 도출하는 것이 조핟
  - 준비 구절에서 코드 재사용에 도움이 되는 패턴으로 오브젝트 마더, 테스트 데이터 빌더가 있다
- 실행 구졸은 보통 한 줄이다
  - 실행 구절이 두 줄 이상인 경우 SUT의 공개 API에 문제가 있을 수 있다
  - 클라이언트가 첫 번째 메서드를 호출하고 두 번째 메서드를 호출하지 않으면 문제가 발생할 수 있다. 불변 위반이라 한다
  - 캡슐화를 항상 지켜야 한다

### 3.1.5 검증 구절에는 검증문이 얼마나 있어야 하는가
- 단위 테스트의 단위는 동작의 단위이지 코드의 단위가 아니므로, 단일 동작 단위가 여러 결과를 낼 수 있다
- 그럼에도 검증 구절이 너무 커지는 것은 경계해야 한다. 제품 코드에서 추상화가 누락됐을 수 있기 때문이다

### 3.1.6 종료 단계는 어떤가
- 대부분의 단위 테스트에는 종료 구절이 필요없다
- 단위 테스트는 프로세스 외부에 종속적이지 않기 때문이다

### 3.1.7 테스트 대상 시스템 구별하기
- SUT는 동작에 대한 진입 지점을 제공한다
- 동작은 여러 클래스를 거칠 수 있지만, 진입 지점은 오직 하나이다
- SUT를 다른 의존성과 구분하기 위해 이름을 `sut`로 하는 것이 좋다

### 3.1.8 준비, 실행, 검증 주석 제거하기
- AAA 패턴을 따르고 준비 및 검증 구절에 빈 줄을 추가하지 않아도 되는 테스트라면 구절 주석들을 제거하라
- 그렇지 않으면 주석을 유지히라

## 3.2 xUnit 테스트 프레임어크 살펴보기
- 생략

## 3.3 테스트 간 테스트 픽스처 재사용
- 테스트 픽스처는 테스트 실행 대상 객체이다
  - SUT로 전달되는 인수다
  - 데이터베이스에 있는 데이터나 하드 디스크 파일일 수 있는데, 이러한 객체는 고정 상태를 유지한다

- 준비 구절에서 코드를 재상하면 테스트를 줄이면서 단순화할 수 있는 좋은 방법이다
- 테스트 픽스처를 재사용하는 첫 번째 방법은 테스트 생성자에서 픽스처를 초기화 하는 것이다
  - 이 방법은 올바르지 않는 방법이다
  - 테스트간 결합도가 높아진다
  - 테스트 가독성이 떨어진다

### 3.3.1 테스트간의 높은 결합도는 안티 패턴이다
- 생성자에 준비 코드를 호출하면 테스트간의 결합도가 높아진다
- 테스트를 수정해도 다른 테스트에 영향을 주어서는 안된다
- 테스트는 서로 격리되어 실행해야 한다
- 이 지침을 따르기 위해서는 공유 상태를 두지 말아야 한다

### 3.3.2 테스트 가독성을 떨어뜨리는 생성자 사용
- 생성자에 준비 코드를 호출하면 테스트의 가독성이 떨어진다
- 테스트만 보고 전체 그림을 파악할 수 없게된다

### 3.3.3 더 나은 테스트 픽스처 사용방법
- 생성자에 준비 코드를 호출하는 것보다 더 나은 방법은 같은 테스트 클래스에 비공개 팩토리 메서드를 두는 것이다
  - 테스트 코드를 짧게 할 수 있다
  - 테스트 진행 상황에서 전체 맥락을 유지할 수 있다
  - 비공개 메서드를 충분히 일반화하는 한 테스트가 서로 결합되지 않는다
- 하지만 모든 테스트 혹은 거의 대부분의 테스트에 사용되는 경우 생성자에 픽스처를 인스턴스화 할 수도 있다

## 3.4 단위 테스트 명명법
- 간단하고 쉬운 영어 구문이 적절하다
- `[테스트 대상 메서드]_[시나리오]_[예상 결과]` 와 같이 작성하는 것은 세부 구현 사항에 집중하게끔 부추기기 떄문에 도움이 되지 않는다


### 3.4.1 단위 테스트 명명 지침
- 엄격한 명명 정책을 따르지 않는다
  - 복잡한 동작에 대한 설명은 해당 정책에 따르지 못할 수 있다
- 비개발자들에게 시나리오를 설명하는 것처럶 테스트 이름을 짓자
- 단어를 밑줄 표시로 구분한다
- 테스트 이름에는 소망이나 욕구를 넣지 않는다. 테스트는 원자적 사실이다.

### 3.4.2 예제: 지침에 따른 테스트 이름 변경
- 생략

## 3.5 매개변수화된 테스트 리팩터링 하기
- 생략

## 3.6 검증문 라이브러리를 사용한 테스트 가독성 향상
- 생략