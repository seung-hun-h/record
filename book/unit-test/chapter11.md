# 11. 단위 테스트 안티 패턴
## 11.1 비공개 메서드 단위 테스트
### 11.1.1 비공개 메서드와 테스트 취약성
- 비공개 메서드를 직접 테스트하는 대신 포괄적인 식별할 수 있는 동작으로서 간접적으로 테스트하는 것이 좋다

### 11.1.2 비공개 메서드와 불필요한 커버리지
- 때로는 비공개 메서드가 너무 복잡해서 식별할 수 있는 동작으로 테스트하기에 충분히 커버리지를 얻을 수 없는 경우가 있다
- 식별할 수 있는 동작에 이미 합리적인 테스트 커버리지가 있다고 가정하면 다음 두 가지 문제가 발생할 수 있다
  - 죽은 코드다. 테스트에서 벗어난 코드가 어디에도 사용되지 않는다면 리팩터링 후에도 남아서 관계없는 코드일 수 있다
  - 추상화가 누랙돼 있다. 비공개 메서드가 너무 복잡하면 별도의 클래스로 도출돼야 하는 추상화가 누락됐다는 징후다

### 11.1.3 비공개 메서드 테스트가 타당한 경우
- ORM을 사용하는 경우 공개 생성자가 필요하지 않아 비공개 생성자를 사용할 수 있다
- 이때 테스트 코드에서는 비공개 생성자이므로 인스턴스화 할 수 없다
- 이러한 경우에 생성자를 공개한다고 해서 테스트가 쉽게 깨지지 않는다
- 그리고 클래스의 공개 API 노출 영역을 가능한 작게 하려면 테스트에서 리플렉션을 통해 인스턴스화 할 수 있다
  - 해킹처럼 보이지만 ORM을 따르고 있으며 배후에서 리플렉션을 사용하기도 한다

## 11.2 비공개 상태 노출
- 단위 테스트 목적으로만 비공개 상태를 노출하는 것은 안티패턴이다
- 테스트는 제품 코드와 정확히 같은 방식으로 테스트 대상 시스템과 상호 작용해야 하며, 특별한 권한이 따로 있어서는 안된다

## 11.3 테스트로 유출된 도메인 지식
- 도메인 지식을 테스트로 유출하는 것은 안티패턴이다
- 이러한 테스트는 구현 세부사항과 결합되는 또 다른 예이다

## 11.4 코드 오염
- 코드 오염이란 테스트에만 필요한 제품 코드를 추가하는 것이다
- 코드 오염도 안티패턴이다

## 11.5 구체 클래스를 목으로 처리하기
- 일부 기능을 지키려고 구체 클래스를 목으로 처리해야 하면 이는 단일 책임 원칙을 위반한 결과다
- 한 구체 클래스가 비관리 의존성과 통신하는 책임과 비즈니스 로직에 대한 책임이 서로 관련이 없음에도 결합돼 있는 경우다
- 두 책임을 분리해야 한다

## 11.6 시간 처리하기
- 시간에 따라 달라지는 기능을 테스트하면 거짓 양성이 발생할 수 있다
- 실행 단계의 시간이 검증 단계의 시간과 다를 수 있다

### 11.6.1 앰비언트 컨텍스트로서의 시간
- 앰비언트 컨텍스트 패턴을 사용하는 방법이다
- 시간 컨텍스트에서 앰비언트 컨텍스트는 프레임워크의 내장 대신 사용자 정의 클래스에 해당한다

```c#
public static class DateTimeServer {
    private static Func<DateTime> _func;
    public static DateTime Now => _func();

    public static void Init(Func<DateTime> func) {
        _func = func;
    }
}

DateTimeServer.Init(() => DateTime.Now);
DateTimeServer.Init(() => new DateTime(2020, 1, 1));
```

- 시간을 앰비언트 컨텍스트로 사용하는 것도 안티 패턴이다
  - 제품 코드를 오염시키고 테스트를 더 어렵게 한다
  - 정적 필드는 테스트간 공유하는 의존성을 도입해 해당 테스트를 통합 테스트 영역으로 전환한다

### 11.6.2 명시적 의존성으로서의 시간
- 더 나은 방법으로 서비스 또는 일반 값을 시간 의존성을 명시적으로 주입하는 것이있다
- 시간을 서비스로 주입하는 것 보다는 값으로 주입하는 것이 더 낫다
- 제품 코드에서 일반 값으로 작업하는 것이 더 쉽고, 테스트에서 해당 값을 스텁으로 처리하기도 더 쉽다