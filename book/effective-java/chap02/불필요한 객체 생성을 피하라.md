
- 똑같은 기능을하는 객체는 매번 새로 생성하는 것 보다는 객체 하나를 재사용하는 편이 나을 떄가 많다

### 1. 객체 재사용: 문자열 리터럴
```Java
String s = new String("bikini");
```

- 위 코드는 매번 실행할 때마다 새로운 문자열 인스턴스가 생성된다

```Java
String s = "bikini";
```

- 문자열 리터럴을 사용한 위 코드는 똑같은 문자열 리터럴을 사용하는 모든 코드가 같은 객체를 사용함이 보장된다

### 2. 객체 재사용:  정적 팩터리 메서드
- 정적 팩토리 메서드를 사용하는 불변 클래스에서는 정적 팩터리 메서드를 사용해 불필요한 객체 생성을 피할 수 있다
- 아래 처럼 생성자를 사용하는 것보다 정적 팩터리 메서드를 사용하는 것이 더 좋다
	- 생성자는 매번 새로운 객체를 만들지만, 팩터리 메서드는 그렇지 않다

```Java
Boolean b = new Boolean(...);

Boolean b = Boolean.valueOf(...);
```

- 불변 객체뿐 아니라 가변 객체도 사용 중간에 변경되지 않을 것임을 안다면 재사용할 수 있다

### 3. 객체 재사용: 캐싱
- 생성 비용이 비싼 객체가 반복해서 필요하다면, 캐싱하여 재사용하길 권한다

```Java
static boolean isRomanNumeral(String s) {
	return s.matches("...");
}
```
- `String.matches`는 정규 표현식으로 문자열 형태를 확인하는 가장 쉬운 방법이지만, 성능이 중요한 상황에서 반복해서 사용하는 것은 적절하지 않다
- 내부에서 `Pattern`인스턴스를 한 번 사용하고 버리기 때문이다
- 성능을 개선하기 위해 불변 `Pattern`인스턴스를 생성해 클래스 초기화 과정에 직접 생성해 캐싱해두고 사용할 수 있다

```Java
public class RomanNumerals {
	private static final Pattern ROMA = Patter.compile("...");
	
	static boolean isRomanNumeral(String s) {
		return ROMAN.matches(s).matches();
	}
}
```

### 객체를 재사용하는 또 다른 경우
- 객체가 불변이라면 재사용해도 안전함이 명백하다
- 어댑터
	- 어댑터는 실제 작업은 뒷단 객체에 위임하고, 자신은 제 2의 인터페이스 역할을 해주는 객체다
	- 뒷단 객체만 관리하면 되므로 뒷단 객체 하나당 어댑터 하나씩만 만들면 된다
- Map 인터페이스의 `keySet()`
	- `keySet`은 Map 객체 안의 키를 전부 담은 Set 뷰를 반환한다
	- `keySet`을 호출할 때마다 새로운 인스턴스가 반환될 것 같지만 그렇지 않을 수도 있다
	- 모두가 똑같은 Map을 대변하기 때문에 반환된 Set이 변경되는 경우 다른 모든 객체가 따라 바뀐다
	- 따라서 매번 다른 인스턴스를 반환할 필요도 이득도 없다
- 연산
	- 오토박싱은 불필요한 객체를 만들어내는 경우가 있다
	- 아래 코드는 불필요한 오토박싱이 일어나 매번 인스턴스를 생성한다
	- 박싱된 기본 타입 보다는 기본 타입을 사용하고, 의도치 않은 오토박싱이 숨어들지 않도록 해야 한다
	  
```Java
public static long sum() {
	Long sum = 0L;
	for (long i = 0; i <= Integer.MAX_VALUE; i++) {
		sum += i;
	}

	return sum;
}
```

### 매번 객체 생성을 피해야 하는 것은 아니다
- '객체 생성은 비싸니 피해야한다' 가 아니다
- 프로그램의 명확성, 간결성, 기능을 위해서 객체를 추가로 생성하는 것이라면 일반적으로 좋은 일이다
- 아주 무거운 객체가 아니면 본인들만의 풀(Pool)을 만들지 마라
	- 자체 객체 풀은 코드를 헷갈리게 만들고 메모리 사용량을 늘리고 성능을 떨어뜨린다
- 불필요한 객체 생성은 그저 코드 형태와 성능에만 영향을 주지만, 객체를 재사용하면서 발생하는 피해가 훨씬 클 수 있다

> 방어적 복사
> 생성자의 인자로 받은 객체의 복사본을 만들어 내부 필드를 초기화 하거나, getter 메서드에서 내부 객체를 반환할 때 객체의 내부를 복사하여 반환


