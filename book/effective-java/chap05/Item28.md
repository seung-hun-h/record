## ITEM28 배열보다는 리스트를 사용하라

- 배열은 제네릭과 다른 중요한 두 가지 차이점을 가지고있다
	- 배열은 공변이지만, 제네릭은 불공변이다
	- 배열은 실체화되지만, 제네릭은 실체화되지 않는다

### 배열은 공변이지만, 제네릭은 불공변이다
- 배열이 공변이라는 것은, Sub가 Super의 하위 타입이면, `Sub[]`도 `Super[]`의 하위 타입인 것을 말한다
- 제네릭은 불공변이다. 즉, Sub가 Super의 하위 타입이지만, `List<Sub>`는 `List<Super>`의 하위 타입은 아니다

```Java
Object[] objectArray = new Long[1];
objectArray[0] = "타입이 달라 넣을 수 없다";
```
- 위 코드는 런타임에 `ArrayStoreException`을 던진다
	- 배열은 공변이기 때문에 위 코드는 문법상 허용된다

```Java
List<Object> objectList = new ArrayList<>();
objectList.add("타입이 달라 넣을 수 없다");
```
- 위 코드는 컴파일 되지 않는다
	- 제네릭은 불공변이므로 컴파일러가 컴파일 시점에 오류를 잡아낸다

### 배열은 실체화되지만, 제네릭은 실체화되지 않는다
- 배열은 런타임에도 자신이 담기로한 원소의 타입을 인지하고 확인한다
- 반면, 제네릭은 타입 정보가 런타임에는 소거된다
	- 컴파일 타임에만 타입 검사를 하고 런타임에는 알 수 없다는 뜻이다

### 배열과 제네릭은 잘 어우러지지 못한다
- 배열은 제네릭 타입, 매개변수화 타입, 타입 매개변수로 사용할 수 없다
	- `new List<>[]`, `new List<String>[]`, `new E[]` 식으로 작성하면 컴파일 할 때 제네릭 배열 생성 오류를 일으킨다
- 제네릭 배열은 타입 안전하지 못하므로 애초에 생성하지 못하게 막았다
- 제네릭 배열을 생성할 수 있다고 가정하자
```Java
List<String>[] stringLists = new List<String>[1]; // 1
List<Integer> intList = List.of(42); // 2
Object[] objects = stringLists; // 3
objects[0] = intList; // 4
String s = stringLists[0].get(0); // 5
```
1. 제네릭 배열을 생성한다
2. 원소가 하나인 `List<String>`을 생성한다
3. `List<String>` 배열을 `Object` 배열로 형변환한다. 배열은 공변이므로 문제없다
4. `List<Integer>`를 `Object`배열의 첫 번째 원소로 저장한다
5. `List<String>` 배열에 `List<Integer>` 원소가 저장되어 있어 `ClassCastException`이 발생한다

- 이러한 일이 일어나는 것을 방지하기 위해 제네릭 배열을 만드는 것을 금지했다

- `E`, `List<E>`, `List<String>` 같은 타입을 실체화 불가 타입이라 한다
	- 실체화 되지 않아서 런타임에는 컴파일 타임보다 타입 정보를 적게 가지는 타입이다
	- 소거 메커니즘 떄문에 매개변수화 타입 가운데 실체화될 수 있는 타입은 `List<?>`, `Map<?, ?>` 같은 비한정적 와일드카드 타입 뿐이다

#### 배열을 제네릭으로 만들 수 없어 귀찮은 경우
- 제네릭 컬렉션에서는 자신의 원소 타입을 담은 배열을 반환하는게 보통은 불가능하다(?)
	- 자신의 원소 타입이라는 것은 `List<String>`인 경우 `String`을 말하는건가?
	- 만약 그럴 경우 `toArray()` 메서드가 `Collection`에 정의되어 있어 구현만하면 가능한데
	- 내부 구현을 보면 원소 배열을 복사하는 방법으로 되어있는데, 이것 때문인가?
- 제네릭 타입과 가변인수 메서드를 함께 쓰면 해석하기 어려운 경고 메시지를 받게 된다
	- 가변인수 메서드를 호출할 때마다 가변인수 매개변수를 담을 배열이 하나 만들어지는데, 이때 그 배열의 원소가 실체화 불가 타입이라면 경고가 발생한다
		- 제네릭은 런타임에 사라지고, 배열은 런타임에 실체화된다
		- 이 문제는 `@SafeVarargs` 애너테이션으로 대체할 수 있다
- 배열로 형변환할 때 제네릭 배열 생성 오류나 비검사 형변환 경고가 뜨는 경우 대부분은 배열인 `E[]` 대신 컬렉션인 `List<E>`를 사용하면 해결된다