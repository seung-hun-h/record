- 객체지향의 핵심은 **역할, 책임, 협력**이다
	- 협력은 메시지를 주고받는 객체들 사이의 상호작용
	- 책임은 객체가 다른 객체와 협력하기 위해 수행하는 행동
	- 역할은 대체 가능한 책임의 집합
- 세 가지 중 가장 중요한 것은 책임이다
	- 책임이 적절하지 못하면 역할 역시 협력과 조화를 이루지 못한다
- 객체지향 설계란 **객체에게 올바른 책임을 할당하면서 낮은 결합도와 높은 응집도를 가진 구조를 창조하는 활동이다**
	- 설계는 변경을 위해 존재한다
	- 변경은 비용을 발생시킨다
	- 적절한 비용에서 쉽게 변경할 수 있는 설계는 응집도가 높고 느슨하게 결합되어 있다
- 결합도와 응집도를 합리적인 수준으로 유지하기 위해서는 객체의 상태가 아니라 객체의 행동에 집중해야 한다

## 데이터 중심의 영화 예매 시스템
- 데이터 중심의 설계는 객체가 내부에 저장해야 하는 '데이터가 무엇인가'에 대해 관심을 갖는다

```Java
public class Movie {  
    private String title;  
    private Duration runningTime;  
    private Money fee;  
    private List<DiscountCondition> discountConditions;  
  
    private MovieType movieType;  
    private Money discountAmount;  
    private double discountPercent;    
    // getter, setter  
}
```

```Java
public enum MovieType {  
    AMOUNT_DISCOUNT,    // 금액 할인 정책  
    PERCENT_DISCOUNT,   // 비율 할인 정책  
    NONE_DISCOUNT       // 미적용  
}
```

- 데이터 중심의 설계에서는 객체가 포함해야 하는 데이터에 집중한다
- 비율 할인 정책(`PERCENT_DISCOUNT`)은 `discountPercent`라는 값을 필요로 하고, 금액 할인 정책(`AMOUNT_DISCOUNT`)은 `discountAmount`를 필요로한다
- 인스턴스의 종류에 따라 배타적으로 사용될 인스턴스 변수를 하나의 클래스안에 포함시키는 방식은 데이터 중심 설계 안에서 흔히 존재하는 패턴이다

```Java
  public class DiscountCondition {  
    private DiscountConditionType type;  
  
    private int sequence;  
  
    private DayOfWeek dayOfWeek;  
    private LocalTime startTime;  
    private LocalTime endTime;  
    // getter, setter
}
```

```Java
public enum DiscountConditionType {  
    SEQUENCE,       // 순번조건  
    PERIOD          // 기간 조건  
}
```
- `DiscountCondition`은 할인 조건이다
	- 순번(`SEQUENCE`)과 기간(`PERIOD`) 조건이 있다
- 마찬가지로 배타적인 데이터(`dayOfWeek`, `startTime, endTime`)가 한 곳에 존재한다


```Java
public class Screening {  
    private Movie movie;  
    private int sequence;  
    private LocalDateTime whenScreened;
    // getter, setter
}
```

```Java  
public class Reservation {  
    private Customer customer;  
    private Screening screening;  
    private Money fee;  
    private int audienceCount;
    // getter, setter
}
```

```Java
public class Customer {  
    private String name;  
    private String id;  
  
    public Customer(String name, String id) {  
        this.id = id;  
        this.name = name;  
    }  
}
```

- 영화 예매를 위한 데이터를 가지고 있는 `Screening`, `Reservation`, `Customer` 클래스를 작성한다

### 영화를 예매하자
```Java
public class ReservationAgency {  
    public Reservation reserve(Screening screening, Customer customer,  
                               int audienceCount) {  
        Movie movie = screening.getMovie();  
  
        boolean discountable = false;  
        for(DiscountCondition condition : movie.getDiscountConditions()) {  
            if (condition.getType() == DiscountConditionType.PERIOD) {  
                discountable = screening.getWhenScreened().getDayOfWeek().equals(condition.getDayOfWeek()) &&  
                        condition.getStartTime().compareTo(screening.getWhenScreened().toLocalTime()) <= 0 &&  
                        condition.getEndTime().compareTo(screening.getWhenScreened().toLocalTime()) >= 0;  
            } else {  
                discountable = condition.getSequence() == screening.getSequence();  
            }  
  
            if (discountable) {  
                break;  
            }  
        }  
  
        Money fee;  
        if (discountable) {  
            Money discountAmount = Money.ZERO;  
            switch(movie.getMovieType()) {  
                case AMOUNT_DISCOUNT:  
                    discountAmount = movie.getDiscountAmount();  
                    break;  
                case PERCENT_DISCOUNT:  
                    discountAmount = movie.getFee().times(movie.getDiscountPercent());  
                    break;  
                case NONE_DISCOUNT:  
                    discountAmount = Money.ZERO;  
                    break;  
            }  
  
            fee = movie.getFee().minus(discountAmount).times(audienceCount);  
        } else {  
            fee = movie.getFee().times(audienceCount);  
        }  
  
        return new Reservation(customer, screening, fee, audienceCount);  
    }  
}
```

- `reserve()`는 크게 두 부분으로 나눌 수 있다
	- `DiscountCondition`에 대해 루프를 돌면서 할인 가능 여부를 확인하는 for문
	- `discountable` 변수의 값을 체크하고 적절한 할인 정책에 따라 예매 요금을 계산하는 if문

## 설계 트레이드 오프
- 객체지향 커뮤니티에서는 설계의 품질을 측정하기 위해 **캡슐화, 응집도, 결합도** 세 가지 척도를 활용한다

### 캡슐화
- 상태와 행동을 하나의 객체 안에 모으는 이유는 객체의 내부 구현을 외부로 숨기기 위해서다
- 객체를 사용하면 변경 가능성이 높은 부분은 내부로 숨기고, 외부에는 상대적으로 안정적인 부분만 공개하여 변경의 여파를 통제할 수 있다
- 변경될 가능성이 높은 부분을 **구현**, 상대적으로 안정적인 부분은 **인터페이스**라 한다
- 객체지향에서 가장 중요한 원칙이 **캡슐화**이다
- 캡슐화는 변경 가능성이 높은 부분을 객체 내부로 숨기는 추상화 기법이다

### 응집도와 결합도
- 응집도는 모듈에 포함된 내부 요소들이 연관돼 있는 정도를 말한다
	- 객체지향 관점에서 응집도는 객체 또는 클래스에 얼마나 관련 높은 책임을 할당했는지를 말한다
- 결합도는 의존성의 정도를 나타내며 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지를 나타내는 정도이다
	- 객체지향 관점에서 결합도는 객체 또는 클래스가 협력에 필요한 적절한 수준의 관계만을 유지하고 있는지를 나타낸다
- 일반적으로 좋은 설계란 높은 응집도와 낮은 결합도를 가진 모듈로 구성된 설계를 의미한다
	- 좋은 설계란 오늘의 기능을 수행하면서 내일의 변경을 수용할 수 있는 설계다
- 변경의 관점에서 응집도란 변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도로 측정할 수 있다
- 변경의 관점에서 결합도는 한 모듈이 변경되기 위해서 다른 모듈의 변경을 요구하는 정도로 측정할 수 있다

- 캡슐화의 정도가 응집도와 결합도에 영향을 준다
	- 캡슐화를 지키면 응집도가 높아지고, 결합도는 낮아진다

## 데이터 중심이 영화 예매 시스템의 문제점
- 데이터 중심의 설계는 캡슐화를 위반하고 객체 내부의 구현을 인터페이스의 일부로 만든다

### 캡슐화 위반
- 데이터 중심으로 설계한 `Movie`는 메서드만을 통해서만 객체의 내부 상태에 접근할 수 있다
	- 하지만 접근자와 수정자를 사용한다
	- 접근자와 수정자는 객체 내부의 어떤 정보도 캡슐화하지 못한다
- 캡슐화 원칙을 어기게된 근본적인 원인은 객체가 수행해야 할 책임이 아니라 데이터에 초점을 두었기 때문이다
- 앨런 홀럽은 접근자와 수정자에 과도하게 의존하는 설계 방식을 **추측에 의한 설계 전략**이라 부른다
	- 객체가 다양한 상황에 사용될 수 있을 것이라는 막연한 추측을 기반으로 설계를 하는 것을 의미한다

### 높은 결합도
- `ReservationAgency`는 모든 데이터 객체에 의존한다
- 높은 결합도는 변경의 전파를 야기한다

```Java
public class ReservationAgency {
	public reserve(Screening screening, Customer customer, int audienceCount) {
		...
		Money fee;
		if (discountable) {
			fee = movie.getFee().minus(discountedAmount).times(audienceCount);
		} else {
			fee = movie.getFee();
		}
		...
	}
}
```

- 높은 결합도는 전체 시스템을 하나의 거대한 의존성 덩어리로 만들어버리기 때문에 어떤 변경이라도 일단 발생하고 나면 시스템 전체가 요동칠 수 밖에 없다

### 낮은 응집도
- 다음과 같은 수정이 일어나면 `ReservationAgency`의 코드를 수정해야 할 것이다
	- 할인 정책이 추가되는 경우
	- 할인 정책별로 요금을 계산하는 방법이 다른경우
	- 할인 조건이 추가되는 경우
	- 할인 조건별로 할인 여부를 판단하는 방법이 변경될 경우
	- 예매 요금을 계산하는 방법이 변경될 경우
- 낮은 응집도는 두 가지 측면에서 설계에 문제를 일으킨다
	- 변경 사유가 다른 코드를 하나의 모듈에 뭉쳐놨기 때문에 아무 상관이 없는 코드들이 영향을 받게된다
		- 할인 정책에 수정이 일어나는 경우 할인 조건에도 영향을 미칠 수 있다
	- 하나의 요구사항 변경을 반영하기 위해 동시에 여러 모듈을 수정해야 한다
		- 할인 정책이 추가되는 경우 `ReservationAgency`에 case 절을 추가해야 한다
		- 그리고 새로운 할인 정책에 따른 요금 계산 방식을 추가하기 위해 `Movie`도 수정해야 한다
		- 등등..

> 단일 책임 원칙(Single Responsibility Principle, SRP)
> 로버트 마틴은 모듈의 응집도가 변경과 관련있다는 사실을 강조하기 위해 단일 책임 원칙이라는 설계 원칙을 제시했다. 단일 책임 원칙이란 클래스는 단 한 가지의 변경 이유만 가져야 한다는 것이다. 단일 책임 원칙은 클래스의 응집도를 높일 수 있는 설계 원칙이다

