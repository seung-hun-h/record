- 훌륭한 객체지향 코드를 작성하기 위해서는 클래스가 아닌 객체를 지향해야 한다
- 객체지향 애플리케이션에서 가장 중요한 재료는 클래스가 아닌 메시지다
- 애플리케이션은 클래스로 구성되지만 메시지를 통해 정의된다
- 유연하고 재사용 가능한 퍼블릭 인터페이스를 만들기 위해서는 설계 원칙과 기법을 익히고 적용해야 한다

## 협력과 메시지
### 클라이언트-서버 모델
- 메시지는 객체 사이의 협력을 가능하게 하는 매개체다
	- 객체는 자신의 희망을 메시지라는 형태로 전송한다
	- 메시지를 수신한 객체는 요청을 적절히 처리한 후 응답한다
- 이러한 협력 관계를 설명하기 위해서 **클라이언트-서버 모델**이라는 전통적인 메타포를 사용한다
	- 메시지를 전송하는 객체를 클라이언트, 메시지를 수신하는 객체를 서버라 한다
- 객체는 협력에 참여하는 동안 클라이언트와 서버의 역할을 동시에 하는 것이 일반적이다
	- 협력의 관점에서 객체는 두 가지 종류의 메시지 집합으로 구성된다. 하나는 객체가 수신하는 메시지 집합이고 다른 하나는 객체가 전송하는 메시지 집합이다
- 객체가 독립적으로 수행할 수 있는 것보다 더 큰 책임을 수행하기 위해서는 다른 객체와 협력해야 한다

### 메시지와 메시지 전송
- **메시지(Message)**
	- 객체들이 협력하기 위해 사용할 수 있는 유일한 의사소통 수단
	- 다른 객체에게 도움을 요청하는 것을 **메시지 전송** 혹은 **메시지 패싱**이라 한다
- **메시지 전송자**
	- 메시지를 전송하는 객체
- **메시지 수신자**
	- 메시지를 수신하는 객체
- 메시지는 **오퍼레이션 명**과 **인자(argument)** 로 구성되고, 메시지 전송은 여기에 메시지 수신자를 추가한 것이다

```Java
condition.isSatisfiedBy(screening);
```
- condition: 메시지 수신자
- isSatisfiedBy: 오퍼레이션 명
- screening: 인자

### 메시지와 메서드
- 메시지를 수신했을 때 실제로 어떤 코드가 실행되는지는 메시지 수신자의 실제 타입이 무엇인가에 달려 있다
- 메시지를 수신했을 때 실제로 실행되는 함스 또는 프로시저를 **메서드**라 한다
- 코드 상에서 동일한 이름의 변수에게 동일한 메시지를 전송하더라도 **객체의 타입에 따라 실행되는 메서드가 달라질 수 있다**
- 메시지와 메서드의 구분은 메시지 전송자와 메시지 수신자가 느슨하게 결합될 수 있게 한다
	- 메시지 전송자는 자신이 어떤 메시지를 전송해야 하는지만 알면 된다
	- 메시지 수신자는 메시지를 처리하기 위해 적절한 메서드를 스스로 결정할 수 있는 자율권을 누린다
- 실행 시점에 메시지와 메서드를 바인딩하는 매커니즘은 두 객체 사이의 결합도를 낮춤으로써 유연하고 확장 가능한 코드를 작성할 수 있게 만든다

### 퍼블릭 인터페이스와 오퍼레이션
- 객체가 의사소통을 위해 외부에 공개하는 메시지의 집합을 **퍼블릭 인터페이스**라 한다
- 프로그래밍 언어 관점에서 퍼블릭 인터페이스에 포함된 메시지를 **오퍼레이션**이라 한다
	- 오퍼레이션은 수행 가능한 어떤 행동의 추상화이다
	- `DiscountCondition`의 `isSatisfiedBy`는 오퍼레이션이다
	- `PeriodCondition`의 `isSatisfiedBy`는 메서드다

### 시그니처
- 오퍼레이션(또는 메서드)의 이름과 파라미터 목록을 합쳐 **시그니쳐**라고 부른다
	- 오퍼레이션은 실행 코드 없이 시그니처만을 정의한 것이다


## 인터페이스 설계와 품질
- 좋은 인터페이스는 **최소한의 인터페이스**와 **추상적인 인터페이스**라는 조건을 만족해야 한다
- **책임 주도 설계** 방법은 최소주의를 따르면서 추상적인 인터페이스를 설계할 수 있는 가장 좋은 방법이다
	- 메시지를 먼저 선택해 협력과 무관한 오퍼레이션을 방지한다
	- 메시지가 객체를 선택해 클라이언트의 의도를 메시지에 표현할 수 있다
- 좋은 인터페이스의 공통적인 특징
	- 디미터 법칙
	- 묻지 말고 시켜라
	- 의도를 드러내는 인터페이스
	- 명령-쿼리 분리

### 디미터 법칙
```Java  
public class ReservationAgency {  
    public Reservation reserve(Screening screening, Customer customer,  
                               int audienceCount) {  
        Movie movie = screening.getMovie();  
  
        boolean discountable = false;  
        for(DiscountCondition condition : movie.getDiscountConditions()) {  
            if (condition.getType() == DiscountConditionType.PERIOD) {  
                discountable = screening.getWhenScreened().getDayOfWeek().equals(condition.getDayOfWeek()) &&  
                        condition.getStartTime().compareTo(screening.getWhenScreened().toLocalTime()) <= 0 &&  
                        condition.getEndTime().compareTo(screening.getWhenScreened().toLocalTime()) >= 0;  
            } else {  
                discountable = condition.getSequence() == screening.getSequence();  
            }  
  
            if (discountable) {  
                break;  
            }  
        }  
		... 
    }  
}
```

- 이 코드의 가장 큰 단점은 `ReservationAgency`와 인자로 전달된 Screening 사이의 결합도가 너무 높다는 것이다
	- Screening이 Movie를 포함하지 않거나, Movie가 DiscountCondition을 포함하지 않거나 sequence의 타입이 Sequence로 변경될 수도 있다
- **디미터 법칙**은 협력하는 객체의 내부 구조에 대한 결합으로 인해 발생하는 설계 문제를 해결하기 위해 제안된 원칙이다
	- 객체 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하는 원칙이다
- 디미터 법칙을 따르기 위해서는 클래스가 특정한 조건을 만족하는 대상에게만 메시지를 전송하도록 프로그래밍 해야 한다
	- 모든 클래스 C와 C에 구현된 모든 메서드 M에 대해서, M이 메시지를 전송할 수 있는 모든 객체는 다음에 서술된 클래스의 인스턴스여야 한다
	- 이때 M에 의해 생성된 객체나 M이 호출하는 메서드에 의해 생성된 객체, 전역 변수로 선언된 객체는 모두 M의 인자로 간주한다
		- M의 인자로 전달된 클래스(C 포함)
		- C의 인스턴스 변수의 클래스
- 위 설명이 어렵다면 아래 조건을 만족하는 인스턴스에만 메시지를 전송하도록 프로그래밍해야 한다고 이해해도 무방하다
	- this 객체
	- 메서드의 매개변수
	- this의 속성
	- this의 속성인 컬렉션의 요소
	- 메서드 내에서 생성된 지역 객체

- 결합도 문제를 해결한 `ReservationAgency`는 아래와 같다

```Java
public class ReservationAgency {  
    public Reservation reserve(Screening screening, Customer customer, int audienceCount) {  
        Money fee = screening.calculateFee(audienceCount);  
        return new Reservation(customer, screening, fee, audienceCount);  
    }  
}
```

- 이제 `ReservationAgency`는 Screening의 내부에 대한 어떤 정보도 알지 못한다
- 디미터 법칙을 사용하면 **부끄럼타는 코드(shy code)** 를 작성할 수 있다
	- 부끄럼타는 코드란 불필요한 어떤 것도 다른 객체에 보여주지 않으며, 다른 객체의 구현에 의존하지 않는 코드를 말한다
- 디미터 법칙을 따르는 코드는 메시지 수신자의 내부 구조가 전송자에게 노출되지 않으며, 메시지 전송자는 수신자의 내부 구현에 결합되지 않는다

```Java
// 디미터 법칙을 위반한 코드
screening.getMovie().getDiscountConditions();

// 디미터 법칙을 준수한 코드
screening.caculateFee(audienceCount);
```

### 묻지 말고 시켜라
- 디미터 법칙은 훌륭한 메시지는 객체의 상태에 관해 묻지 말고 원하는 것을 시켜라는 사실을 강조한다
- **묻지 말고 시켜라(Tell. Don't ask)** 는 이런 스타일의 메시지 작성을 장려하는 원칙을 가리키는 용어다
- 묻지 말고 시켜라 원칙을 따르면 밀접하게 연관된 정보와 행동을 함께가지는 객체를 만들 수 있다
	- 자연스럽게 정보 전문가에 책임을 할당하게되고 응집도 높은 클래스를 얻을 확률이 높아진다
- 내부의 상태를 묻는 오퍼레이션을 인터페이스에 포함하고 있다면 더 나은 방법이 없는지 고민하라
- 단순하게 묻지 말고 시킨다고 모든 것이 해결되는 것은 아니고, 객체가 어떻게 작업을 수행하는지를 노출해서는 안된다


