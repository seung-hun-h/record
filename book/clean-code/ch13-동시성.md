## 목차
- [동시성](#동시성)
  - [동시성이 필요한이유?](#동시성이-필요한이유)
    - [미신과 오해](#미신과-오해)
    - [타당한 생각](#타당한-생각)
  - [난관](#난관)
  - [동시성 방어 원칙](#동시성-방어-원칙)
    - [단일 책임 원칙](#단일-책임-원칙)
    - [따름 정리: 자료 범위를 제한하라](#따름-정리-자료-범위를-제한하라)
    - [따름 정리: 자료 사본을 이용하라](#따름-정리-자료-사본을-이용하라)
    - [따름 정리: 스레드는 가능한 독립적으로 구현하라](#따름-정리-스레드는-가능한-독립적으로-구현하라)
  - [라이브러리를 이해하라](#라이브러리를-이해하라)
  - [실행 모델을 이해하라](#실행-모델을-이해하라)
    - [기본 용어](#기본-용어)
    - [생산자-소비자](#생산자-소비자)
    - [읽기-쓰기](#읽기-쓰기)
    - [식사하는 철학자들](#식사하는-철학자들)
  - [동기화하는 메서드 사이에 존재하는 의존성을 이해하라](#동기화하는-메서드-사이에-존재하는-의존성을-이해하라)
  - [동기화하는 부분을 작게 만들어라](#동기화하는-부분을-작게-만들어라)
  - [올바른 종료 코드는 구현하기 어렵다](#올바른-종료-코드는-구현하기-어렵다)
  - [스레드 코드 테스트하기](#스레드-코드-테스트하기)
    - [말이 안 되는 실패는 잠정적인 스레드 문제로 취급하라](#말이-안-되는-실패는-잠정적인-스레드-문제로-취급하라)
    - [다중 스레드를 고려하지 않는 순차 코드부터 제대로 돌게 만들자](#다중-스레드를-고려하지-않는-순차-코드부터-제대로-돌게-만들자)
    - [다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있게 스레드 코드를 구현하라](#다중-스레드를-쓰는-코드-부분을-다양한-환경에-쉽게-끼워-넣을-수-있게-스레드-코드를-구현하라)
    - [다중 스레드를 쓰는 코드 부분을 상황에 맞게 조율할 수 있게 작성하라](#다중-스레드를-쓰는-코드-부분을-상황에-맞게-조율할-수-있게-작성하라)
    - [프로세서 수보다 많은 스레드를 돌려보라](#프로세서-수보다-많은-스레드를-돌려보라)
    - [다른 플랫폼에서 돌려보라](#다른-플랫폼에서-돌려보라)
    - [코드에 보조 코드를 넣어 돌려라. 강제로 실패를 일으키게 해보라](#코드에-보조-코드를-넣어-돌려라-강제로-실패를-일으키게-해보라)

# 동시성
> 객체는 처리의 추상화다. 스레드는 일정의 추상화다. <br/>
> -제임스 O.코플리엔

## 동시성이 필요한이유?
- 동시성은 결합(Coupling)을 없애는 전략이다
  - 무엇(What)과 언제(When)을 분리하는 전략이다
  - 무엇과 언제를 분리하면 애플리케이션의 구조와 효율이 극적으로 나아진다
  - 구조적인 관점에서 프로그램은 거대한 루프 하나가 아니라 작은 협력 프로그램 여럿으로 보인다
  - 시스템을 이해하기가 쉽고 문제를 분리하기도 쉽다
- 웹 애플리케이션이 표준으로 사용하는 '서블릿 모델'도 동시성을 사용한다
  - 서블릿 웹 컨테이너의 관리를 받는다
  - 컨테이너는 동시성을 부분적으로 관리한다
  - 웹 요청이 들어올 때 마다 웹 서버는 비동기식으로 서블릿을 실행한다
  - 원칙적으로 각 서블릿 스레드는 다른 서블릿 스레드와 무관하게 돌아간다
- 웹 컨테이너의 동시성을 활용한 결합분리 전략은 완벽과 거리가 멀다
  - 서블릿 프로그래머는 동시성을 정확구 구현하도록 각별한 주의와 노력을 해야한다
  - 그럼에도 서블릿 모델이 제공하는 이점은 매우 크다
- 구조적 개선 뿐 아니라 응답 시간과 작업 처리량 개선을 위해 동시성을 구현하는 경우도 있다
  - 웹 사이트의 데이터를 가져와 정보를 요약하는 정보 수집기의 경우가 그 예이다
  - 한 사이트의 데이터를 수집한 후 다음 사이트의 데이터를 수집하는 경우에는 수집 시간이 늘어난다
  - 다중 스레드 알고리즘을 구현하면 한 번에 여러 사이트의 데이터를 수집할 수 있다

### 미신과 오해
1. 동시성은 항상 성능을 높여준다
   - 동시성은 떄로 성능을 높여준다
   - 대기 시간이 아주 길어 여러 스레드가 프로세스를 공유할 수 있는 경우
   - 여러 프로세서가 동시에 처리할 독립적인 계산이 충분히 많은 경우
2. 동시성을 구현해도 설계는 변하지 않는다
   - 단일 스레드 시스템과 다중 스레드 시스템은 설계가 판이하게 다르다
3. 웹 또는 EJB 컨테이너를 사용하면 동시성을 이해할 필요가 없다
   - 실제로 컨테이너가 어떻게 동작하는 지, 어떻게 동시 수정, 데드락 등과 같은 문제를 해결하는 지 이해해야 한다.

### 타당한 생각
1. 동시성은 다소 부하를 유발한다
2. 동시성은 복잡하다
3. 일반적으로 동시성 버그는 재현하기 어렵다
4. 동시성을 구현하려면 흔히 근본적인 설계 전략을 재고해야 한다

## 난관
```java
public class X {
    private int lastIdUsed;
    public int getNextId() {
        return ++lastIdUsed;
    }
}
```

인스턴스 X를 생성하고, lastIdUsed 필드를 42로 설정한 다음, 두 스레드가 인스턴스를 공유할 때 `getNextId()`를 호출하면 결과는 다음 셋 중 하나이다.
- 한 스레드는 43을 받는다. 다른 스레드는 44를 받는다. lastUsedId는 44가 된다
- 한 스레드는 44을 받는다. 다른 스레드는 43를 받는다. lastUsedId는 44가 된다
- 한 스레드는 43을 받는다. 다른 스레드는 43를 받는다. lastUsedId는 43가 된다

두 스레드가 같은 변수를 동시에 참조하면 세 번째와 같은 결과가 나올 수 있다. 두 스레드가 자바 코드 한 줄을 거쳐가는 경로는 수 없이 많은데 그 중에서 일부 경로가 잘못된 결과를 내놓기 때문이다. 경로의 개수를 답하기 위해서는 JIT 컴파일러가 바이트코드를 처리하는 방식과 자바 메모리 모델이 원자로 간주하는 최소 단위를 알아야 한다.

간단하게 위 상황에서 잠재적인 경로는 12,879에 달한다. 대다수는 올바른 결과를 내놓지만, 일부 경로가 잘못된 결과를 내놓는다.

## 동시성 방어 원칙
### 단일 책임 원칙
- SRP는 메서드/클래스/컴포넌트를 변경해야 할 이유가 하나여야 한다는 원칙이다
- 동시성 코드는 다른 코드와 분리하라
- 동시성을 구현할 때 고려해야 할 사항은 다음과 같다
  - 동시성 코드는 독자적인 개발, 변경, 조율 주기가 있다
  - 동시성 코드에는 독자적인 난관이 있다. 다른 코드에서 겪는 난관과 다르며 훨씬 어렵다
  - 잘못 구현한 동시성 코드는 별의 별 방식으로 실패한다. 주변에 있는 다른 코드가 발목을 잡지 않더라도 동시성 하나만으로 충분히 어렵다

### 따름 정리: 자료 범위를 제한하라
- 자료를 캡슐화하라. 공유 자료를 최대한 줄여라
- 객체 하나를 공유한 후 동일 필드를 수정하던 두 스레드가 서로 간섭하므로 예상치 못한 결과를 낳는다.
- `synchronized` 키워드로 임계 영역을 보호할 수 있다

### 따름 정리: 자료 사본을 이용하라
- 처음부터 공유 자료를 사용하지 않는 것이 가장 좋다
- 객체를 복사해 읽기 전용으로 사용하는 방법도 있다
- 사본으로 동기화를 피할 수 있다면, 내부 잠금을 없애 절약한 수행 시간이 사본 생성과 가비지 컬렉션에 드는 부하를 상쇄할 가능성이 크다

### 따름 정리: 스레드는 가능한 독립적으로 구현하라
- 독자적인 스레드로, 가능하면 다른 프로세서에서, 돌려도 괜찮도록 자료를 독립적인 단위로 분할하라
- 모든 정보는 비공유 출처에서 가져오며 로컬 변수에 저장하면 각 스레드는 자신만의 세상에서 돌아갈 수 있다

## 라이브러리를 이해하라
- 언어가 제공하는 클래스를 검토하라
- 자바에서는 java.util.concurrent, java.util.concurrent.atomic, java.util.concurrent.locks를 익혀라

## 실행 모델을 이해하라
### 기본 용어
- 한정된 자원(Bound Resource)
  - 다중 스레드 환경에서 사용하는 자원으로 크기나 숫자가 제한적이다. 데이터베이스 연결, 길이가 일정한 읽기/쓰기 버퍼가 예다
- 상호 배제
  - 한 번에 한 스레드만 공유 자료나 공유 자원을 사용할 수 있는 경우
- 기아
  - 하나 이상의 스레드가 오랫동안 자원을 기다리는 것
- 데드락
  - 여러 스레드가 서로 끝나기를 기다리는 것
- 라이브락
  - 락을 거는 단계에서 각 스레드가 서로 방해하는 것
  - 스레드는 계속해서 진행하려 하지만, 공명으로 인해 굉장히 오랫동안 혹은 영원히 진행하지 못한다

### [생산자-소비자](https://ko.wikipedia.org/wiki/%EC%83%9D%EC%82%B0%EC%9E%90-%EC%86%8C%EB%B9%84%EC%9E%90_%EB%AC%B8%EC%A0%9C)
### [읽기-쓰기](https://ko.wikipedia.org/wiki/%EB%8F%85%EC%9E%90-%EC%A0%80%EC%9E%90_%EB%AC%B8%EC%A0%9C)
### [식사하는 철학자들](https://ko.wikipedia.org/wiki/%EC%8B%9D%EC%82%AC%ED%95%98%EB%8A%94_%EC%B2%A0%ED%95%99%EC%9E%90%EB%93%A4_%EB%AC%B8%EC%A0%9C)

## 동기화하는 메서드 사이에 존재하는 의존성을 이해하라
- 공유 객체 하나에는 메서드 하나만 사용하라
- 여러 메서드가 필요한 경우 다음을 고려 하라
  - 클라이언트에서 잠금
    - 클라이언트에서 첫 번째 메서드를 호출하기 전에 서버를 잠근다
  - 서버에서 잠금
    - 서버에다 "서버를 잠그고 모든 메서드를 호출한 후 잠금을 해제하는" 메서드를 구현한다
  - 연결(Adapted) 서버
    - 잠금을 수행하는 중간 단계를 생성한다
    - 서버에서 잠금과 유사하지만 원래 서버는 변경하지 않는다

## 동기화하는 부분을 작게 만들어라
- 자바에서 `synchronized` 키워드를 사용하면 락을 설정한다
- 락을 설정한 구역은 한 스레드만 실행이 가능하다
- 락은 부하를 가중시키기 때문에, 임계 영역은 최소화 하는 것이 바람직하다
- 임계 영역의 개수를 줄인다고 임계영역 하나로 구현하기도 하는데, 이런 경우 스레드간 경쟁이 늘어나고 프로그램 성능이 떨어진다

## 올바른 종료 코드는 구현하기 어렵다
- 종료 코드를 개발 초기부터 고민하고 동작하게 초기부터 구현하라
  - 생각보다 어려우므로 이미 나온 알고리즘을 검토하라
- 종료 코드에서 가장 흔히 발생하는 문제는 데드락이다

## 스레드 코드 테스트하기
- 문제 상황을 노출하는 테스트 케이스를 짜라
  - 프로그램 설정과 시스템 설정과 부하를 바꿔가며 자주 돌려라
  - 테스트가 실패하면 원인을 추적하라
  - 다시 돌렸더니 통과하더라는 이유로 그냥 넘어가면 절대 안된다

### 말이 안 되는 실패는 잠정적인 스레드 문제로 취급하라
- 시스템 실패를 일회성이라 치부하지 마라
- 다중 스레드에서 실패를 재현하기는 어렵다
- 일회성 문제는 존재하지 않는다고 가정하는 편이 안전하다
- 일회성 문제를 계속 무시한다면 잘못된 코드 위에 코드가 계속 쌓인다

### 다중 스레드를 고려하지 않는 순차 코드부터 제대로 돌게 만들자
- 스레드 환경 밖에서 생기는 버그와 스레드 환경에서 생기는 버그를 동시에 디버깅하지 마라.
  - 먼저 스레드 환경 밖에서 코드를 올바로 돌려라

### 다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있게 스레드 코드를 구현하라
- 다양한 설정에서 실행할 목적으로 다른 환경에 쉽게 끼워 넣을 수 있게 코드를 구현하라
  - 한 스레드로 실행하거나, 여러 스레드로 실행하거나, 실행 중 스레드 수를 바꿔본다
  - 스레드 코드를 실제 환경이나 테스트 환경에서 돌려본다
  - 테스트 코드를 빨리 천천히 다양한 속도로 돌려 본다
  - 반복 테스트가 가능하도록 테스트 케이스를 작성한다

### 다중 스레드를 쓰는 코드 부분을 상황에 맞게 조율할 수 있게 작성하라
- 다양한 설정으로 프로그램의 성능 측정 방법을 강구한다
- 스레드 개수를 조율하기 쉽게 코드를 구현한다
- 프로그램이 돌아가는 도중 스레드 개수를 변경하는 방법도 고려한다
- 프로그램 처리율과 효율에 따라 스스로 스레드 개수를 조율하는 코드도 고민한다

### 프로세서 수보다 많은 스레드를 돌려보라
- 시스템이 스레드를 스와핑할 때도 문제가 발생한다

### 다른 플랫폼에서 돌려보라
- 운영체제마다 스레드를 처리하는 정책이 달라 결과가 달라질 수 있다

### 코드에 보조 코드를 넣어 돌려라. 강제로 실패를 일으키게 해보라
- 보조 코드를 사용해 코드가 실행되는 순서를 바꿔준다
- 각 메서드는 스레드가 실행되는 순서에 영향을 미친다
- 잘못된 코드라면 가능한 초반에 그리고 가능한 자주 실패하는 편이 좋다