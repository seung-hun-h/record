## 목차
- [냄새와 휴리스틱](#냄새와-휴리스틱)

# 냄새와 휴리스틱
## 주석
### 부적절한 정보
- 다른 시스템에 저장할 정보는 주석으로 적절하지 않다
  - 소스 코드 관리 시스템, 버그 추적 시스템, 이슈 추적 시스템 등
  - 작성자, 최종 수정일, SPR(Software Problem Report) 번호 같은 메타 정보만 주석으로 넣는다

### 쓸모없는 주석
- 오래된 주석, 엉뚱한 주석, 잘못된 주석은 더이상 필요 없다

### 중복된 주석
- 코드만으로 충분한데 구구절절 설명하는 주석이 중복된 주석이다
- 주석은 코드만으로 다하지 못하는 설명을 부언해야 한다

### 성의 없는 주석
- 작성할 가치가 있는 주석은 잘 작성할 가치도 있다
- 간결하고 명료하게 작성한다

### 주석 처리된 코드
- 주석처리된 코드는 읽는 사람을 헷갈리게 만든다
- 주석처리된 코드는 발견하면 즉각 지워라

## 환경
### 여러 단계로 빌드해야 한다
- 빌드는 간단히 한 단계로 끝나야 한다

### 여러 단계로 테스트 해야 한다
- 모든 단위 테스트틑 한 명령으로 돌려야 한다

## 함수
### 너무 많은 인수
- 함수에서 인수 개수는 작을수록 좋다

### 출력 인수
- 출력 인수는 직관을 정면으로 위배한다
- 일반적으로 독자는 인수를 입력으로 간주한다
- 함수에서 뭔가의 상태를 변경해야 한다면, 함수가 속한 객체의 상태를 변경한다

### 플래그 인수
- boolean 인수는 함수가 여러 기능을 수행한다는 명백한 증거다

### 죽은 함수
- 아무도 호출하지 않는 함수는 삭제한다

## 일반
### 한 소스 파일에 여러 언어를 사용한다
- 이상적으로는 소스 파일 하나에 언어 하나만 사용하는 방식이 좋다
- 현실적으로는 여러 언어가 불가피하다
  - 하지만 각별한 노력을 기울여 소스 파일에서 언어 수와 범위를 최대한 줄이도록 애써야 한다

### 당연한 동작을 구현하지 않는다
- 최소 놀람의 원칙(The Principle of Least Surprise)에 의거해 함수나 클래스는 다른 프로그래머가 당연하게 여길 만한 동작과 기능을 제공해야 한다
- 당연한 동작을 구현하지 않으면 코드를 읽거나 사용하는 사람이 더 이상 함수 이름만으로 함수 기능을 직관적으로 예상하기 어렵다

### 경계를 올바로 처리하지 않는다
- 모든 경계 조건을 찾아내고, 모든 경계 조건을 테스트하는 테스트 케이스를 작성하라
- 부지런함을 대신할 지름길은 없다.

### 안전 절차 무시
- 실패하는 테스트 케이스를 일단 제껴두고 나중으로 미루는 태도는 신용카드가 공짜 돈이라는 생각만큼 위험하다

### 중복
- DRY(Don't Repeat Yourself)는 소프트웨어의 가장 중요한 원칙 중 하나이다
- 코드에서 중복을 발견할 때마다 추상화할 기회로 간주하라
  - 중복된 코드를 하위 루틴이나 다른 클래스로 분리하라
- switch/case나 if/else 문으로 똑같은 조건을 거듭 확인하는 중복은 다형성으로 대체할 수 있다
- 알고리즘이 유사하나 코드가 다른 중복은 TEMPLATE METHOD 패턴이나 STRATEGY 패턴으로 중복을 제거한다

### 추상화 수준이 올바르지 못하다
- 추상화는 저차원 상세 개념에서 고차원 일반 개념을 분리한다
- 추상화로 개념을 분리할 떄는 철저해야 한다
  - 모든 저차원 개념은 파생 클래스로 넣고, 모든 고차원 개념은 기초 클래스에 넣는다

### 기초 클래스가 파생 클래스에 의존한다
- 기초 클래스가 파생 클래스를 사용한다면 문제가 있는 것이다

### 과도한 정보
- 잘 정의된 모듈은 인터페이스가 아주 작다
- 따라서 결합도가 낮다
- 우수한 소프트웨어 개발자는 클래스나 모듈 인터페이스에 노출할 함수를 제한할 줄 알아야 한다
- 자료, 유틸리티 함수, 상수, 임시 변수를 숨겨라

### 선택자 인수
- 일반적으로, 인수를 넘겨 동작을 선택하는 대신 새로운 함수를 만드는 편이 좋다

### 모호한 의도
- 코드를 짤 때는 의도를 최대한 분명히 밝힌다

### 잘못 지운 책임
- 코드는 독자가 자연스럽게 기대할 위치에 배치한다

### 부적절한 static 함수
- `Math.max()`는 좋은 static 메서드다. 특정 인스턴스와 관련된 기능이 아니기 떄문이다.
  - `max()`가 사용하는 인수 정보는 두 수가 전부이며, 메서드를 소유하는 객체에서 가져오는 정보가 아니다
  - 결정적으로 `Math.max()`를 재정의할 가능성의 거의 없다
- 일반적으로 static 함수 보다 인스턴스 함수가 더 좋다.
  - 조금이라도 의심스럽다면 인스턴스 함수로 정의한다.

### 서술적 변수
- 프로그램 가독성을 높이는 가장 효과적인 방법 중 하나가 계산을 여러 단계로 나누고 중간 값으로 서술적인 변수 이름을 사용하는 방벙이다
- 서술적인 변수 이름은 많이 써도 괜찮다

### 이름과 기능이 일치하는 함수
- 이름만으로 분명하지 않기에 구현을 살피거나 문서를 뒤적여야 한다면, 더 좋은 이름으로 바꾸거나 아니면 더 좋은 이름을 붙이기 쉽도록 기능을 정리해야 한다.

### 알고리즘을 이해하라
- 대다수 괴상한 코드는 사람들이 알고리즘을 충분히 이해하지 않은 채 코드를 구현한 탓이다.
- 구현이 끝났다고 선언하기 전에 함수가 돌아가는 방식을 확실히 이해하는 지 확인하라
- 테스트 케이스를 모두 통과했다는 사실 자체는 부족하고, 작성자가 알고리즘이 올바르다는 사실을 알아야 한다.

### 논리적 의존성은 물리적으로 드러내라
- 한 모듈이 다른 모듈에 의존한다면 물리적인 의존성도 있어야 한다
- 의존하는 모듈이 상대 모듈에 대해 뭔가를 가정하면 안 된다
  - 의존하는 모든 정보를 명시적으로 요청하는 편이 좋다

### if/else 혹은 switch/case 문보다 다형성을 이용하라
- 대다수의 개발자가 switch 문을 사용하는 이유는 당장 가장 손쉬운 선택이기 때문이다
  - 그러므로 switch를 선택하기 전에 다형성을 먼저 고려하라는 의미다
- 유형보다 함수가 더 쉽게 변하는 경우는 극히 드물다
  - 함수가 더 쉽게 변하는 경우는 switch문을 사용해도 좋다
  - 일단 모든 switch문은 의심하라

### 표준 표기법을 따르라
- 팀은 업계 표준에 기반한 구현 표준을 따라야 한다
  - 표준을 설명하는 문서는 코드 자체로 충분해야 하며 별도 문서를 만들 필요는 없어야 한다
- 팀이 정한 표준은 팀원들 모두가 따라야 한다
  - 괄호를 넣는 위치가 중요한 것이 아니라 팀원 모두가 동의한 위치에 넣는다는 사실이 중요하다

### 매직 숫자는 명명된 상수로 교체하라
- 일반적으로 코드에서 숫자를 사용하지 말고, 숫자는 명명된 상수 뒤로 숨기라는 의미다
- 매직 숫자는 숫자에만 국한되는 것이 아니라, 의미가 분명하지 않는 토큰 모두를 가리킨다

### 정확하라
- 코드에서 뭔가를 결정할 때는 정확히 결정한다
- 결정을 내리는 이유와 예외를 처리할 방법을 분명히 알아야 한다

### 관례보다 구조를 사용하라
- 설계 결정을 강제할 때는 규칙보다 관례를 사용한다
- 명명 관례도 좋지만 구조 자체로 가제하면 더 좋다

### 조건을 캡슐화하라
- 조건의 의도를 분명히 밝히는 함수로 표현하라

### 부정 조건은 피하라
- 부정 조건은 긍정 조건보다 이해하기 어렵다

### 함수는 한 가지만 해야 한다
- 함수를 짜다보면 한 함수 안에 여러 단락을 이어, 일련의 작업을 수행하고픈 유혹에 빠진다
- 이런 함수는 한 가지만 수행하는 함수가 아니다.
- 한 가지만 수행하는 좀 더 작인 함수 여럿으로 나눠야 마땅하다

### 숨겨진 시간적 결합
- 때로는 시간적 결합이 필요하다. 하지만 시간적 결합을 숨겨서는 안된다
- 함수 인수를 적절히 배치해 함수가 호출되는 순서를 명백히 드러내야 한다

```java
public class MoogDriver {
    Gradient gradient;
    List<Spline> splines;

    public void dive(String reason) {
        saturateGradient();
        reticulateSplines();
        diveForMoog(reason);
    }
}
```
- 위 코드보다 아래 코드가 더 좋다.

```java
public class MoogDriver {
    Gradient gradient;
    List<Spline> splines;

    public void dive(String reason) {
        Gradient gradient = saturateGradient();
        List<Spline> splines = reticulateSplines(gradient);
        diveForMoog(splines, reason);
    }
}
```

### 일관성을 유지하라
- 코드 구조를 잡을 때는 이유를 고민하고, 그 이유를 코드 구조로 명백히 표현하라


### 경계 조건을 캡슐화하라
- 경계 조건은 한 곳에서 별도로 처리한다
- 다시 말해 코드 여기저기에 +1이나 -1을 흩어놓지 않는다

### 함수는 추상화 수준을 한 단계만 내려가야 한다
- 함수 내 모든 문장은 추상화 수준이 동일해야 한다
  - 추상화 수준은 함수 이름이 의미하는 작업보다 한 단계만 낮아야 한다

### 설정 정보는 최상위 단계에 둬라
- 추상화 최상위 단계에 둬야 할 기본값 상수나 설정 관련 상수를 저차원 함수에 숨겨서는 안된다
- 설정 관련 상수는 최상위 단계에 둬야 한다
  - 그래야 변경하기도 쉽다

### 추이적 탐색을 피하라
- 일반적으로 한 모듈은 주변 모듈을 모를수록 좋다
  - 이를 디미터 법칙이라 한다
- 내가 아는 모듈이 연이어서 자신이 아는 모듈을 따라가며 전체를 휘저을 필요가 없다는 의미다
- 내가 사용하는 모듈이 내게 필요한 서비스를 모두 제공해야 한다

## 자바
### 긴 import 목록을 피하고 와일드카드를 사용하라
- 명시적인 import문은 강한 의존성을 생성하지만 와일드카드는 그렇지 않다
- 와일드카드로 패키지를 지정하면 특정 클래스가 존재할 필요가 없다
  - 명시적으로 클래스를 import하면 그 클래스가 반드시 존재해야 한다
- 명시적으로 import 문을 길게 나열해야 하는 경우도 있다
- 와일드카드 import 문은 때로 이름 충돌이나 모호성을 초래한다
  - 이름이 같으나 패키지가 다른 클래스는 명시적은 import문을 사용하거나, 코드에서 클래스를 사용할 때 전체 경로를 명시한다
  - 다소 번거롭지만 자주 발생하지 않으므로 여전이 와일드카드 import 문이 명시적인 import 문 보다 좋다

### 상수는 상속하지 않는다
- 상수를 최상위 계층에서부터 상속하지 말고 static import하는 것이 좋다

### 상수 대 Enum
- Enum은 이름이 부여된 열거체이다
- 마음껏 사용하라

## 이름
### 서술적인 이름을 사용하라
- 이름을 성급하게 결정하지 말고 서술적인 이름을 신중하게 고른다

### 적절한 추상화 수준에서 이름을 선택하라
- 구현을 드러내는 이름은 피하라

### 가능하다면 표준 명명법을 사용하라
- 기존 명명법을 사용하는 이름은 이해하기 쉽다
  - DECORATOR 패턴을 사용한다면 장식하는 클래스 이름에 Decorator라는 단어를 사용한다
- 프로젝트에 유효한 의미가 담긴 이름을 많이 사용할수록 독자가 코드를 이해하기 쉬워진다

### 명확한 이름
- 함수나 변수의 목적을 명확히 밝히는 이름을 선택한다

### 긴 범위는 긴 이름을 사용하라
- 이름 길이는 범위 길이에 비례해야 한다

### 인코딩을 피하라
- 이름에 유형 정보나 범위 정보를 넣어서는 안된다

### 이름으로 부수 효과를 설명하라
- 함수, 변수, 클래스가 하는 일을 모두 기술하는 이름을 사용한다

## 테스트
### 불충분한 테스트
- 테스트 케이스는 잠재적으로 깨질 만한 부분을 모두 테스트해야 한다

### 커버리지 도구를 사용하라
- 커버리지 도구는 테스트가 빠뜨리는 공백을 알려준다
- 커버리지 도구를 사용하면 테스트가 불충분한 모듈, 클래스, 함수를 찾기가 쉬워진다

### 사소한 테스트를 건너뛰지 마라
- 사소한 테스트는 짜기 쉽다
- 사소한 테스트가 제공하는 문서적 가치는 구현에 드는 비용을 넘어선다

### 무시한 테스트는 모호함을 뜻한다
- 불분명한 요구사항은 테스트 케이스를 주석으로 처리하거나 테스트 케이스에 @Ignore를 붙여 표현한다

### 경계 조건을 테스트하라
- 경계 조건은 각별히 신경 써서 테스트한다

### 버그 주변은 철저히 테스트하라
- 버그는 서로 모이는 경향이 있다.

### 실패 패턴을 살펴라
- 때로는 테스트 케이스가 실패하는 패턴으로 문제를 진단할 수 있다

### 테스트 커버리지 패턴을 살펴라
- 통과하는 테스트가 실행하거나 실행하지 않는 코드를 살펴보면 실패하는 테스트 케이스의 실패 원인이 드러난다

### 테스트는 빨라야 한다
- 느린 테스트는 실행하지 않는다. 테스트는 빨라야 한다.