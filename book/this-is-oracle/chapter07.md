# 7.  PL/SQL 고급
## 7.1 Oracle 데이터 형식
### 7.1.1 Oracle에서 지원하는 데이터 형식 종류
**숫자 데이터**
- NUMBER(p, [s])
	- 전체 자릿수(p)와 소숫점 이하 자릿수(s)를 가진 숫자형
	- 바이트 수 : 5 - 21
	- 숫자 범위 : p = 1 - 38, s = 84, 127

**문자 데이터**

| Type         | Bytes      | Description                                                               |
| ------------ | ---------- | ------------------------------------------------------------------------- |
| CHAR[(n)]    | 1 - 2,000  | 고정길이 문자형                                                           |
| NCHAR[(n)]   | 2 - 2,000  | 유니코드 고정길이 문저형. 한글을 저장할 수 있어 한 글자당 2Bytes가 사용됨 |
| VARCHAR2(n)  | 1 - 4,000  | 가변길이 문자형                                                           |
| NVARCHAR2(n) | 2 - 4,000  | 유니코드 가변길이 문자형. 한글을 저장할 수 있어 한 글자당 2Bytes가 사용됨 |
| CLOB         | 최대 128TB | 대용량 텍스트의 데이터 타입                                               |
| NCLOB        | 최대 128TB | 대용량 텍스트의 유니코드 데이터 타입                                      |

- CHAR, NCHAR는 고정길이 문자형으로 자릿수가 고정되어 있다
	- CHAR(100)에 3 글자를 저장해도 100자리를 모두 확보한 후에 앞에 3자리를 사용하고 뒤의 97자리를 낭비하게되는 결과가 나온다
- VARCHAR2, NVARCHAR2는 가변길이 문자형이다
	- VARCHAR2(100)에 3 글자를 저장하면 3자리만 사용하게 된다
- CHAR을 사용하는 것이 일반적으로 INSERT/UPDATE 시에 더 좋은 성능을 발휘한다

**이진 데이터 형식**
| Type | Bytes      | Description                                     |
| ---- | ---------- | ----------------------------------------------- |
| BLOB | 최대 128TB | 대용량 이진 데이터를 저장할 수 있는 데이터 타입 |
- BLOB은 주로 이미지, 동영상, 음악, 지도 데이터 등을 저장하기 위한 데이터형식이다
- BLOB은 파일을 Oracle 내부에 저장하지만, BFILE은 운영체제에 파일 형태로 저장하고 파일의 위치만 Oracle 내부에 저장된다

**날자 데이터 형식**
| Type      | Bytes | Description                                                                                       |
| --------- | ----- | ------------------------------------------------------------------------------------------------- |
| DATE      | 7     | 날짜는 기원전 4712년 1월 1일부터 9999년 12월 31일까지 저장된다. 연, 월, 일, 시, 분, 초가 저장된다 |
| TIMESTAMP | 11    | DATE와 같으나 밀리초까지 저장된다                                                                 |

**기타 데이터 형식**
| Type  | Bytes | Description                                                                              |
| ----- | ----- | ---------------------------------------------------------------------------------------- |
| RAWID | 10    | 행의 물리적인 주소를 저장하기 위한 데이터 형식으로 모든 행에 자동으로 RAWID열이 생성된다 |

**유니 코드 데이터**
- 여러 언어를 처리하는 경우 NCHAR, NVARCHAR2, NCLOB 형식을 사용하는 것이 좋다
- 유니코드 문자 저장 시에는 내부적으로 더 넓은 공간이 필요하다. CHAR(4)는 4바이트지만, NCHAR(4)는 8바이트를 내부적으로 차지한다
- 유니코드는 문자에만 해당하는 이야기이며, 숫자/날짜는 상관할 것이 없다

### 7.1.2 변수의 사용
```SQL
DECLARE
	변수이름1 데이터형식1;
	변수이름2 데이터형식2;
BEGIN
	변수이름 := 값;
	SELECT 열 이름 INTO 변수이름2 FROM 테이블;
END;
```

### 7.1.3 데이터 형식과 형 변환
**데이터 형식 변환 함수**
- CAST
- TO_CHAR
- TO_NUMBER
- TO_DATE

### 7.1.4 Oracle 내장 함수
**문자열 함수**
- ASCII(영문자), CHR(숫자), ASCIISTR(한글), UNISTR(유니코드값)
	- ASCII는 한 문자의 아스키 코드 값을 반환한다
	- CHR는 숫자의 아스키 코드 값에 해당하는 문자를 반환한다
	- ASCIISTR은 유니코드를 입력하면 해당하는 유니코드 값을 16진수로 반환한다
- LENGTH(문자열), LENGTHB(문자열)
	- LENGTH는 문자열의 길이, LENGTHB는 문자열의 바이트 수를 반환한다
- CONCAT(문자열1, 문자열2) 또는 ||
	- 문자열을 이어준다
- INSTR(기준 문자열, 부분 문자열, 찾을 시작 위치), INSTRB(기준 문자열, 부분 문자열, 찾을 시작 위치)
	- 기준 문자열에서 부분 문자열을 찾아서 문자열이 시작하는 위치를 반환한다
- LOWER(문자열), UPPER(문자열), INITCAP(문자열)
	- INITCAP은 첫 글자를 모두 대문자로 변환한다
- REPLACE(문자열, 원래 문자열, 바꿀 문자열)
- TRANSLATE(문자열, 원래 문자열, 바꿀 문자열)
	- 한 글자씩 찾아서 변환해준다
	- 아래 쿼리의 결과는 `ABA OracleA다`
```SQL
SELECT TRANSLATE('이것이 Oracle이다', '이것', 'AB') FROM dual;
```
- SUBSTR(문자열, 시작_위치, 길이)
- REVERSE(문자열)
- LPAD(문자열, 길이, 채울 문자열), RPAD(문자열, 길이, 채울 문자열)
	- 문자열을 길이만큼 늘린 후에, 빈 곳을 채울 문자열로 채운다
	- 길이는 Byte 단위로 크기를 지정해야 한다
- LTRIM(문자열, 제거할 문자), RTRIM(문자열, 제거할 문자)
	- 문자열 왼쪽/오른쪽의 제거할 문자를 제거한다
	- 중간 문자는 제거되지 않는다
	- 제거할 문자를 생략하면 공백을 제거한다
- TRIM(제거할_방향 제거할_문자 FROM 문자열)
	- TRIM(문자열)만 사용함현 앞뒤 공백을 제거한다
- REGEXP_COUNT(문자열, 문자)
	- 문자열에서 문자의 개수를 센다

**숫자 및 수학 함수**
- ABS(숫자)
- ACOS(숫자), ASIN(숫자), ATAN(숫자), ATAN2(숫자1, 숫자2), SIN(숫자), COS(숫자), TAN(숫자)
- CEIL(숫자), FLOOR(숫자), ROUND(숫자)
- EXP(숫자), LN(숫자), LOG(밑수, 숫자)
- MOD(숫자1, 숫자2)
	- 숫자1을 숫자2로 나눈 나머지를 구한다
- POWER(숫자1, 숫자2), SQRT(숫자)
- SIGN(숫자)
	- 숫자가 양수인지 음수인지 반환한다
	- -1, 0, 1만 반환한다
- TRUNC(숫자)
	- 숫자를 소수점을 기준으로 정수 위치까지 구하고 버린다

**날짜 및 시간 함수**
- ADD_MONTHS(날짜, 개월) 와 +/=
	- ADD_MONTHS는 날짜를 기준으로 개월으 더하거나 뺸 결과를 반환한다
	- 일자를 더하려면 +를 사용한다
- CURRENT_DATE, SYSDATE, CURRENT_TIMESTAMP
- EXTRACT(형식 FROM DATE '날짜')
	- 날짜에서 연, 월, 시, 분, 초를 구한다
	- YEAR, MONTH, DAY, HOUR, MINUTE, SECOND
- LAST_DAY(날짜)
	- 주어진 날짜의 마지막 날짜를 구한다
- NEXT_DAY(날짜, 요일)
	- 주어진 날짜의 다음에 오는 요일의 날짜를 구한다
- MONTHS_BETWEEN(날짜1, 날짜2)
	- 두 날짜 사이의 개월 수를 계산해서 소수점 단위까지 반환한다

**형 변환 함수**
- BIN_TO_NUM(2진수)
	- 주어진 2진수를 10진수로 변환한다
	- 2진수 숫자는 콤마로 구분해서 입력한다
- NUMTODSINTERVAL(숫자, '표현식')
	- 숫자가 며칠에 해당하는지 반환한다
- NUMTOYMINTERVAL(숫자 , '표현식')
	- 숫자가 몇 년 몇 개월에 해당하는지 반환한다

**분석/순위함수**
- RANK()
- NTILE()
- DENSE_RANK()
- ROW_NUMBER()

**피벗의 구현**
- 피벗은 한 열에 포함된 여러 값을 출력하고, 이를 여러 열로 변환하여 테이블 반환식을 회전하고 필요하면 집계까지 수행하는 것을 말한다

```SQL
SELECT *
FROM pivotTest
PIVOT (
	SUM(amount)
	FOR season
	IN ('봄', '여름', '가을', '겨울')
);
```

## 7.2 조인
- 조인이란 두 개 이상의 테이블을 서로 묶어서 하나의 결과 집합으로 만들어 내는 것을 의미한다
- 가장 많이 사용되는 보편적인 관계가 '1대다' 관계이다
	- '1대다' 관계란 한 쪽 테이블에는 하나의 값만 존재해야 하지만, 다른 쪽 테이블에는 여러 개가 존재할 수 있는 관계를 의미한다

### 7.2.1 INNER JOIN(내부 조인)
- 내부 조인은 조인 중에서 가장 많이 사용되는 조인이다
- 일반적으로 조인이라고 하면 내부 조인을 말하는 것이다

```SQL
SELECT <열 목록>
FROM <첫 번째 테이블>
	INNER JOIN <두 번째 테이블>
	ON <조인 조건>
[WHERE 검색 조건]
```

- 사용자 테이블 user, 구매 테이블 buy이 있을 때 JYP라는 이름을 가진 사람이 구매한 물건을 발송하기 위해 이름/주소/연락처를 구하는 경우

```SQL
SELECT *
FROM buy
	INNER JOIN user
		ON buy.userID = user.userID
WHERE buy.userID = 'JYP';
```

- 'INNER JOIN'을 명시하지 않고 아래와 같이 작성할 수 있지만, 호환성과 같은 문제로 권장하지 않는 방법이다

```SQL
SELECT *
FROM buy, user
WHERE buy.userID = 'JYP' AND buy.userID = user.userID;
```

**세 개의 테이블 조인**
- 한 학생이 여러 개의 동아리에 가입할 수 있고, 동아리에는 여러 학생이 가입할 수 있기 때문에 '다대다' 관계이다
- 다대다 관계는 논리적으로는 구성이 가능하지만, 물리적으로 구성할 떄는 두 테이블 사이에 연결 테이블을 둬서 이 연결 테이블과 두 테이블이 일대다 관계를 맺도록 해야 한다

```text
std(1) ----- (다)stdClub(다) ----- (1)club
```

- 학생을 기준으로 학생 이름/지역/가입한 동아리/동아리 이름 출력
```SQL
SELECT S.stdName, S.addr, C.clubName, C.roomNo
FROM std s
	INNER JOIN stdClub sc
		ON s.stdName = sc.stdName
	INNER JOIN club c
		ON sc.clubName = c.clubName
ORDER BY s.stdName;
```

### 7.2.2 OUTER JOIN(외부 조인)
- 조인의 조건에 맞지 않는 행까지도 포함하는 것을 말한다
- LEFT OUTER JOIN은 LEFT JOIN로 사용할 수 있고 왼쪽 테이블의 것은 모두 출력된다
- RIGHT OUTER JOIN은 RIGHT JOIN으로 사용할 수 있고 오른쪽 테이블의 것은 모두 출력된다
- FULL OUTER JOIN은 FULL JOIN으로 사용할 수 있고 LEFT OUTER JOIN, RIGHT OUTER JOIN이 합쳐진 것이라고 볼 수 있다

```SQL
SELECT <열 목록>
FROM <첫 번째 테이블<LEFT 테이블>>
<LEFT | RIGHT | FULL> OUTER JOIN <두 번째 테이블<RIGHT 테이블>>
	ON <조인 조건>
[WHERE <검색 조건>];
```

### 7.2.3 CROSS JOIN(상호 조인)
- 상호 조인은 한쪽 테이블의 모든 행들과 다른 쪽 테이블의 모든 행을 조인시키는 기능을 말한다
- 두 테이블의 행의 개수를 곱한 개수가 반환된다
- 카티션 곱이라고도 한다

### 7.2.4 SELF JOIN(자체 조인)
- 자체 조인은 별도의 구문이 있는 것이 아니라 자기 자신과 자기 자신이 조인한다는 의미다
- 하나의 테이블에 같은 데이터가 존재하되 의미가 다르게 존재하는 경우에는 두 테이블을 서로 SELF JOIN시켜서 정보를 확인할 수 있다

### 7.2.5 UNOIN / UNION ALL / NOT IN / IN
- UNOIN은 두 쿼리의 결과를 행으로 합치는 것을 말한다
```SQL
SELECT 문장1
	UNOIN [ALL]
SELECT 문장2
```
- SELECT 문장1과 SELECT 문장2의 결과 열의 개수가 같아야 하고, 데이터 형식도 각 열 단위로 같거나 서로 호환되는 데이터 형식이여야 한다
- UNION만 사용하면 중복된 열을 제거가 되고 데이터가 정렬되어 나오며, UNION ALL을 사용하면 중복된 열까지 모두 출력된다

- NOT IN은 첫 번째 쿼리의 결과 중에서 두 번째 쿼리에 해당하는 것을 제외하기 위한 구문이다
- IN은 NOT IN과 반대로 첫 번째 쿼리 결과 중에서 두 번째 쿼리에 해당하는 것을 포함하기 위한 구문이다

## 7.3 PL/SQL 프로그래밍
- 생략
