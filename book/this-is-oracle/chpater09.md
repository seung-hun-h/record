# 9. 인덱스
## 9.1 인덱스의 개념
- 인덱스는 데이터를 좀 더 빠르게 찾을 수 있도록 해주는 도구다
- 인덱스의 장점
	- 검색 속도가 매우 빨라질 수 있다
	- 해당 쿼리에 대한 부하가 줄어서 전체 시스템의 성능이 향상된다
- 인덱스의 단점
	- 추가적인 공간을 필요로 한다. 대략 데이터베이스 크기의 10%정도를 차지한다
	- 처음 인덱스를 생성하는데 시간이 많이 걸릴 수 있다
	- 데이터의 변경 작업이 많이 발생할 경우 오히려 성능이 나빠질 수 있다

## 9.2 인덱스의 종류와 자동 생성
### 9.2.1 Oracle에서 사용되는 인덱스의 종류
- B-TREE 인덱스
	- 가장 일반적인 인덱스
	- 주로 OLTP 데이터베이스에서 사용된다
- BITMAP 인덱스
	- OLAP 데이터베이스에서 사용된다
- 함수 기반 인덱스
- 어플리케이션 도메인 인덱스

### 9.2.2 자동으로 생성되는 인덱스
- 인덱스는 테이블의 열 단위에 생성된다
	- 하나 이상의 열에 인덱스를 생성할 수 있다
- 테이블 생성 시 PRIMARY KEY, UNIQUE를 사용하면 자동으로 인덱스가 생성된다

## 9.3 인덱스의 내부 작동
### 9.3.1 B-Tree(Balanced Tree. 균형 트리)
- B-Tree는 균형 잡힌 트리이다
- 노드란 트리 구조에서 데이터가 존재하는 공간을 말한다
- 루트 노드란 노드의 가장 상위 노드를 말한다
- 리프 노드는 제일 마지막에 존재하는 노드를 말한다
- 중간 노드는 루트 노드와 리프 노드 사이에 있는 노드를 말한다
- Oracle이 B-Tree를 사용할 때 이 노드에 해당하는 것이 블록이다
	- 블록은 8Kbyte의 크기를 가진다
	- 아무리 작은 데이터를 저장하더라도 8Kbyte를 차지하게 된다
- 모든 데이터는 정렬되어 있으므로 빠르게 대상 데이터의 위치를 찾을 수 있다

### 9.3.2 인덱스 분할
- 인덱스를 구성하면 데이터 변경 작업(INSERT, UPDATE, DELETE) 시에 성능이 나빠지는 단점이 있다
- 특히 INSERT 작업이 일어날때 성능이 느려질 수 있는데, 이는 인덱스 분할이라는 작업이 발생되기 떄문이다
- INSERT가 일어나면 리프 노드의 빈 블록에 데이터를 저장한다
- 리프 노프에 빈 블록이 없다면 새로운 노드를 확보하고 데이터를 적절히 나누게 된다
- 인덱스 분할로 인해 인덱스를 사용하는 경우 오히려 성능이 나빠질 수 있다

### 9.3.3 B-Tree 인덱스의 구조
- 인덱스의 특징
	- 인덱스 생성 시에는 데이터 블록은 그냥 둔 상태에서 별도의 블록에 인덱스를 구성한다
	- 인덱스의 리프 블록은 데이터가 아니라 데이터가 위치하는 주소값(ROWID)이다
	- 데이터의 입력/수정/삭제 시에는 인덱스가 없을 때보다 느리다
	- 인덱스는 여러 개 생성할 수 있다. 하지만 함부로 남용하는 경우 오히려 시스템의 성능을 떨어뜨리는 결과를 초래할 수 있어 꼭 필요한 열에만 생성하는 것이 좋다
	- 인덱스를 검색하기 위한 일차 조건은 WHERE절에 해당 인덱스를 생성한 열의 이름이 나와야 한다

## 9.4 인덱스 생성/변경/삭제
### 9.4.1 인덱스 생성
- 생성 구문 생략
- 인덱스는 정렬 방식을 선택할 수 있다
	- ASC가 기본 값이며 오름차순으로 정렬되어서 인덱스가 생성된다

### 9.4.2 인덱스 제거
```SQL
DROP INDEX 인덱스이름;
```

## 9.5 인덱스의 성능 비교
- SELECT 문을 수행하면 Oracle의 옵티마이저가 SELECT를 분석한 후 어떻게 처리하는 것이 효율적일 지 계획을 세운 후에 SELECT를 수행한다
- 따라서 테이블에 인덱스가 있다 하더라도 전체 테이블 검색이 더 효율적이라고 판단하는 경우 인덱스를 무시하고 전체 테이블을 탐색한다
- 옵티마이저의 작동을 하지 않고 직접 처리 방법을 지정하는 것을 힌트라고 한다

```SQL
SELECT /*+ 힌트 */ 열 이름 FROM ~~
SELECT --+ 힌트 열 이름 FROM ~~
```

- 전체 데이터 중 적정 수량 이상을 스캔하는 경우에는 Oracle이 인덱스를 사용하지 않고 테이블 검색을 실시한다
	- 대략 5% 이상을 조회할 때는 인덱스를 사용하지 않는다

**인덱스를 사용해야 하는데 쿼리를 잘못 작성한 경우**
- 인덱스가 생성된 열에 함수나 연산을 가하면 인덱스를 사용하지 못할 수가 있으니 조심해야 한다
- Oracle이 많이 향상되어 그렇지 않은 경우도 있지만 최대한 인덱스 열을 가공하지 말아야 한다

**카디날리티가 높아 인덱스를 사용하지 않는 경우**
- 성별처럼 데이터의 카디날리티(중복도)가 높으면 인덱스가 있어도 인덱스를 사용하지 않는다
- 따라서 카디날리티가 높은 열은 인덱스를 사용하지 않는 것이 좋다

## 9.6 결론: 인덱스를 생성해야 하는 경우와 그렇지 않은 경우
- 인덱스를 만드는 절대 기준은 존재하지 않는다
	- 테이블의 데이터 구성이 어떻게 되었는지, 어떠한 조회를 많이 사용하는지에 따라 인덱스를 생성해야 한다
- 기억해야할 것들
	- 인덱스는 열 단위에 생성된다
	- WHERE 절에 사용되는 열에 인덱스를 만들어야 한다
	- WHERE 절에 사용되더라도 자주 사용해야 가치가 있다
	- 데이터의 중복도가 높은 열은 인덱스를 만들어도 별 가치가 없다
	- JOIN에 자주 사용되는 열에는 인덱스를 생성 해주는 것이 좋다
	- INSERT/UPDATE/DELETE가 얼마나 자주 일어나는 지를 고려해야 한다
	- 사용하지 않는 인덱스는 제거하자