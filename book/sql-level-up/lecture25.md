# 25강 시퀀스 객체, IDENTITY 필드, 채번 테이블
---
- 표준 SQL에는 순번을 다루는 기능으로 시퀀셜 객체와 IDENTITY 필드가 존재한다
- 이들 기능은 **최대한 사용하지 않는** 것이 좋다
- 꼭 사용할 수 밖에 없다면 IDENTITY 필드 보다는 **시퀀셜 객체**를 사용하는 것이 좋다

## 1. 시퀀스 객체
**시퀀스 객체 정의 예**
```SQL
CREATE SEQUENCE testseq
START WITH 1
INCREMENT BY 1
MAXVALUE 100000
MINVALUE 1
CYCLE;
```

- 이 기능이 가장 자주 사용되는 장소는 바로 INSERT 구문 내부이다
- 시퀀스 객체로 만들어진 순번을 기본 키로 사용해 레코드를 INSERT 하는 것이다

```SQL
INSERT INTO HogeTbl VALUES(NEXT VALUE FOR nextval, 'a', 'b', ...);
```

### 시퀀스 객체의 문제점
1. 표준화가 늦어서 구현에 따라 구문이 달라 이식성이 없고 사용할 수 없는 구현도 있다
2. 시스템에서 자동으로 생성되는 값이므로 실제 엔티티 속성이 아니다
3. 성능적인 문제를 일으킨다

### 시퀀스 객체로 발생하는 성능문제
- 시퀀스 객체가 생성하는 순번의 기본적인 특성 3가지
	- 유일성
	- 연속성
	- 순서성
- 시퀀스 객체는 기본적으로 세 가지 특성을 만족하는 순번을 생성한다. 따라서 동시 실행 제어를 위해 락 메커니즘이 필요하다
- 사용자 A가 시퀀스 객체에서 NEXT VALUE를 검색할 때의 처리를 간단하게 나타내면 다음과 같다
	1. 시퀀스 객체에 배타 락을 적용
	2. NEXT VALUE를 검색
	3. CURRENT VALUE를 1만큼 증가
	4. 시퀀스 객체에 배타 락을 해제
- 여러 사용자가 시퀀스 객체에 접근하는 경우 락 충돌로 성능 저하 문제가 발생할 수 있고, 1 - 4의 단계를 반복하므로 오버헤드가 발생할 수 있다

### 시퀀스 객체로 발생하는 성능 문제의 대처
- 성능 문제를 해결하기 위해 CACHE, NOORDER 객체를 사용할 수도 있다
- CACHE는 새로운 값이 필요할 떄마다 메모리에 읽어들일 필요가 있는 값의 수를 설정하는 옵션이다
	- 이 값을 크게하면 접근 비용을 줄일 수 있다
	- 시스템에 장애가 발생하는 경우 연속성을 보장할 수 없다
- NOORDER 옵션은 순서성을 담보하지 않아서 오버 헤드를 줄이는 효과가 있다
	- 순서성을 담보하고 싶은 경우에는 사용할 수 없다
- 연속성 또는 순서성을 사용하지 않아도 되는 상황이면 CACHE, NOORDER를 채택해서 성능을 개선할 수 있다

### 순번을 키로 사용할 때의 성능 문제
- 순번처럼 비슷한 데이터를 연속으로 INSERT하면 물리적으로 같은 영역에 저장된다
	- 이떄 저장소의 특정 물리적 블록에만 I/O 부하가 커지므로 성능 악화가 발생한다(?)
	- 부하가 몰리는 부분을 핫 스팟, 핫 블록이라 한다
- 이러한 문제는 대처하기가 거의 불가능 하다

### 순번을 키로 사용할 때의 성능 문제 대처
- Oracle의 역 키 인덱스처럼, 연속된 값을 도입하는 경우라도 DBMS 내부에서 변화를 주어 제대로 분산할 수 있는 구조(일종의 해시)를 사용한다	
- 인덱스에 일부러 복잡한 필드를 추가해서 데이터의 분산도를 높인다
- INSERT 구문 자체는 빨리지지만, 범위 검색 등에서 I/O양이 늘어나 SELECT 구문의 성능이 나빠질 위험이 있다
- 구현에 의존적인 방법이라 다른 엔지니어가 설계를 이해하기 어려울 수 있다

## 2. IDENTITY 필드
---
- 자동 순번 필드라고도 한다
- INSERT가 발생할 때마다 자동으로 순번을 붙여주는 기능이다
- IDENTITY 필드는 특정한 테이블과 연결된다. 성능적으로 시퀀스처럼 NOORDER, CACHE를 사용할 수 없다

### 3. 채번 테이블
---
- IDENTITY나 시퀀스 객체를 사용할 수 없을 때 순번을 부여해주기 위해 사용했던 방법이다
- 현재 시점에서 설계하는 시스템이라면 사용할 이유가 전혀없다
- 바틀 넥이 걸려도 튜닝할 수 있는 방법이 전혀 없으므로 기도해야 한다
