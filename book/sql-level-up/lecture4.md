# 4강 실행 계획이 SQL 구문의 성능을 결정
- 데이터 양이 많은 테이블에 접근하거나 복잡한 SQL 구문을 실행하면 반응 지연이 발생하는 경우가 있다
	- 통계 정보가 부족한 경우
	- 이미 최적의 경로가 설정되었는데도 느린 경우
	- SQL 구문이 복잡해 옵티마이저가 최적의 경로를 선택하지 못한 경우

## 1. 실행 계획 확인 방법
| 이름          | 명령어                                 |
| ------------- | -------------------------------------- |
| Oracle        | set autotrace traceonly                |
| MS SQL Server | SET SHOWPLAN_TEXT ON                   |
| DB2           | EXPLAIN ALL WITH SNAPSHOT FOR SQL 구문 |
| PostgreSQL    | EXPLAIN SQL 구문                       |
| MySQL         | EXPLAIN EXTENDED SQL 구문              |

- 대부분의 DBMS의 실행 계획에 포함되어 있는 정보는 아래와 같다
	- 조작 대상 객체
	- 객체에 대한 조작의 종류
	- 조작 대사이 되는 레코드 수

### 조작 대상 객체
- 실행할 SQL 구문의 조작 대상 객체를 나타낸다
- 여러 테이블을 사용하는 SQL 구문에서는 어떤 객체를 조작하는지 혼동하지 않게 주의가 필요하다
- 테이블 외에도 인덱스, 파티선, 시퀀스처럼 SQL 구문으로 저작할 수 있는 객체라면 무엇이든 올 수 있다

### 객체에 대한 조작의 종류
- 객체에 대한 조작의 종류는 실행 계획에서 가장 중요한 부분이다
- 오라클에서는 Operation 필드로 나타낸다
	- TABLE ACCESS FULL: 테이블 풀 스캔
	- INDEX UNIQUE SCAN: 인덱스 스캔
	- 인덱스 스캔은 B-tree가 모집합의 데이터의 양에 따라 함수적으로 처리비용이 늘어나기 때문에 일반적으로 테이블 풀 스캔보다 빠르다

### 조작 대상이 되는 레코드 수
- 결합 또는 집약이 포함되면 1개의 SQL 구문을 실행해도 여러 개의 조작이 수행된다
- 그러면 각 조작에서 얼마만큼의 레코드가 처리되는지가 SQL 구문 전체의 실행 비용을 파악하는데 중요한 지표가 된다
- 여기서 레코드 수는 실제 레코드 수가 아닌 카탈로그로 부터 얻은 레코드 수이다
- 옵티마이저는 통계라는 메타 정보를 믿기 때문에 실제 테이블을 제대로 보지 않는다

## 2. 테이블 결합 알고리즘
- 결합을 사용하면 실행 계획이 상당히 복잡해지므로 옵티마이저도 최적의 실행 계획을 세우기 어렵다
- 따라서 결합시 실행 계획의 특성을 공부하는 것은 중요하다
- DBMS에서 결합시 3가지 알고리즘을 사용한다

### Nested Loops
- 한쪽 테이블을 읽으면서 레코드 하나마다 결합 조건에 맞는 레코드를 다른 쪽 테이블에서 찾는 방식
- 절차 지향형 언어로 구현 한다면 이중 반복이므로 중첩 방복이라는 이름이 붙었다

### Short Merge
- 결합 키로 레코드를 정렬하고 순차적으로 두 개의 테이블을 결합하는 방법이다
- 결합전 전처리로 정렬을 수행할 때 워킹 메모리를 사용한다

### Hash
- 결합 키값을 해시값으로 매핑하는 방법
- 워킹 메모리를 사용한다

- 결합 전의 경우 어떤 테이블에 먼저 접근하는 지가 굉장히 중요하다
- 같은 중첩 단계에서는 실행 계획상 위에서 아래로 실행된다