### 유스케이스 둘러보기
- 유스케이스는 다음과 같은 단계를 따른다
	1. 입력을 받는다
	2. 비즈니스 규칙을 검증한다
	3. 모델 상태를 조작한다
	4. 출력을 반환한다

- 유스케이스 코드가 도메인 로직에만 신경써야지, 입력 유효성 검증으로 오염되면 안 된다.

### 입력 유효성 검증
- 입력 유효성 검증인 유스케이스의 책임은 아니지만 애플리케이션 계층의 책임에 해당한다
	- 애플리케이션 코어 바깥으로부터 유효하지 않은 입력값을 받게 되고, 모델의 상태를 해칠 수 있기 때문이다
- **입력 모델**이 입력 유효성을 검증 하도록 한다
	- 생성자에서 유효성 검증, Bean Validation API를 사용할 수 있다
	- 생성자는 빌더와 달리 새로운 필드를 추가 혹은 제거할 때마다 컴파일 에러를 따라 수정할 수 있다

- **입력 모델은 유스케이스마다** 만드는 것이 좋다
	- 유스케이스를 더 명확하게 만든다
	- 다른 유스케이스와 결합도 제거하여 부수효과가 발생하지 않게 한다
### 비즈니스 규칙 검증하기
- 비즈니스 규칙은 유스케이스 로직의 일부다
- 입력 유효성을 검증하는 것은 **구문상**의 유효성을 검증하는 것이고, 비즈니스 규칙은 유스케이스 맥락 속에서 **의미적인** 유효성 검증을 하는 것이다
- 둘의 실용적인 구분 방법은 **비즈니스 규칙은 모델의 현재 상태**에 접근해야 한다는 것이다
	- '출금 계좌는 초과 출금되어서는 안 된다'는 현재 상태에 접근해야 한다
	- '송금액은 0보다 커야한다'는 모델에 직접 접근하지 않아도 검증 가능하다
- 비즈니스 규칙을 구현하는 가장 좋은 방법은 비즈니스 규칙을 도메인 엔티티 안에 넣는 것이다
	- 차선으로 유스케이스에서 비즈니스 규칙을 검증할 수도 있다

### 풍부한 도메인 모델 VS 빈약한 도메인 모델
- 풍부한 도메인 모델
	- 엔티티에서 가능한 많은 도메인 로직이 구현된 모델
	- 유스케이스는 진입점으로 동작
- 빈약한 도메인 모델
	- getter, setter 수준의 메서드만 포함한 얇은 모델
	- 유스케이스에 검증, 상태 변경, 저장하는 책임 모두 있음

### 유스케이스마다 다른 출력 모델
- 출력도 가능하면 각 유스케이스에 맞게 구체적일 수록 좋다
- 출력 모델은 호출자에게 필요한 데이터만 가지고 있어야 한다
- 유스케이스간 출력 모델을 공유하면 유스케이스들도 강하게 결합된다

### 읽기 전용 유스케이스
- 읽기 전용 유스케이스를 따로 만든다면 명확하게 구분된다
- 이러한점은 CQS, CQRS 같은 개념과 아주 잘 맞는다