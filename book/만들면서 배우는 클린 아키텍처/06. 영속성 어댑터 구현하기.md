## 의존성 역전

<img width="830" alt="image" src="https://github.com/seung-hun-h/record/assets/60502370/ff04f574-b1cf-4577-97c5-5a88575ff9d8">

- 영속성 어댑터는 '아웃고잉' 혹은 '주도되는' 어댑터다
	- 애플리케이션이 호출할 뿐, 애플리케이션을 호출하지 않는다
- 영속성 계층에 대한 의존성을 없애기 위해 '포트'라는 간접 계층을 추가했다

## 영속성 어댑터의 책임
1. 입력을 받는다
2. 입력을 데이터베이스 포맷으로 매핑한다
3. 입력을 데이터베이스로 보낸다
4. 데이터베이스 출력을 애플리케이션 포맷으로 매핑한다
5. 출력을 반환한다

- 입력과 출력 모델이 영속성 어댑터가 아니라 **애플리케이션 코어에 위치**하는 것이 중요하다

## 포트 인터페이스 나누기

<img width="843" alt="image" src="https://github.com/seung-hun-h/record/assets/60502370/d0b8dfc7-52be-4bb7-bd36-1983ff68c49c">

- 특정 엔티티가 필요로하는 모든 데이터베이스 연산을 하나의 레포지토리에 두는 것이 일반적이다
	- 이렇게되면 각 서비스는 '넓은' 포트 인터페이스에 의존성을 갖게 된다
- '인터페이스 분리 원칙'을 적용하여 각 서비스가 실제 필요로하는 메서드에만 의존한다
- 모든 상황에 '포트 하나당 하나의 메서드'를 적용할 수는 없다
	- 응집성이 높고 함께 사용될 때가 많은 메서드는 하나의 인터페이스로 묶을 수 있다

## 영속성 어댑터 나누기

<img width="815" alt="image" src="https://github.com/seung-hun-h/record/assets/60502370/9ccb311e-139d-4fd8-becc-03f426d6d8ef">

- 영속성 어댑터를 구현할 때 하나 이상의 클래스 생성을 금지하는 규칙은 없다
- 영속성 연산이 필요한 도메인 클래스 하나당 하나의 영속성 어댑터를 구현할 수도 있다

## 데이터 베이스 트랜잭션
- 트랜잭션을 열고 닫는 책임은 영속성 어댑터 호출을 관장하는 서비스에 위임해야 한다
	- 영속성 어댑터는 어떤 데이터베이스 연산이 같은 유스케이스에 포함되는지 알 수 없다