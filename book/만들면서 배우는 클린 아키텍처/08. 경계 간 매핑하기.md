## 매핑하지 않기
- 포트 인터페이스가 도메인 모델을 입출력 모델로 사용하는 경우다
- 도메인 모델에 웹, 애플리케이션, 영속성 계층과 관련된 이유로 변경될 수 있으므로 **단일 책임 원칙**을 위반한다
	- 웹 계층을 위한 JSON 관련 애너테이션
	- 영속성 계층을 위한 JPA 관련 애너테이션
- 각 계층이 도메인 모델에 특정 커스텀 필드를 두도록 요구할 수 있다
	- 한 계층에서만 필요로하는 필드를 포함하는 파편화된 도메인 모델로 이어질 수 있다
- 모든 계층이 정확히 같은 구조, 정확히 같은 정보를 필요로한다면 '매핑하지 않기' 전략은 적절하다
	- 애플리케이션 계층이나 도메인 계층에서 웹과 영속성 관련 문제를 다루게되면 곧 바로 다른 전략을 취해야 한다
- 어떤 매핑 전략을 취하더라도 나중에 언제든지 바꿀 수 있다

## 양방향 매핑 
- 각 계층이 전용 모델을 가진 매핑 전략
	- 각 계층이 전용 모델을 변경하더라도 다른 계층에는 영향이 없다
- '매핑 하지 않기' 전략 다음으로 간단한 전략이다
	- 매핑 책임이 명확하다
- 양방향 매핑은 '은총알'이 아니다
	- 너무 많은 보일러플레이트 코드가 생긴다
	- 도메인 모델이 계층 경계를 넘어서 통신하는데 사용된다

## 완전 매핑 전략
- 각 연산마다 별도의 입출력 모델을 사용한다
	- 계층의 경계를 넌ㅁ어 통신할 때 도메인 모델을 사용하는 대신 각 작업에 특화된 모델을 사용한다
- 웹 계층과 애플리케이션 계층 사이에섯 상태 변경 유스케이스의 경계를 명확하게 할 때 가장 빛을 발한다
- 애플리케이션 계층과 영속성 계층 사이에서는 매핑 오버헤드 때문에 사용하지 않는 것이 좋다
- 어떤 경우에는 연산의 입력 모델에 대해서만 이 매핑을 사용하고, 도메인 객체를 그대로 출력 모델로 사용하는 것도 좋다

## 단방향 매핑 전략
- 모든 계층의 모델들이 같은 인터페이스를 구현한다
- 인터페이스는 관련 있는 특성에 대한 getter 메서드를 제공해서 도메인 모델의 상태를 캡슐화한다
	- 행동을 변경하는 것이 인터페이스에 노출되어 있지 않으므로 실수로 도메인 객체의 상태를 변경하는 일은 발생하지 않는다
- 계층 간의 모델이 비슷할 때 가장 효과적이다

## 언제 어떤 매핑 전략을 사용할 것인가?
- 그때그떄 다르다
- 한 전략을 전체 코드에 대한 어떤 경우에도 변하지 않는 전역 규칙으로 정의하려는 충동을 이겨내야 한다
- 언제 어떤 전략을 사용하지 결정하기 위해 팀 내에서 합의할 수 있는 가이드라인을 정해둬야 한다