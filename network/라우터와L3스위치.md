# 라우터
---

라우터는 3 계층 장비로 경로를 지정해준다. 라우터에 들어오는 패킷의 목적지 IP 주소를 확인하고 자신이 가진 경로 정보를 통해서 패킷을 최적의 경로로 포워딩 한다.

<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/140916086-c81264a3-9c54-469b-86a2-013ece4e6e90.png width=500>
</p>

## 라우터 동작 방식과 역할

라우터는 다양한 경로 정보를 수집해 최적의 경로를 라우팅 테이블에 저장한 후 패킷이 라우터로 들어오면 도착지 IP 주소와 라우팅 테이블을 비교해 최선의 경로로 패킷을 보낸다.

스위치가 테이블에 MAC 주소가 없을 경우 플러딩 하는 것과 다르게 라우터는 IP 주소가 테이블에 존재하지 않을 경우 버린다.

라우터는 패킹 포워딩 과정에서 기존 2계층 헤더 정보를 버리고 새루운 2계층 헤더 정보를 만들어낸다

### 경로 지정
라우터는 경로를 지정해 패킷을 포워딩 하는 역할을 두 가지로 구분한다.

- 경로 정보를 얻는 역할
- 경로 정보를 확인하고 패킷을 포워딩 하는 역할

라우터는 다양한 방법으로 경로 정보를 얻을 수 있다. IP 주소를 입력하면서 자연스럽게 인접 네트워크 정보를 얻는 방법, 관리자가 직접 경로 정보를 입력하는 방법, 라우터끼리 서로 정보를 자동으로 교환하는 방법이 있다.

<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/140916791-903d88b5-732c-49e0-8cfc-8c215617ca0f.png width=500>
</p>

### 브로드 캐스트 컨트롤
스위치는 패킷이 도착하면 LAN 어딘가에 목적지가 존재한다고 믿고 플러딩한다. LAN은 크기가 작아 플러딩에 의한 영향이 작고 도착지의 NIC가 주소가 다르면 패킷을 버리기 떄문에 네트워크에 큰 무리를 주지 않는다.

반면 라우터는 패킷이 테이블에 없을 경우 버리는데, 인터넷 연결은 대부분 지정된 대역폭만 빌려사용하므로 쓸모 없는 통신이 네트워크를 차지하는 것을 막기 위함이다.

라우터는 기본적으로 멀티캐스트 정보를 습득하지 않고 브로드캐스트 패킷을 전달하지 않는다. 이 기능을 브로드캐스트/멀티캐스트 컨트롤이라고 한다.

### 프로토콜 변환
라우터의 또 다른 역할은 서로 다른 프로토콜로 구성된 네트워크를 연결하는 것이다.

<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/140917469-c5333651-2872-4260-9297-024271bead1e.png width=500>
</p>

라우터는 3계층에서 동작하는 장비이다. 패킷이 들어오면 2계층 헤더를 벗겨내어 3계층 주소 정보를 확인하고 새로운 2계층 헤더를 만들어 씌우고 위부로 내보낸다. 

이 기능을 이용하면 전혀 다른 기술간 변환이 가능하다. 저속 전용회선에서 WAN 구간은 PPP와 같은 WAN 프로토콜이 사용되고 LAN은 이더넷 프로토콜이 사용된다. LAN 구간의 패킷이 라우터를 지나면서 2계층까지의 헤더가 벗겨지고 WAN 구건으로 패킷이 나올 때 PPP 헤더로 변경되어 프로토콜이 변환된다.

# 경로 지정
---

라우터는 서브넷 단위로 라우팅 정보를 습득하고 라우팅 정보를 최적화 하기 위해 서머리 작업을 통해 여러 개의 서브넷 정보를 뭉쳐 전달한다.

그래서 라우터에 들어온 패킷의 목적지 주소와 라우터가 갖고 있는 라우팅 테이블 정보가 정확히 일치하지 않아도 목적지에 가장 근접한 정보를 찾아 패킷을 포워딩한다.

## 라우팅 동작과 라우팅 테이블

현대 인터넷에서는 목적지까지 경로를 모두 책짐지는 것이 아니라 인접한 라우터까지만 경로를 지정하면 해당 라우터에서 또 다시 인접한 라우터까지 경로를 지정한다.

이 기법을 홉-바이-홉 라우팅이라하고 인접한 라우터를 넥스트 홉(Next hop)이라 한다.

넥스트 홉 지정 방식은 일반적으로 다음 3가지를 따른다

1. 다음 라우터의 IP를 지정하는 방법
2. 라우터의 나가는 인터페이스를 지정하는 방법
3. 라우터의 나가는 인터페이스와 다음 라우터의 IP를 동시에 지정하는 방법


일반적으로는 라우터 인터페이스의 IP 주소를 지정하는 방법을 사용한다. 특수한 경우에먼 라우터의 나가는 인터페이스를 지정하는 방법을 사용하는데, 상대방 넥스트 홉 라우터의 IP를 모르더라도 MAC 주소 정보를 알아낼 수 있을 때만 사용할 수 있다.

라우터는 출발지와 상관 없이 목적지 주소와 라우팅 테이블을 비교해 어느 경로로 포워딩할 지 결정한다. 라우팅 테이블에 저장하는 데이터는 다음과 같다

- 목적지 주소
- 넥스트 홉 IP 주소, 나가는 로컬 인터페이스

패킷이 영구적으로 사라지지 않는다면 동일한 패킷이 핑퐁을 치거나 인터넷에서 사라지지 않는 유령 패킷이 넘쳐날 것이다. 그래서 모든 패킷은 TTL이라는 수명 값을 가지고 있고 0이되면 네트워크에서 버려진다. TTL은 실제 초와 같은 시간이 아니라 홉을 지칭하며 홉을 지날때 마다 TTL이 감소한다.

<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/140919239-86323175-4ae7-40d0-a80e-5216c5daad22.png width=500>
</p>

## 라우팅
### 다이렉트 커넥티드
IP 주소를 입력할 때 사용된 IP 주소와 서브넷 마스크로 해당 IP 주소가 속한 네트워크 주소 정보를 알 수 있다. 라우터나 PC에서는 이 정보로 네트워크에 대한 라우팅 테이블을 자동으로 만든다. 이 경로 정보를 다이렉트 커넥티드라고한다.

### 스태틱 라우팅
관리자가 목적지 네트워크와 넥스트 홉을 라우터에 직접 지정해 경로 정보를 입력하는 것을 스태틱 라우팅이라한다.

### 다이나믹 라우팅
스태틱 라우팅은 관리자가 변화가 적은 네트워크에서 손쉽게 사용할 수 있는 방법이지만, 라우터 사이의 회선이나 라우터에 장애 상황을 파악하여 대처하기 어렵다.

다이나믹 라우팅은 라우터끼리 자신이 알고있는 경로 정보나 링크 상태 정보를 교환해 전체 네트워크 정보를 학습하여 스태틱 라우터의 단점을 보완한다. 대부분의 경우 다이나믹 라우팅을 사용한다.

<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/140920067-5831cd5b-f2ad-4a13-9e3a-dcc5111683ad.png width=500>
</p>

다이나믹 라우팅에서는 자신이 광고할 네트워크를 선언해주어야 한다. 

라우터에서 라우팅의 역할은 경로 정보를 얻는 것뿐 아니라 다양한 경로 정보를 체계적으로 데이터베이스화하고 순위를 적절히 부여해 최선의 경로 정보만을 수집하는 것이다.

패킷을 포워딩할 때 최적의 경로를 찾는 작업을 단순화하기 위해 라우팅 정보를 저장할 때 최적의 경로만 추려 별도의 테이블에 미리 보관한다.

라우터가 수집한 경로 정보, 원시 데이터를 토폴로지 테이블이라하고, 경로 정보 중 최적의 경로를 저장하는 테이블을 라우팅 테이블이라한다.

중요한 개념은 패킷을 보낼 때 전체 경로를 고려하는 것이 아니라 **다음 라우터까지만 패킷을 포워딩** 하는 것이다.

### 스위칭(경로 지정 방법)
라우터가 다양한 방법으로 경로 정보를 얻고 그 정보 중 최적의 경로를 라우팅 테이블에 올려 유지하는 것을 라우팅이라한다.

그리고 패킷이 들어와 라우팅 테이블을 참조하고 최적의 경로를 찾아 **라우터 위부로 포워딩하는 작업을 스위칭**이라고 한다.

라우터는 라우팅 테이블에서 도착지 IP와 가장 가깝게 매칭되는 경로 정보를 찾는다. 이 기법을 롱기스트 프리픽스 매치(Longest Prefix Match)라고 한다.

이 작업은 많은 부하가 걸리기 때문에 라우터는 한 번 스위칭 작업을 수행한 정보는 캐시에 저장하고 뒤에 들어오는 패킷은 라우팅 테이블을 확인하는 것이 아니라 캐시를 먼저 확인한다.

### 다이나믹 라우팅
네트워크가 몇개 없는 간단한 네트워크에서는 스태틱 라우팅으로 망을 유지하는 것이 가능하지만 일반적으로 IT 환경을 구축할 때는 SPoF(Single Point of Failure 단일 장애점)를 없애기 위해 두 개 이상의 경로를 유지하는 경우 대체 경로에 대한 고민이 필요하다.

대체 경로가 필요한 경우 스태틱 라우팅만으로는 네트워크 상태가 변경될 때 신속한 대응을 할 수가 없고, 관리해야할 라우터와 네트워크가 많아지만 스태틱 라우팅으로 구성하고 관리하기 어려워진다.

다이나믹 라우팅 프로토콜을 사용하면 라우팅 관리자의 직접적인 개입 없이 라우터끼리 정보를 교환해 경로 정보를 최신으로 유지할 수 있다. 

<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/140927717-c70cac37-2be6-43a8-a57f-79e2d01680d9.png width=500>
</p>

그림처럼 다양한 라우팅 프로토콜이 있지만, 최근에는 OSPF와 BGP 프로토콜이 주로 사용된다. 

유니캐스트 경로 정보를 교환하는 라우팅 프로토콜과 멀티캐스트 경로 정보를 교환하는 라우팅 프로토콜이 별도로 존재한다. 

**역할에 따른 분류**

일반적인 라우팅 프로토콜은 유니캐스트 프로토콜을 말한다. 인터넷에는 AS(Autonomous System)이라는 자율 시스템이 존재한다. SKT, KT, LGU+와 같은 사업자가 한개 이상의 AS를 운영한다. AS 내부에서 사요하는 라우팅 프로토콜을 IGP(Interior Gateway Protocol)라고 하고 AS간 통신에 사용하는 라우팅 프로토콜을 EGP(Exterior Gateway Protocol)라고 한다.

AS 내부 연결은 효율성이 중요하지만 AS간 연결은 효율성보다 조직간 정책이 더 중요하다.

<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/140931975-7df77960-70df-44bb-8a5f-3aec9d250006.png width=700>
</p>

**동작 원리에 따른 분류**

IGP 라우팅 프로토콜은 동작 원리에 따라 크게 디스턴스 벡터, 링크 스테이트로 나뉜다. 두 동작 원리의 장, 단점을 적절히 배합해 기능을 향상시킨 어드밴스드 디스턴스 벡터가 있지만 특정 회사가 만든 라우팅 프로토콜은 최근에는 많이 사용되지 않는다.

디스턴스 벡터는 인접한 라우터에서 경로 정보를 습득하는 라우팅 프로토콜이다. 디스턴스 벡터는 인접하지 않는 라우터에 대한 정보는 인접한 라우터를 통해 간접적으로 전달 받는다. 인접 라우터가 이미 계산한 결과물인 라우팅 테이블을 전달 받고 계산하므로 라우팅 정보 처리에 많은 리소스가 필요 없다는 장점이있다.

인접 라우터만 직접 경로 정보를 교환하여 멀리 떨어진 라우터의 경로 정보를 얻는 데 많은 라우터를 거쳐 모든 라우터 정보가 동기화 되는데 많은 시간이 필요하다.

<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/140950604-009e05ed-8676-498f-8420-e5f5e8957e08.png width=700>
</p>

링크 스테이트는 라우터에 연결된 링크 상태를 서로 교환하고 각 네트워크 맵을 그리는 라우팅 프로토콜이다. 링크 스테이트는 용어 그대로 라우터들에 연결된 링크 상태를 교환하는 라우팅 프로토콜이다. 링크 상태를 교환하므로 최적의 경로를 연산 결과물인 라우팅 테이블과 달리 직접적인 상태 정보를 받아 볼 수 있다.

<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/140950914-5cbdbf78-2348-4258-ac86-532d6af4e4a3.png width=700>
</p>

최단 경로 트리를 이용해 최적의 경로를 선정한 후 라우팅 테이블에 그 정보를 추가한다. 링크 스테이트 라우팅 프로토콜은 이미 최적의 경로를 연산한 정보를 받는 것이 아니라 전체 네트워크 링크 상태 정보를 받아 각자 처리하므로 전체 네트워크 맵을 그리고 경로 변화를 파악하는데 유리하다.

하지만 이런 작업이 부하로 작요할 수 있어 네트워크 규모가 커지면 네트워크 경로를 파악하는 데 CPU와 메모리 자원을 많이 소모한다.

따라서 네트워크 변화를 더 빨리 감지하고 리소스를 최적화하기 위해 네트워크 에어리어 단위로 분리하고 분리된 에어리어 내에서만 링크 상태 정보를 교환한다.

<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/140951712-2cd7d43c-f656-45ca-9c6d-5ca4836c9291.png width=700>
</p>
