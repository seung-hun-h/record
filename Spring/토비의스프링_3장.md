# 3장 템플릿

## JDBC 리소스 반환
JDBC의 Connection 이나 PrepareStatement는 풀 방식으로 동작한다. 여기서 풀 방식은 제한된 개수의 DB 커넥션을 만들어서 재사용 가능한 풀을 만드는 것을 의미한다. 리소스 반환을 위해 `close()` 메소드를 호출하는데, 만약 예상치 못한 에러로 인해 리소스를 반환하지 못한다면 커넥션 풀의 여유가 없어지고 결국 리소스가 모자라는 에러를 발생시킬 수 있다.

```java
public void deleteAll() {
    Connection c = dataSource.getConnection();

    PrepareStatement statement = c.prepareStatement("DELETE FROM users");
    statement.executeUpdate();

    --- 여기서 예외가 발생하면 메소드 실행이 중단되고, 리소스를 반환할 수 없게된다. ---
    
    statement.close();
    c.close();
}
```

이러한 예상치 못한 예외에서도 로직을 수행하기 위해 `try - catch - finally` 구문을 사용한다. `finally` 구문에서는 예외가 발생해도 반드시 실행해야하는 로직이 작성된다.

## 전략 패턴

오브젝트를 아예 둘로 분리하고 클래스 레벨에서는 인터페이스를 통해서만 의존하도록만드는 패턴이다. 

<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/130593121-e2be3a10-248c-4c44-b29e-6392a5942477.png height=250>
</p>

Conext의 `ContextMethod()`를 통해서 일정한 구조를 가지고 동작하다가 특정 확장 기능은 Strategy 인터페이스를 통해 외부의 독립된 전략 클래스에 위임하는 것이다.<br/>

전략 패턴에 따르면 Context가 어떤 전략을 사용하게 할 것인가는 Context를 사용하는 앞단의 Client가 결정하는 것이 일반적이다. Client가 구체적인 전략의 하나를 선택하고 오브젝트로 만들어서 Context에 전달하는 것이다.<br/>

전략 오브젝트를 생성하고 컨텍스트로의 전달을 담당하는 책임을 분리하기 위해 `ObjectFactory`를 사용할 수 있고, 이를 일반화 한 것이 DI이다. 결국 DI는 전략 패턴의 장점을 일반적으로 활용할 수 있도록 만든 구조이다.

### 마이크로 DI
DI는 다양한 형태로 적용할 수 있다. 핵심은 제 3자의 도움을 통해 두 오브젝트 사이의 유연한 관계가 설정되도록 만든다는 것이다.<br/>

DI가 매우 작인 단위의 코드와 메소드 사이에서 발생하는 경우도 있다. DI의 장점을 단순화해서 IoC 컨테이너의 도움 없이 코드내에서 적용한 것을 마이크로 DI라고 한다.

## 자동 DI, 수동 DI

### 스프링 빈으로 DI

의존관계 주입의 개념을 충실히 따르면, 인터페이스를 사이에 두고 클래스 레벨에서 의존관계가 고정되지 않게하고, 런타임에 다이내믹한 의존 관계를 형성해준다. 하지만 그 의미를 좀 더 넓히면 객체의 생성과 관계 설정을 외부로 책임을 위임하는 IoC의 개념을 포괄한다.<br/>

인터페이스가 아닌 구체 클래스를 통해 DI 구조를 형성할 수 있는 경우는 아래 처럼 생각해볼 수 있다.
- 구체 클래스가 변경되는 상태 정보를 가지지 않고, 빈으로 등록되는 경우
- 구체 클래스가 DI를 통해 다른 빈에 의존하고 있는 경우
    - 구체 클래스가 컨테이너를 통해 DI를 받기 위해서라도 빈으로 등록되어 있어야 한다.

### 코드를 이용하는 DI
클래스를 스프링 빈으로 등록하지 않고 클래스 내부에서 직접 DI를 적용하는 방법이다. 객체를 싱글톤으로 관리하지 않기 때문에 여러 단점이 발생할 수 있지만 아래와 같은 조건이면 고려해볼 수 있다.

- 클래스 내부에 하나의 객체만 생성하여 사용할 수 있도록한다
- 의존을 주입할 객체가 상태정보가 없다

위 조건 하에서는 프로젝트가 거대화 되거나, 객체가 여러개 생성되어도 GC에 대한 부담이 적고 객체가 자주 생성되었다가 제거되지 않아서 수동 DI를 고려해볼만 하다.


## 템플릿/콜백
### 템플릿
템플릿은 어떤 목적을 위해 미리 만들어둔 모양이 있는 틀을 가리킨다. 프로그래밍에서 고정된 틀 안에 바꿀 수 있는 부분을 넣어서 사용하는 경우에 템플릿이라 부른다. 템플릿 메소드 패턴은 고정된 틀의 로직을 가진 템플릿 메소드를 슈퍼 클래스에 더고, 바뀌는 부분을 서브 클래스의 메소드에 두는 구조로 이뤄진다.<br/>

### 콜백
콜백은 실행되는 것을 목적으로 다른 오브젝트의 메소드에 전달되는 오브젝트를 말한다. 파라미터로 전달되지만 값을 참조하는 것을 위함이 아니라 특정 로직을 담은 메소드를 실행시키기 위해 사용한다. 자바에서는 메소드 자체를 전달할 수 있는 방법이 없기 때문에 메소드가 담긴 오브젝트를 전달하는데 이를 Functional Object라고 한다.<br/>

### 특징
일반적인 DI는 템플릿에 인스턴스 변수를 만들어 두고 사용할 의존 오브젝트를 수정자 메소드로 받아서 사용할 것이다. 하지만 템플릿/콜백 방식에서는 매번 메소드 단위로 사용할 오브젝트를 새롭게 전달 받는다.<br/>

템플릿/콜백 방식은 전략 패턴과 DI의 장점을 익명 내부 클래스 사용 전략과 결합한 독특한 방법이라고할 수 있다.