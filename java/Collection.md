# Collection
다수의 객체를 생성해 저장해두고 필요할 때마다 꺼내써야하는 경우가 많다. 이때 배열을 쓸 수도 있지만, 배열은 생성할 때 그 크기가 결정되어 불특정 다수의 객체를 다루기는 쉽지않다. 그리고 객체를 생성하고 삭제하는 과정에서 배열 중간 중간이 비어있을 수도 있어 이에 대한 부가작업이 필요하다.

자바에서는 널리 알려져있는 자료구조를 바탕으로 객체들을 효율적으로 조회, 삽입, 삭제 할 수 있도록 인터페이스와 클래스를 제공하는데 이를 Collection이라 한다.

컬렉션 프레임워크의 주요 인터페이로는 List, Map, Set이 있다.

## List
List는 객체를 일렬로 늘어놓은 구조를 가지고 있다. 객체를 인덱스로 관리하기 때문에 객체를 저장하면 자동 인덱스가 부여되고 인덱스로 객체를 검색, 삭제할 수 있는 기능을 제공한다. 컬렉션은 객체 자체를 저장하는 것이 아니라 객체의 참조 값을 저장하기 때문에 null도 허용한다.

### ArrayList
List 인터페이스의 구현체로 객체가 인덱스로 관리된다. 일반 배열과 ArrayList는 인덱스로 객체를 관리한다는 점에서 유사하지만 ArrayList는 저장 용량이 동적으로 늘어난다는 것에서 차이가 있다.

ArrayList에서 객체를 중간에 삽입하면 자동적으로 이후 객체들이 뒤로 밀려나고, 삭제한 경우 당겨진다. 따라서 객체의 삽입과 삭제가 빈번한 경우 ArrayList를 사용하는 것은 적절하지 않을 수 있다. 인덱스 검색이나 맨 마지막에 객체를 추가하는 경우에는 ArrayList가 적절할 수 있다.

### Vector
Vector는 ArrayList와 동일한 내부구조를 가지고있다. 차이점은 동기화를 제공한다는 것이다. 이를 통해 멀티 스레딩 환경에서도 안전하게 객체를 삽입, 삭제할 수 있다. 이것을 스레드 안전(Thread-safe)하다고 한다.

단점은 동기화를 제공하기 때문에 성능에 저하가있다.

### LinkedList
List의 구현체로 ArrayList와 사용 방법은 동일하지만 내부 구조가 완전히 다르다. ArrayList는 내부에서 배열에 객체를 저장해 인덱스로 관리하지만, LinkedList는 인접 참조를 링크해서 체인처럼 관리한다. LinkedList는 특정 인덱스의 객체를 제거하면 앞뒤 링크만 변경되고 나머지 링크는 변경되지 않는다. 따라서 빈번한 객체 삭제와 삽입이 일어나는 곳에는 ArrayList보다 LinkedList가 좋은 성능을 발휘한다.

끝에서 부터 순차적으로 추가/삭제하는 경우는 ArrayList가 빠르지만, 중간에 추가 또는 삭제할 경우는 LinkedList가 더 빠르다.

## Set
List 컬렉션은 저장 순서를 유지하지만 Set 컬렉션은 순서를 유지 하지 않는다. Set은 수학의 집합에 비유될 수 있는데 집합은 순서와 상관 없고 중복을 허용하지 않는다. Set은 인덱스로 관리하지 않기 때문에 인덱스를 매개 값으로 갖는 메소드가 없다.

### HashSet
HashSet은 객체들을 순서 없이 저장하고 동일한 객체는 중복 저장하지 않는다. HashSet은 동일한 객체를 판단하기 위해서 `hashCode()` 메소드를 호출해서 해시 코드를 얻어낸다. 동일한 해시 코드가 있으면 다시 `equals()` 메소드로 비교해서 다를 경우에만 저장한다.

## Map
Map은 키와 값으로 구성된 Entry 객체를 저장하는 구조를 가지고 있다. 키는 중복 저장될 수 없지만 값은 중복 저장될 수 있다. 키로 객체들을 관리하기 때문에 키와 관련한 메소드가 많다.

### HashMap
HashMap의 키로 사용할 객체는 `hashCode()`와 `equals()` 메소드를 재정의해서 동등 객체가 될 조건을 정해야한다. 동등한 객체가 될 조건은 hashCode()의 반환 값이 같아야하고 equals()가 true를 반환해야 한다.

### HashTable
HashMap과 동일한 내부 구조를 가지고 있다. HashMap과 차이점은 동기화된 메소드를 제공한다는 점이다. 따라서 Thread-safe하고 성능은 떨어진다.

### Properties
HashTable의 하위 클래스이다. HashTable과 차이점은 Properties는 키와 값을 String 타입으로 제한한다는 것이다. Properties는 주로 애플리케이션의 정보, 데이터베이스 연결 정보, 국제화 정보가 저장된 .properties 파일을 읽을 때 사용한다.

## 검색 기능을 강화시킨 컬렉션들
### TreeSet
이진 트리를 기반으로한 Set 컬렉션이다. 하나의 노드는 노드 값인 value, 두 노드는 왼쪽과 오른쪽 자식을 참조하기 위해 사용한다. TreeSet에 객체를 저장하면 자동으로 정렬되는데 부모값과 비교해서 낮은 것은 왼쪽, 높은 것은 오른쪽에 저장한다.

### TreeMap
이진 트리를 기반으로 한 Map 컬렉션이다. TreeSet과 차이점은 Map.Entry를 저장한다는 점이다.

### Comparable과 Comparator
TreeSet과 TreeMap은 Comparable을 구현한 객체를 요구한다. 래퍼 클래스는 모두 Comparable를 구현한다. 사용자 정의 클래스도 Comparable을 구현하면 사용가능하다. 

## LIFO와 FIFO 컬렉션
LIFO는 나중에 넣은 객체가 먼저 빠져나가는 자료구조이고, FIFO는 먼저 넣은 객체가 먼저 빠져나가는 자료구조이다. 컬렉션 프레임 워크에는 LIFO 자료구조를 제공하는 스택과 FIFO 자료구조를 제공하는 큐가 있다.

스택을 응용한 대표적인 예가 JVM의 스택 메모리이고, 큐를 응용한 대표적인 예가 스레드 풀의 작업 큐이다.


## 동기화된 컬렉션
Vector와 HashTable은 동기화된 메서드를 제공하기 때문에 멀티 스레드 환경에서 사용할 수 있지만 ArrayList, LinkedList, HashMap은 Thread-safe하지 않아 사용할 수 없다. 컬렉션은 동기화된 메소드를 제공하기 위해서 synchronizedXXX() 메소드를 제공한다. 매개값으로 비동기화된 컬렉션을 제공하면 동기화된 컬렉션을 리턴한다.

## 병렬 처리를 위한 컬렉션
동기화된 컬렉션은 멀티 스레드 환경에서 하나의 스레드가 요소를 안전하게 처리하도록 도와주지만 전체 요소를 빠르게 처리할 수는 없다. 자바는 멀티 스레드가 컬렉션의 요소를 병렬적으로 처리할 수 있도록 특별한 컬렉션을 제공하고 있다. ConcurrentHashMap과 ConcurrentLinkedQueue이다.

ConcurrentHashMap은 전체 잠금이 아닌 부분 잠금을 제공한다. 예를 들어 컬렉션에 10개의 객체가 저장되어 있고, 한 컬렉션을 수정할 때 컬렉션 전체를 잠금하면 전체 잠금이고, 수정할 객체만 잠금하면 부분 잠금이다.

ConcurrentLinkedQueue는 락-프리 알고리즘을 구현한 것이다. 락-프리 알고리즘은 여러 개의 스레드가 동시에 접근할 경우, 잠금을 사용하지 않고도 최소한 하나의 스레드가 안전하게 요소를 저장하거나 얻도록 해준다.

## hashCode()와 equals()
hashCode()와 equals()는 Object 클래스에 정의되어 있다.

### equals()
2 개의 객체가 동일한 지 검사하기 위해 사용된다. 재정의 하지 않은 상태에서는 다음과 같이 구현되어 있다.

```java
public boolean equals(Object obj) {
     return (this == obj);
}
```

String은 다른 인스턴스더라도 동일한 문자면 equals()가 true를 반환한다. 이는 String 클래스에서 재정의 되었기 때문이다.

### hashCode()
실행 중에 객체의 유일한 Integer 값을 반환한다. Object 클래스에서는 heap에 저장된 객체의 메모리 주소를 반환하도록 되어 있다.


### equals()와 hashCode()의 관계
동일한 객체는 동일한 메모리 주소를 갖는다는 것을 의미한다. 즉, 동일한 객체는 동일한 해시코드를 가져야한다. 따라서 equals() 메소드를 재정의 한다면 hashCode() 메소드도 재정의 해야한다

- 자바 프로그램을 실행하는 동안 equals에 사용된 정보가 수정되지 않았다면, hashCode는 항상 동일한 값을 반환해야한다
- 두 객체가 equals()에 의해 동일하다면 두 객체의 hashCode() 값도 일치해야한다
- 두 객체가 equals()에 의해 동일하지 않다면 두 객체의 hashCode() 값은 일치하지 않아도 된다.
