# 통신 방식
---
### 유니캐스트
- 1:1 통신 방식
- 출발지와 목적지가 1:1로 통신한다.
- 실제로 대부분의 통신은 유니캐스트 통신이다
### 브로드캐스트
- 1:모든 통신 방식
- 동일 네트워크에 존재하는 모든 호스트가 목적지
- 유니캐스트로 통신하기 전, 상대방의 정확한 위치를 알기 위해 사용한다.
- 기본 동작은 로컬 네트워크 내에서 모든 호스트에 패킷을 전달할 때 사용
### 멀티캐스트
- 1:그룹(멀티캐스트 구독 호스트) 통신
- 하나의 출발지에서 다수의 특정 목적지로 데이터 전송
- 사내 방송이나 증권 시세 전송과 같이 단방향으로 다수에게 동시에 같은 내용을 전달할 때 사용한다.

### 애니캐스트
- 1:1(동일 그룹 내의 1개 호스트)
- 다수의 동일 그룹 중 가장 가까운 호스트에서 응답   
- 가장 가까운 호스트나 가장 효율적으로 통신할 수 있는 호스트와 통신하는 방식이다.
- 가장 가까운 DNS 서버를 찾을떄나, 가장 가까운 게이트웨이를 찾을 때 사용한다.

### 유니캐스트 VS 애니캐스트
최종 통신 방식은 1:1로 동일하다. 하지만 유니캐스트는 출발지와 목적지가 단 한대인 반면, 애니캐스트는 목적지의 후보군이 다수라는 차이가 있다.

통신 방식을 구분할때 중요한 점은, 출발지가 기준이 아니라 목적지 주소를 기준으로 구분한다는 것이다.

### BUM 트래픽
- Broadcast + Unknown Unicast + Multicast
  - 서로 다른 트래픽이지만 네트워크에서 동작 방식이 비슷하다
- Unknown Unicast: 목적지 주소는 명확하지만 네트워크에서 동작은 브로트캐스트와 동일한 경우
  - 목적지가 아닌 NIC는 패킷을 버린다.
  - 스위치가 목적지에 대한 주소를 학습하지 못한 상황에 패킷을 플러딩한다.

- 이더넷 환경에서는 ARP 브로드캐스트를 먼저 보내고 이후 통신을 시작하므로 BUM 트래픽이 많이 발생하지는 않는다.



# MAC 주소
---

MAC(Media Access Control)은 2계층에서 통신을 위해 네트워크 인터페이스에 할당된 고유 식별자이다. 네트워크에 접속하는 모든 장비는 MAC 주소라는 물리적인 주소가 있어야 하고 이 주소를 통해 서로 통신하게 된다.

## 주소 체계
MAC 주소는 48비트의 16진수 12자리로 표현된다. 48비트 주소는 다시 24비트, 24비트로 나누어 구분한다. 앞의 24비트는 제조사 코드가 위치하고 뒤의 24비트는 각 제조사에서 자체적으로 할당하여 네트워크에서 각 장비를 구분할 수 있게 한다.

<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/140734033-e836c01f-a2f4-48d0-8b07-7a98e9645e97.png width=500>
</p>

## MAC 주소 동작 방식
1. NIC는 전기 신호가 들어오면 전기 신호를 데이터 형태(Frame?)으로 변환한다.
2. 목적지 MAC 주소와 출발지 MAC 주소를 확인한다.
   1. 만약 목적지 MAC주소와 자신의 MAC주소가 같으면 상위 계층으로 넘긴다.
   2. 다르면 폐기한다

# IP 주소
----
사용자가 변경 가능한 논리 주소이다. 주소에 레벨이 있고 그룹을 의미하는 네트워크 주소와 호스트 주소로 나뉜다.

## IP 주소 체계
흔히 사용하는 IP주소는 32비트 주소인 IPv4이다.
<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/140734693-6256d764-3fb6-4985-be96-0c093ab6d774.png width=500>
</p>

IP는 v4, v6 두 체계가 있고 v6은 128비트 주소 체계이다. MAC 주소가 16진수로 표기된 것과 다르게 IP주소는 10진수로 표기한다.

네트워크 주소는 호스트들을 모은 네트워크를 지징하는 주소이다. 네트워크 주소가 동일한 네트워크를 로컬 네트워크라 한다.

호스트 주소는 하나의 네트워크 내에 존재하는 호스트를 구분하기 위한 주소이다.

IP주소는 MAC주소가 고정적인 크기로 분할되는 것과 다르게 유동적으로 네트워크와 호스트 주소가 분할된다.

## 클래스풀
IP주소는 네트워크와 호스트 주소가 유동적으로 구분된다. 만약 네트워크 주소의 범위가 작으면 많은 호스트를 가질 수 있고, 네트워크 주소 범위가 커지면 비교적 적은 호스트를 가질 수 있을 것이다.

**네트워크 주소 범위를 클래스 별로 설정**하여 각 조직에 배분하는 방식을 클래풀이라 한다.

<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/140877655-2454a524-9dfc-479b-9e01-fc2c6d242fba.png width=500>
</p>

- A클래스: 네트워크 주소 1옥텟 + 호스트 주소 3옥텟
- B클래스: 네트워크 주소 2옥텟 + 호스트 주소 2옥텟
- C클래스: 네트워크 주소 3옥텟 + 호스트 주소 1옥텟

클래스 기반의 IP주소 체계에서는 옥텟의 위치를 통해 클래스를 구분할 수 있다. 

## 클래스리스
클래스풀 IP 주소는 네트워크 주소와 호스트 주소를 구분 짓는 구분자인 서브넷 마스크가 필요하지 않다. 맨 앞자리 주소만 보고 해당 주소가 어느 클래스에 위치한 지 알 수 있기 때문이다.

하지만 인터넷이 상용화되면서 클래스풀 주소 체계는 급속도로 늘어나는 IP 주소에 대한 요구를 감당할 수 없었고, 다음과 같은 문제점들이 있었다.

- 하나의 네트워크에서 IP를 사용하면 다른 네트워크에서 그 IP를 사용하지 못했다
- IPv4의 크기가 작았다.
- 상위 클래스(A class)를 할당 받은 조직이 주소를 제대로 활용하지 않았다.

이러한 문제점의 해결책으로 다음 3가지가 제안되었다.
- 단기: 클래스 리스기반 주소체계
- 중기: NAT와 사설 IP 주소
- 장기: IPv6


클래스의 개념을 버린 클래스리스기반 주소체계는 맨 앞의 숫자를 통해 네트워크 주소와 호스트 주소를 구분할 수 없었다. 클래스리스 네트워크에서는 별도의 구분자를 사용하는데 이를 **서브넷 마스크**라한다.

### 서브넷 마스크
서브넷 마스크는 IP 주소와 네트워크 주소를 구분할 때 사용하는 구분자이다. 2진수 숫자 1은 네트워크 주소, 0은 호스트 주소로 표시한다.

클래스를 서브넷 마스크로 나타내면 아래와 같다.
<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/140879111-f3f2bb02-595a-4880-9965-6bb7e377794c.png width=500>
</p>

IP 주소를 서브넷 마스크와 `& 연산`하면 네트워크 주소를 확인할 수 있다.

<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/140879606-770c5aee-994d-4e6a-aabb-db2321c084c1.png width=500>
</p>

### 서브 네팅
네트워크-호스트 구분 기준을 사용자가 정해, 원래 클래스풀 단위의 네트워크보다 더 쪼개 사용하는 것을 서브 네팅이라한다.

부여된 주소를 다시 잘라 사용해 서브네팅이라 부르는데 현대 클래스리스 네트워크의 가장 큰 특징이다.
<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/140881269-85bfe37f-e68b-4615-8512-b49420378e1a.png width=500>
</p>


## 공인IP와 사설IP

인터넷에 접속하기 위해서는 IP 주소가 필요하고 이 IP는 전세계에서 유일해야 하는 식별자이다. 이러한 IP 주소를 **공인IP**라고 한다.

인터넷에 연결하지 않고 개인적으로 네트워크를 구성한다면 공인IP 주소를 할당 받지 않고도 네트워크를 구축할 수 있다. 이때 사용하는 주소를 **사설IP 주소**라고 한다.

주로 인터넷에 접속하지 않거나 NAT(Network Address Translation)기술을 사용할 경우 사설IP 주소를 사용한다. 공유기가 대표적인 NAT 장비 중 하나이다.

NAT 기술을 사용하더라도 다른 사용자에게 이미 부여된 IP를 사설 IP 주소로 사용하면 안된다. 

### Bogon IP
IP 주소를 할당하는 최상위 기구인 IANA가 여러 가지 목적으로 예약해놓아 공인 IP로 할당하지 않는 주소를 BogonI라고 한다.

# TCP와 UDP
---

TCP와 UDP는 OSI 7계층 중 4계층에서 동작하는 프로토콜이다. 4계층의 목적은 목적지를 찾아가는 주소가 아니라 애플리케이션에서 사용하는 프로세스를 정확히 찾아가고 데이터를 분할한 패킷을 잘 쪼개 보내고 잘 조립하는 것이다.

데이터가 인캡슐레이션 및 디캡슐레이션 되면서 각 계층에서 정의하는 헤더가 추가되고 여러 가지 정보가 들어간다. 이때 가장 중요한 정보 두 가지는 다음과 같다.

- 각 계층에서 정의하는 정보
  - 동일 계층에서 사용하기 위한 정보
- 상위 프로토콜 지시자 정보
  - 상위 계층의 프로토콜이나 프로세스를 정확히 찾아가기 위한 정보

<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/140883313-7220c6b3-19f0-440e-8314-6f3dd9c740fe.png width=500>
</p>

패킷을 분할하고 조합하기 위해 TCP 프로토콜은 시퀀스 번호와 ACK를 번호를 사용한다. 반면 UDP는 신뢰성있는 데이터 통신을 보장하는 프로토콜이 아니기 때문에 해당 정보를 가지고 있지 않다.

<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/140883809-c054cc33-04ad-465c-9477-e250acaa555b.png width=500>
</p>

4 계층에서 상위 프로토콜 지시자는 포트 번호이다. 2 계층의 이더 타입이나 3 계층의 프로토콜 번호는 출발지와 목적지를 구분해 사용하지 않지만, 4 계층의 포트 번호는 구분해 처리한다. 포트에 따라 7 계층의 애플리케이션 프로토콜이 달라지기 때문이다.

2, 3 계층의 출발지, 목적지 주소는 상위 프로토콜 지시자가 아니다.

## TCP



TCP는 신뢰성 없는 네트워크망에서도 정보 유실 없는 통신을 보장하기 위해 **세션을 안전하게 연결**하고 **데이터를 분할하고 분할된 패킷이 잘 전송되었는 지 확인**하는 기능이 있다.

### 패킷 번호, 응답 번호
TCP는 분할된 패킷을 잘 분할하고 수신 측이 잘 조합하도록 패킷에 순서를 주고 응답 번호를 부여한다. 두 번호가 상호작용하여 순서가 바뀌거나 중간에 손실된 패킷을 확인할 수 있다.

<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/140884669-6524e2de-e569-4e73-afdd-67cfa68e2954.png width=500>
</p>

송신자가 패킷에 순서 번호(0)을 보내면, 수신자는 잘 받았다는 의미로 다음 순서번호를 패킷에 실어 보낸다(1).

### 윈도우 사이즈와 슬라이딩 윈도우
TCP는 일방적으로 패킷을 보내는 것이 아니라 얼마나 잘 받았는지 확인하기 위해 ACK 번호를 확인하고 다음 패킷을 전송한다.

TCP는 한 번에 하나의 패킷만 보내는 것이 아니라 일반적으로 많은 패킷을 한꺼번에 보내고 응답을 하나만 받는다. 가능한 많은 패킷을 보내는 것이 효율적이겠지만, 네트워크 상태가 좋지 않으면 패킷이 유실될 가능성도 크기 때문에 적절한 송신량을 결정한다.

한 번에 전송할 수 있는 데이터의 크기를 윈도우 사이즈라고 한다.

### 혼잡 제어
- **Addictive Increase**

전송한 패킷에 대해서 ACK를 받은 경우 윈도우 사이즈를 1씩 증가시키는 방법

- **Multiplicative Decrease**


ACK를 받지 못한 경우 윈도우 사이즈를 절반으로 줄이는 방법

- **Slow start**


윈도우 사이즈를 1로 시작한다. 전송에 성공한 패킷의 수 만큼 윈도우 사이즈를 증가시키는 방법이다. 즉 윈도우 크기가 1, 2, 4, 8 , 16, ... 2의 지수승 만큼증가한다.

그리고 네트워크 혼잡이 감지된 경우 그때 윈도우 사이즈를 Threshold로 기억하고 윈도우 사이즈를 1로 줄인다. 다시 윈도우를 2의 지수만큼 증가하다가 Threshold의 절반 크기가 된 경우 윈도우 사이즈를 1씩 늘린다.

- **Fast Retransmit**

패킷 하나가 중간에 유실된 경우 수신측은 유실된 패킷의 다음 시퀀스를 ACK에 실어 보낸다. 수신측은 유실된 패킷의 시퀀스를 중복적으로 보내고 시퀀스가 3번이 중복되면 송신측은 해당 패킷을 재전송한다.

- **Fast Recovery**

네트워크 혼잡이 감지되면 윈도우 사이즈를 1이 아닌 절반으로 줄이고 선형증가하는 방법이다. 이 정책은 처음 혼잡 상황을 겪은 뒤에는 계속 선형증가한다.

### 3 way handshake

TCP는 유실없는 안전한 통신을 위해 사전 연결작업을 수행한다. 패킷 네트워크에서는 동시에 많은 상대방과 통신하므로 정확한 통신을 위해서는 통신에 필요한 리소스를 미리 확보하는 것이 중요하다. TCP에서는 3번의 패킷을 주고받으며 통신을 주고 받아 3 way-handshake라 한다.


 <p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/140899565-9a7169dd-74db-4219-a656-996bd5529cdd.png width=500>
</p>

클라이언트의 마지막 패킷에는 연결이 완료되었음을 알리는 ACK 플래그와 함께 데이터도 전송할 수 있다.

## UDP

UDP는 TCP와 달리 4계층 프로토콜이 가져야 할 특징이 거의 없다. UDP는 신뢰성있는 통신을 보장하지 않으므로 TCP에 비해서 헤더의 크기도 작고 제한된 용도로 사용된다.

<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/140900179-d214ec08-8ce3-40de-a644-d64fdf5226a1.png width=500>
</p>

UDP는 데이터를 전송하는 데 신뢰성 보다는 일부 데이터가 유실되더라도 시간에 맞추어 계속 전송하는 것이 중요한 화상회의 시스템과 같은 서비스인 경우 사용한다.

## ARP

3 계층의 IP 주소와 2 계층의 MAC 주소는 아무 연관이 없다. MAC 주소는 NIC에 종속된 물리적 주소이며, IP는 유동적인 네트워크 인터페이스의 주소이다.

출발지의 IP 주소는 호스트가 임의로 설정하거나 DHCP를 통해 IP 주소를 할당 받는다. 그리고 목적지 IP 주소는 DNS 서버 등을 통해 알아낸다. MAC 주소는 ARP(Address Solution Protocol)을 통해 알아낸다.

ARP는 논리적인 IP 주소와 물리적인 MAC 주소를 연계 해주기 위한 메커니즘이다. 처음 호스트에서 통신을 시도할 때 목적지와 출발지 IP 주소, 출발지 MAC 주소는 이미 가지고 있지만 목적지의 MAC 주소는 가지고 있지 않아 2 계층에서 캡슐화 할 수 없다.

따라서 상대방의 MAC 주소를 알아내기 위해 ARP 브로드캐스트를 이용해 네트워크 전체에 상대방의 MAC 주소를 질의 해야한다.

### GARP
ARP가 상대방의 MAC 주소를 알아내기 위해 사용되는 반면 GARP 는 자신의 IP와 MAC 주소를 알리기 위해 사용된다. GARP를 사용하는 이유는 다음과 같다

1. IP 주소 충돌 금지

IP 주소는 유일하게 할당 되어야 하지만 내가 할당 받은 IP를 이미 다른 사람이 사용하고 있을 수 있다. 이를 예방하기 위해 현재 네트워크에서 자신의 IP가 이미 사용되고 있는 지 확인하기 위해 GARP를 사용한다.

2. 상대방 ARP 테이블 갱신

3. HA(고가용성) 용도의 클러스터링

# 서브넷과 게이트웨이
---

로컬 네트워크에서는 ARP 브로드캐스트를 이용해 도착지 MAC 주소를 학습할 수 있고 MAC 주소를 이용해 직접 통신할 수 있다.

하지만 원격 네트워크 통신은 네트워크를 넘어 전달되지 못하는 브로드캐스트의 성질 때문에 네트워크 장비의 도움이 필요하다. 이 장비를 게이트웨이라고 한다.

<p align=middle>
    <img src=https://user-images.githubusercontent.com/60502370/140902859-2a807958-c4a1-474f-9bed-1adcea35c189.png width=500>
</p>

출발지와 목적지 네트워크가 동일한 LAN에서 통신 하는 것 인지, 아니면 서로 다른 네트워크 간의 통신인지에 따라 통신 방식이 다르다. 따라서 네트워크의 범위를 확인해야하는데 이때 서브넷 마스크가 사용된다.

